window.package={"name":"projectx","version":"2015/04/09 22:14:07 UTC (0.0.1)","author":"Vigour.io <dev@vigour.io>","repository":{"type":"git","url":"https://github.com/vigour-io/vigour-native/examples/projectx","branch":"shawn-dev"},"main":"./make.js","engines":{"node":">=0.10.0"},"scripts":{"start":"gaston -d","build":"./bin/bin.js build"},"description":"example project that uses vigour-native plugins","bugs":{"url":"https://github.com/vigour-io/vigour-native/issues"},"dependencies":{"vigour-native-statusBar":"git+ssh://@github.com:vigour-io/vigour-native-statusBar.git#master"},"devDependencies":{"commander":"^2.7.1","vigour-dev-tools":"git+ssh://@github.com:vigour-io/vigour-dev-tools.git#dev","gaston":"git+ssh://@github.com:vigour-io/gaston.git#master"},"vigour":{"native":{"platforms":{"web":true,"ios":{"splash":{"src":"./img/splash-ios.png"},"productName":"Vigour Test App","organizationName":"Vigour","organizationIdentifier":"io.vigour.vigourTestApp","buildNumber":"10"},"android":{"packageName":"io.vigour.cloudandroidwrapper"},"wp8":true,"chromecast":true,"LG TV":true,"Samsung TV":true,"iWatch":true}}},"sha":"0.0.1"};(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({"/Users/shawn/Work/vigour-native/examples/projectx/www/index.js":[function(require,module,exports){
require('./styles.less')
var bridge = require('../../../lib/bridge')
  , Element = require('vigour-js/ui/element')

var app = new Element({
  node: document.body
  , header:
  {
    node: 'h1'
    , text: "Testing the native bridge"
  }
  , werf:
  { node: 'button'
    , text: "tap me"
    , events:
    { click: function () {
        doSome()
      }
    }
  }
  , t1:
  {
    node: 'button'
    , text: "send 'test message'"
    , events:
    {
      click: function () {
        testOneWay('test message')
      }
    }
  }
  , t2:
  {
    node: 'button'
    , text: "dummy/dummy()"
    , events:
    {
      click: function () {
        testSimple()
      }
    }
  }
  , t3:
  {
    node: 'button'
    , text: "statusbar/hide()"
    , events:
    {
       click: function () {
        testSimple('statusbar','hide')
      }
    }
  }
  , t4:
  {
    node: 'button'
    , text: "statusbar/show()"
    , events:
    {
       click: function () {
        testSimple('statusbar','show')
      }
    }
  }
  , t5:
  {
    node: 'button'
    , text: "test/log('test log message')"
    , events:
    {
       click: function () {
        testSimple('test', 'log', 'test log message')
      }
    }
  }
  , t6:
  {
    node: 'button'
    , text: "test/echo('test echo message')"
    , events:
    {
       click: function () {
        testSimple('test', 'echo', 'test echo message')
      }
    }
  }
  , t7:
  {
    node: 'button'
    , text: "test/vibrate()"
    , events:
    {
       click: function () {
        testSimple('test', 'vibrate')
      }
    }
  }
  , t8:
  {
    node: 'button'
    , text: "test/getTime()"
    , events:
    {
       click: function () {
        testSimple('test', 'getTime')
      }
    }
  }
  , container:
  {
    attr: { id: "container" }
  }
})

function doSome() {
  var div = document.createElement('div')
  div.innerHTML = "tap tap"
  document.body.appendChild(div)
  try {
    window.webkit.messageHandlers.vigourBridgeHandler.postMessage([1,2,3])
    window.webkit.messageHandlers.vigourBridgeHandler.postMessage({"a":[1,2], "b":"c"})
    //ignores funcs passing
    window.webkit.messageHandlers.vigourBridgeHandler.postMessage({"a":[1,2], "b":function(){return 1}})
  } catch(err) {
    console.log('The native context does not exist yet');
  }
}

function testSend (msg) {
  bridge.send(msg)
}
function testOneWay (message) {
    wrapTry(testSend)(message)
}

function testSimple () {
    var plugin = arguments[0] || 'dummy'
    var fnName = arguments[1] || 'dummy'
    var args = arguments[2] || []
    wrapTry(callNative)(plugin, fnName, args, function(error, value) {
        if (error) {
            addToDom("error: " + error)
        } else {
            addToDom("success!: " + value)
        }
    })

}

function wrapTry (fn) {
  return function() {
    try{
      fn.apply(fn, arguments)
    } catch(e) {
      bridge.addToDom("exception: " + e)
    }
  }
}

},{"../../../lib/bridge":"/Users/shawn/Work/vigour-native/lib/bridge/index.js","./styles.less":"/Users/shawn/Work/vigour-native/examples/projectx/www/styles.less","vigour-js/ui/element":"/Users/shawn/Work/vigour-native/node_modules/vigour-js/ui/element/index.js"}],"/Users/shawn/Work/vigour-native/examples/projectx/www/styles.less":[function(require,module,exports){

},{}],"/Users/shawn/Work/vigour-native/lib/bridge/android/index.js":[function(require,module,exports){
var bridge = require('../')

module.exports = exports = {}
/**
  wil send a message to the native side and returns immediately

  @param {Object} message
**/
exports.send = function (message) {
  NativeInterface.send(JSON.stringify(message))
}

/**
 * called by the android counterpart
 * expects a serialised array with [id,result,error]
**/
exports.receiveResult = function (id, result) {
  receiveNativeResult(id, result)
}
window.receiveAndroidResult = exports.receiveResult


exports.receiveError = function (id, error) {
  receiveNativeError(id, error)
}
window.receiveAndroidError = exports.receiveError
},{"../":"/Users/shawn/Work/vigour-native/lib/bridge/index.js"}],"/Users/shawn/Work/vigour-native/lib/bridge/index.js":[function(require,module,exports){
var Promise = require('promise')
  , ua = require('vigour-js/browser/ua')
  , bridges = {
    android: require('./android')
    , ios: require('./ios')  
  }
  , messageId = 1
  , callbackMap = {}
  , error

module.exports = exports = {}

console.log('platform', ua.platform)

if (bridges[ua.platform]) {
  exports.send = bridges[ua.platform].send
  exports.receiveResult = bridges[ua.platform].receiveResult
  exports.receiveError = bridges[ua.platform].receiveError
} else {
  error = new Error("Unsupported platform")
  error.requestedPlatform = ua.platform
  error.availablePlatofrms = Object.keys(bridges).join(',')
  console.error(error)
}

/**
  call a function in a native plugin
  @param {String} pluginId
  @param {String} fnName
  @param {Object} params
  @param {Function(err, value)} cb
 **/
exports.call = function (pluginId, fnName, params, cb) {
  var id = messageId++
  callbackMap[id] = cb
  exports.send([id, pluginId, fnName, params])
}
window.callNative = exports.call

exports.popCallback = function (id) {
  if (!callbackMap[id]) {
    exports.addToDom("illegal id: "+id) 
    return
  }
  var cb = callbackMap[id]
  delete callbackMap[id]
  return cb
}

exports.receiveNativeResult = function (id, result) {
  var cb = exports.popCallback(id)
  if (cb) {
    cb(null, result)
  } else {
    exports.addToDom("result without cb: " + error)
  }
}
window.receiveNativeResult = exports.receiveNativeResult

exports.receiveNativeError = function (id, error) {
  var cb = exports.popCallback(id)
  if (cb) {
    cb(error)
  } else {
    exports.addToDom("error without cb: " + error)
  }
}
window.receiveNativeError = exports.receiveNativeError

exports.addToDom = function (data) {
    var p = document.createElement('p')
    p.setAttribute('class', 'debug-output')
    p.appendChild(document.createTextNode(data))
    var container = document.getElementById('container');
    if (container.firstChild) {
        container.insertBefore(p, container.firstChild)
    } else {
        container.appendChild(p)
    }
}
window.addToDom = exports.addToDom



},{"./android":"/Users/shawn/Work/vigour-native/lib/bridge/android/index.js","./ios":"/Users/shawn/Work/vigour-native/lib/bridge/ios/index.js","promise":"/Users/shawn/Work/vigour-native/node_modules/promise/index.js","vigour-js/browser/ua":"/Users/shawn/Work/vigour-native/node_modules/vigour-js/browser/ua.js"}],"/Users/shawn/Work/vigour-native/lib/bridge/ios/index.js":[function(require,module,exports){
module.exports=require("/Users/shawn/Work/vigour-native/examples/projectx/www/styles.less")
},{"/Users/shawn/Work/vigour-native/examples/projectx/www/styles.less":"/Users/shawn/Work/vigour-native/examples/projectx/www/styles.less"}],"/Users/shawn/Work/vigour-native/node_modules/promise/index.js":[function(require,module,exports){
'use strict';

module.exports = require('./lib/core.js')
require('./lib/done.js')
require('./lib/es6-extensions.js')
require('./lib/node-extensions.js')
},{"./lib/core.js":"/Users/shawn/Work/vigour-native/node_modules/promise/lib/core.js","./lib/done.js":"/Users/shawn/Work/vigour-native/node_modules/promise/lib/done.js","./lib/es6-extensions.js":"/Users/shawn/Work/vigour-native/node_modules/promise/lib/es6-extensions.js","./lib/node-extensions.js":"/Users/shawn/Work/vigour-native/node_modules/promise/lib/node-extensions.js"}],"/Users/shawn/Work/vigour-native/node_modules/promise/lib/core.js":[function(require,module,exports){
'use strict';

var asap = require('asap')

module.exports = Promise;
function Promise(fn) {
  if (typeof this !== 'object') throw new TypeError('Promises must be constructed via new')
  if (typeof fn !== 'function') throw new TypeError('not a function')
  var state = null
  var value = null
  var deferreds = []
  var self = this

  this.then = function(onFulfilled, onRejected) {
    return new self.constructor(function(resolve, reject) {
      handle(new Handler(onFulfilled, onRejected, resolve, reject))
    })
  }

  function handle(deferred) {
    if (state === null) {
      deferreds.push(deferred)
      return
    }
    asap(function() {
      var cb = state ? deferred.onFulfilled : deferred.onRejected
      if (cb === null) {
        (state ? deferred.resolve : deferred.reject)(value)
        return
      }
      var ret
      try {
        ret = cb(value)
      }
      catch (e) {
        deferred.reject(e)
        return
      }
      deferred.resolve(ret)
    })
  }

  function resolve(newValue) {
    try { //Promise Resolution Procedure: https://github.com/promises-aplus/promises-spec#the-promise-resolution-procedure
      if (newValue === self) throw new TypeError('A promise cannot be resolved with itself.')
      if (newValue && (typeof newValue === 'object' || typeof newValue === 'function')) {
        var then = newValue.then
        if (typeof then === 'function') {
          doResolve(then.bind(newValue), resolve, reject)
          return
        }
      }
      state = true
      value = newValue
      finale()
    } catch (e) { reject(e) }
  }

  function reject(newValue) {
    state = false
    value = newValue
    finale()
  }

  function finale() {
    for (var i = 0, len = deferreds.length; i < len; i++)
      handle(deferreds[i])
    deferreds = null
  }

  doResolve(fn, resolve, reject)
}


function Handler(onFulfilled, onRejected, resolve, reject){
  this.onFulfilled = typeof onFulfilled === 'function' ? onFulfilled : null
  this.onRejected = typeof onRejected === 'function' ? onRejected : null
  this.resolve = resolve
  this.reject = reject
}

/**
 * Take a potentially misbehaving resolver function and make sure
 * onFulfilled and onRejected are only called once.
 *
 * Makes no guarantees about asynchrony.
 */
function doResolve(fn, onFulfilled, onRejected) {
  var done = false;
  try {
    fn(function (value) {
      if (done) return
      done = true
      onFulfilled(value)
    }, function (reason) {
      if (done) return
      done = true
      onRejected(reason)
    })
  } catch (ex) {
    if (done) return
    done = true
    onRejected(ex)
  }
}

},{"asap":"/Users/shawn/Work/vigour-native/node_modules/promise/node_modules/asap/asap.js"}],"/Users/shawn/Work/vigour-native/node_modules/promise/lib/done.js":[function(require,module,exports){
'use strict';

var Promise = require('./core.js')
var asap = require('asap')

module.exports = Promise
Promise.prototype.done = function (onFulfilled, onRejected) {
  var self = arguments.length ? this.then.apply(this, arguments) : this
  self.then(null, function (err) {
    asap(function () {
      throw err
    })
  })
}
},{"./core.js":"/Users/shawn/Work/vigour-native/node_modules/promise/lib/core.js","asap":"/Users/shawn/Work/vigour-native/node_modules/promise/node_modules/asap/asap.js"}],"/Users/shawn/Work/vigour-native/node_modules/promise/lib/es6-extensions.js":[function(require,module,exports){
'use strict';

//This file contains the ES6 extensions to the core Promises/A+ API

var Promise = require('./core.js')
var asap = require('asap')

module.exports = Promise

/* Static Functions */

function ValuePromise(value) {
  this.then = function (onFulfilled) {
    if (typeof onFulfilled !== 'function') return this
    return new Promise(function (resolve, reject) {
      asap(function () {
        try {
          resolve(onFulfilled(value))
        } catch (ex) {
          reject(ex);
        }
      })
    })
  }
}
ValuePromise.prototype = Promise.prototype

var TRUE = new ValuePromise(true)
var FALSE = new ValuePromise(false)
var NULL = new ValuePromise(null)
var UNDEFINED = new ValuePromise(undefined)
var ZERO = new ValuePromise(0)
var EMPTYSTRING = new ValuePromise('')

Promise.resolve = function (value) {
  if (value instanceof Promise) return value

  if (value === null) return NULL
  if (value === undefined) return UNDEFINED
  if (value === true) return TRUE
  if (value === false) return FALSE
  if (value === 0) return ZERO
  if (value === '') return EMPTYSTRING

  if (typeof value === 'object' || typeof value === 'function') {
    try {
      var then = value.then
      if (typeof then === 'function') {
        return new Promise(then.bind(value))
      }
    } catch (ex) {
      return new Promise(function (resolve, reject) {
        reject(ex)
      })
    }
  }

  return new ValuePromise(value)
}

Promise.all = function (arr) {
  var args = Array.prototype.slice.call(arr)

  return new Promise(function (resolve, reject) {
    if (args.length === 0) return resolve([])
    var remaining = args.length
    function res(i, val) {
      try {
        if (val && (typeof val === 'object' || typeof val === 'function')) {
          var then = val.then
          if (typeof then === 'function') {
            then.call(val, function (val) { res(i, val) }, reject)
            return
          }
        }
        args[i] = val
        if (--remaining === 0) {
          resolve(args);
        }
      } catch (ex) {
        reject(ex)
      }
    }
    for (var i = 0; i < args.length; i++) {
      res(i, args[i])
    }
  })
}

Promise.reject = function (value) {
  return new Promise(function (resolve, reject) { 
    reject(value);
  });
}

Promise.race = function (values) {
  return new Promise(function (resolve, reject) { 
    values.forEach(function(value){
      Promise.resolve(value).then(resolve, reject);
    })
  });
}

/* Prototype Methods */

Promise.prototype['catch'] = function (onRejected) {
  return this.then(null, onRejected);
}

},{"./core.js":"/Users/shawn/Work/vigour-native/node_modules/promise/lib/core.js","asap":"/Users/shawn/Work/vigour-native/node_modules/promise/node_modules/asap/asap.js"}],"/Users/shawn/Work/vigour-native/node_modules/promise/lib/node-extensions.js":[function(require,module,exports){
'use strict';

//This file contains then/promise specific extensions that are only useful for node.js interop

var Promise = require('./core.js')
var asap = require('asap')

module.exports = Promise

/* Static Functions */

Promise.denodeify = function (fn, argumentCount) {
  argumentCount = argumentCount || Infinity
  return function () {
    var self = this
    var args = Array.prototype.slice.call(arguments)
    return new Promise(function (resolve, reject) {
      while (args.length && args.length > argumentCount) {
        args.pop()
      }
      args.push(function (err, res) {
        if (err) reject(err)
        else resolve(res)
      })
      var res = fn.apply(self, args)
      if (res && (typeof res === 'object' || typeof res === 'function') && typeof res.then === 'function') {
        resolve(res)
      }
    })
  }
}
Promise.nodeify = function (fn) {
  return function () {
    var args = Array.prototype.slice.call(arguments)
    var callback = typeof args[args.length - 1] === 'function' ? args.pop() : null
    var ctx = this
    try {
      return fn.apply(this, arguments).nodeify(callback, ctx)
    } catch (ex) {
      if (callback === null || typeof callback == 'undefined') {
        return new Promise(function (resolve, reject) { reject(ex) })
      } else {
        asap(function () {
          callback.call(ctx, ex)
        })
      }
    }
  }
}

Promise.prototype.nodeify = function (callback, ctx) {
  if (typeof callback != 'function') return this

  this.then(function (value) {
    asap(function () {
      callback.call(ctx, null, value)
    })
  }, function (err) {
    asap(function () {
      callback.call(ctx, err)
    })
  })
}

},{"./core.js":"/Users/shawn/Work/vigour-native/node_modules/promise/lib/core.js","asap":"/Users/shawn/Work/vigour-native/node_modules/promise/node_modules/asap/asap.js"}],"/Users/shawn/Work/vigour-native/node_modules/promise/node_modules/asap/asap.js":[function(require,module,exports){
(function (process){

// Use the fastest possible means to execute a task in a future turn
// of the event loop.

// linked list of tasks (single, with head node)
var head = {task: void 0, next: null};
var tail = head;
var flushing = false;
var requestFlush = void 0;
var isNodeJS = false;

function flush() {
    /* jshint loopfunc: true */

    while (head.next) {
        head = head.next;
        var task = head.task;
        head.task = void 0;
        var domain = head.domain;

        if (domain) {
            head.domain = void 0;
            domain.enter();
        }

        try {
            task();

        } catch (e) {
            if (isNodeJS) {
                // In node, uncaught exceptions are considered fatal errors.
                // Re-throw them synchronously to interrupt flushing!

                // Ensure continuation if the uncaught exception is suppressed
                // listening "uncaughtException" events (as domains does).
                // Continue in next event to avoid tick recursion.
                if (domain) {
                    domain.exit();
                }
                setTimeout(flush, 0);
                if (domain) {
                    domain.enter();
                }

                throw e;

            } else {
                // In browsers, uncaught exceptions are not fatal.
                // Re-throw them asynchronously to avoid slow-downs.
                setTimeout(function() {
                   throw e;
                }, 0);
            }
        }

        if (domain) {
            domain.exit();
        }
    }

    flushing = false;
}

if (typeof process !== "undefined" && process.nextTick) {
    // Node.js before 0.9. Note that some fake-Node environments, like the
    // Mocha test runner, introduce a `process` global without a `nextTick`.
    isNodeJS = true;

    requestFlush = function () {
        process.nextTick(flush);
    };

} else if (typeof setImmediate === "function") {
    // In IE10, Node.js 0.9+, or https://github.com/NobleJS/setImmediate
    if (typeof window !== "undefined") {
        requestFlush = setImmediate.bind(window, flush);
    } else {
        requestFlush = function () {
            setImmediate(flush);
        };
    }

} else if (typeof MessageChannel !== "undefined") {
    // modern browsers
    // http://www.nonblocking.io/2011/06/windownexttick.html
    var channel = new MessageChannel();
    channel.port1.onmessage = flush;
    requestFlush = function () {
        channel.port2.postMessage(0);
    };

} else {
    // old browsers
    requestFlush = function () {
        setTimeout(flush, 0);
    };
}

function asap(task) {
    tail = tail.next = {
        task: task,
        domain: isNodeJS && process.domain,
        next: null
    };

    if (!flushing) {
        flushing = true;
        requestFlush();
    }
};

module.exports = asap;


}).call(this,require('_process'))

},{"_process":"/Users/shawn/npm/lib/node_modules/gaston/node_modules/browserify/node_modules/process/browser.js"}],"/Users/shawn/Work/vigour-native/node_modules/vigour-js/base/index.js":[function(require,module,exports){
/*!
 * @license Copyright (c) 2012-2014, Vigour. All rights reserved.
 * @author: Jim de Beer, jim@vigour.io
 */
var V = require('../')
  , util = require('../util')
  , inject = require('../util/inject')
// , raf = require('../browser/animation/raf')


/*
  util.define( extend, 'extensions',{val:[], setClass:true} )
*/

/**
 * Base is used as a class constructor.
 * @constructor V.Base
 * @param  {*} [val] Startvalue for new V.Base
 */
var base = V.Base = module.exports = exports = function(val) {
  this._from = this.constructor
  if (val) this.set(val)
}

exports.settings = require('./settings')

/**
 * Sets properties defined in an object.
 * Define a _set method on a base instance to get custom method per set.
 * @function _set
 * @param  {*} val         Any value
 * @param  {*} [params]    Added parameters
 * @param {Boolean} noset  When true returns a parsed val object but set nothing
 * @return {Object}        return self for chaining
 */
var _set = exports.set = function(val, params, noset) {
  for (var i in val) {
    if (~i.indexOf(',')) {
      for (var arr = i.split(','), multiobj = {}, m = 0, ml = arr.length; m < ml; m++) {
        multiobj[arr[m]] = util.clone(val[i])
      }
      if (!noset) {
        _set.call(this, multiobj, params, noset)
      } else {
        delete val[i]
        for (var n in multiobj) {
          val[n] = multiobj[n]
        }
      }
    } else {
      i = util.dotField(val, i)
      if (this._set && !noset) {
        this._set.call(this, val, i, params)
      } else {
        //TODO: check for property move from element set to here
        // if( V.Object && this.isProperty( i, val ) && this[i] instanceof V.Object )
        // {
        //   console.log('??', i, val, this.isProperty( i, val ) )
        //   this[i].val = val[i]
        // }
        // else
        // {
          this[i] = val[i]
        // }
      }
    }
  }
  return noset ? val : this
};

util.define(base,
  /**
   * When a Base is extended without defining the type this is the default type.
   * @property defaultType
   */
  'isProperty', function( i, val) {
    var t = this
      , result = 
          !( val[i] instanceof Object 
           //TODO: check if this is really nesseracy ( void 0 )
           && t._[i] === void 0 //--- danger resolve when define _ is fixed
           && !util.lookup.call(t, i) 
           && typeof t[i]!=='function' 
          )

    // console.log( val[i] instanceof Object, t._[i] === void 0, 'val:',t._[i], !util.lookup.call(t, i), typeof t[i]!=='function'  )

    // console.log( 'IS PROPERTY', i, result )

    return result
  },
  'defaultType', false,
  'extensions', false,
  'define', function(val) {
    for(var i in val) {
      util.define( this, i, val[i] )
      util.define( this.Class, i, val[i] )
    }
  },
  /**
   * Extend is used to add properties to base.
   * Settings are similar to standard defineProperty.
   * @method extend
   * @param   {Object}   settings        Define the following fields: name, type, set, new, remove.
   * @param   {String}   settings.name   Define the name of the property
   * @param   {Object}   [settings.type] Define the type of object e.g. V.Value, set type to false if you want to use standard defineProperty
   * @param   {Function} settings.set    Define a function on set
   * @param   {Function} settings.new    Define a function on construct
   * @param   {Function} settings.remove Define a function on remove
   * @return  {[type]}                   [description]
   */
  'extend', function(settings) {

    //TODO: add to instance as well , have a dictionary of extenstions -- get to orginal easyly
    var args = util.arg(arguments)
      , l = args.length
      , i

    if (l > 1) {
      for (i = 0; i < l; this.extend( args[i++] ));
    } else if (!settings.name) {
      for (i in settings) {

        if( typeof settings[i] === 'function' ) 
        {
          this.extend( { name: i, set: settings[i] } )
        }
        else
        {
          settings[i].name = i
          this.extend( settings[i] )
        }

      }
    } else {
      if (!settings.def && settings.def !== 0) settings.def = false;
  
      if (this.Class.prototype._settings) {
        exports.settings.parse.call(this, settings)
        if (settings._settings) exports.settings.create.call(this, settings)
      }
      //1. normal extensions
      if (settings.type === false || ( !settings.type && !this.defaultType ) ) {

        //TODO: test if double define is actually ok!
        // util.define(this, settings.name, settings)

        util.define(this.Class, settings.name, settings)

      } else {
        //2. V.Values
        if (!settings.type) settings.type = this.defaultType
          //a type has fields type, set ,get, create
        var get =  function(prop) {
            //custom get
            return settings.type.get 
              ? settings.type.get.call(this, prop, settings)
              : prop
          }
          , set =  function(val) {

            var prop = this[settings.name]
            if(prop===null) return
            if (prop===settings.def) { //(prop instanceof V.Object)
              //return is hier mischien niet nodig;
              return settings.type.create.call(this, val, prop, settings)
            } else {
              // console.log('????????????', this, val, prop, settings)
              
              val = settings.type.set.call(this, val, prop, settings)
              if (val!== null) prop.val = val
            }
          }

        //TODO: test if double define is actually ok!
        util.define(
          this,
          settings.name,
          settings.def,
          set,
          get,
          true
        )
        //dit breaked wat shit

        //or on value ? value.prop

        //make extended prototype object perhaps
        // this.Class.prototype['__'+settings.name+'__'] = settings

        util.define(
          this.Class,
          settings.name,
          settings.def,
          set,
          get
        )
      }
    }
  },
  /**
   * Removes this Base. Also removes all listeners added to extensions.
   * Instances true will remove all instances as well.
   * @method remove
   * @param  {[type]} instances  [description]
   * @param  {[type]} fromremove [description]
   * @param  {[type]} params     [description]
   */
  'remove', function(instances, fromremove, params) {

    // this._removing = true

    if(!this._from) return

    this.setting('remove', [params]);

    if (!fromremove) {
      var ins = this._from.base.instances
      if(ins) {
        for (var n = 0, l = ins.length; ins[n] !== this || !ins.splice(n, 1); n++);
      }
    }

    for (var i in this.__) {
      if (this.__[i] instanceof V.Object) {
        //nested, blacklist, not (fields in object), from, stamp, noupdate
//         console.log('---------', i, this.__[i], this.__[i]._path )
        this.__[i].remove(false, false, false, false, false, true);
        this.__[i] = null
      } else {
        this.__[i] = null
      }
    }
    this.__ = null

    if (instances && this.instances) {
      for (j = this.instances.length - 1; j >= 0; this.instances[j--].remove(true, true));
    }

    for (var j in this) {
      // if(this[j] instanceof V.Base) {
      //   this[j].remove()
      // } 
      this[j] = null;
    }

    this._settings = null
    this._ = null
    delete this._settings
    delete this._
    delete this.__
    // delete this._class; may not be nessecary
  },
  /*set on prototype*/
  'set', _set,
  'inject', inject,
  /**
   * Passes field parameter only for instances matching a field
   * @method
   * @param  {Function} fn    [description]
   * @param  {String}   field [description]
   * @param  {*}        val   [description]
   * @param  {*}        p     [description]
   * @return {Boolean}        [description]
   */
  'eachInstance', function(fn, field, val, p) {
    var instances = this.instances;
    if (instances) {
      for (var i = 0, l = instances.length, instance; i < l; i++) {
        instance = instances[i];


//problem! has to correct for missing instances!!!
//   console.log(instance, instances)

          

        if (instance && (!field || !instance.__ || !instance.__[field])) {
          if (fn.call(instance, val, p)) {
            return true;
          }
          if (instance.eachInstance(fn, field, val)) {
            return true;
          }
        } else if(!instance) {
          console.error('\n\n\n\ninstance in base gone?', i , instances)
          // debugger
        }
      }
    }
  },
  /**
   * Creates a class from the current Base instance
   * @constructor Class
   * @return {Object}
   */
  'Class', {
    get: function() {
      if (!this._class) {
        this.instances = [];
        this._class = function(val, proto, setting) {
          if (!proto) {
            var from = this._from.base;
            from.instances.push(this);
            if (this.setting) {
              this.setting('new', [from, setting]);
            }
            if (val) {
              this.set(val);
            }
          }
        };
        this._class.base = this;
        this._class.prototype = new this._from(false, true);
        this._class.prototype.__ = null;
        util.setstore.call(this);
        var i, _proto = this._class.prototype._ = {};
        for (i in this.__) {
          _proto[i] = this.__[i];
        }
        for (i in this._) {
          if (_proto[i] === void 0) {
            _proto[i] = this._[i];
          }
        }
        this._class.prototype._from = this._class;
        this._class.inject = inject
      }
      return this._class;
    }
  });
},{"../":"/Users/shawn/Work/vigour-native/node_modules/vigour-js/index.js","../util":"/Users/shawn/Work/vigour-native/node_modules/vigour-js/util/index.js","../util/inject":"/Users/shawn/Work/vigour-native/node_modules/vigour-js/util/inject.js","./settings":"/Users/shawn/Work/vigour-native/node_modules/vigour-js/base/settings.js"}],"/Users/shawn/Work/vigour-native/node_modules/vigour-js/base/settings.js":[function(require,module,exports){
/*!
 * @license Copyright (c) 2012-2014, Vigour. All rights reserved.
 * @author: Jim de Beer, jim@vigour.io
 */
var base = require('./'),
  util = require('../util');

/**
 * Settings are used for special cases e.g. onRemove or onNew instance
 * @property
 */
util.define(base, '_settings');

base.prototype._._settings = {};

/**
 * Set settings on Base
 * @function _set
 * @param  {Object}  set      Object to set
 * @param  {Boolean} [remove]
 * @param  {Boolean} [force]  True/false
 */
var _set = function(set, remove, force) {
  var _s = set._settings //e.g. node , remove and parent
    , t = this
    , __t = t._._settings
    , setting
    , i
    , _t

  util.setstore.call(t)

  if (!t.__._settings) {
    // console.log('create my own settings')
    t.__._settings = {}
    for (var j in __t) {
      t._settings[j] = __t[j]
    }
  }

  _t = t.__._settings

  // console.log('SETTINGS?'.inverse, set, __t)

  for (i in _s) {
    setting = _s[i]
    //efficient memory management only make own if absolutely nessecary
    if ((remove && _t[setting][set.name]) || (!remove && !_t[setting][set.name]) || force) {
      
      if (_t[setting] === __t[setting]) {
        _t[setting] = {}
        for (var n in __t[setting]) {
          _t[setting][n] = __t[setting][n]
        }
      }

      if (remove) {
        this.eachInstance(function() {
          if (this[set.name] !== t[set.name]) {
            if (this._setting !== _t && this._settings[setting] === _t[setting]) {
              // console.log('found that the settings are the same and not the same property make my own');
              // console.log('------ SETTING')
              _set.call(this, _t[setting][set.name], false, true);
            }
          } else {
            if (this._setting !== _t && this._settings[setting] !== _t[setting]) {
              // console.log('------ REMOVE SETTING')

              // console.log(this.name,set.name,'found that the property is the same but settings are not!');
              this.removeSetting(set.name, setting);
            }
          }
        });
        _t[setting][set.name] = null;
        delete _t[setting][set.name]; //delete is kut!;
        if (util.empty(_t[setting])) {
          // console.log('lets put this to true!')
          _t[setting] = true;
        }
      } else {
        // console.log('------ DO SETTING', set, _t, setting, set.name)
        if(_t[setting]===true) {
          _t[setting]={}
        }
        _t[setting][set.name] = set;
        // console.log('RESULT?', setting, _t[setting])
      }
    }
  }

  // console.log('SETTINGS? -- result'.inverse, _t, this._settings===_t, this.BLUXEN)

};

/**
 * Creates a setting
 * @method create
 * @param  {[type]} set [description]
 * @return {[type]}     [description]
 */
exports.create = function(set) {
  set._set = set.set;
  set.set = function(val, prop) {
    _set.call(this, set)
    set._set.apply(this, arguments)
  }
}

/**
 * Extracts settings from settingsobject and stores them in an array.
 * @method parse
 * @param  {Object} settings Settingobject
 * @param  {Object} object   Settingsobject
 */
exports.parse = function(settings, object) {
  if (!object) {
    object = this._settings
  }
  for (var i in object) {
    if (settings[i]) {
      if (!settings._settings) {
        settings._settings = [];
      }
      settings._settings.push(i);
    }
  }
};

/**
 * Adds setting(s) to Base prototype
 * @method add
 * @param  {String[]}    name  Array of settingnames
 * @param  {Prototype}   proto Prototype eg. myBase class
 */
exports.add = function(name, proto) { //start using this sometimes!;
  if (name instanceof Array) {
    for (var i in name) {
      if (proto) {
        this.add(name[i], proto);
      } else {
        this.addSetting(name[i], false);
      }
    }
  } else {
    if (!proto) {
      util.setstore.call(this);
      if (!this.__._settings) {
        this.__._settings = {};
      }
      for (var j in this._._settings) {
        this._settings[j] = this._._settings[j];
      }
      this._settings[name] = true;
    } else {
      proto.prototype._settings[name] = true;
    }
  }
};

/**
 * Add settings to instances of Base
 * settings only work for instances of the added Basesettings
 * @method
 */
util.define(base,
  'addSetting', function(name) {
    exports.add.call(this, name);
    if (this._class) {
      this._class.prototype._._settings = this._settings;
    }
  },
  /**
   * Simple implementation of setting.create
   * @method setSetting
   * @param  {Object} set Settingobject
   */
  'setSetting', function(set) {
    //eerst checken of ie al bestaat anders kan het voorkomen dat het teveel is
    exports.parse.call(this, set);

    // console.log('SET SETTING'.yellow.inverse, set, this._settings )

    //get gebruiken --- object is een check op meerdere fields returns true of false // bij get ook mogelijk om field mee te geven
    _set.call(this, set);

    // console.log('SET SETTING -- result'.yellow.inverse, this._settings )

  },
  /**
   * [description]
   * @method removeSetting
   * @param  {String}       name     Name of the setting to remove
   * @param  {Array|Object} settings Settingobject
   */
  'removeSetting', function(name, settings) {

    // if(!settings) {
    //   //this may all be not nessecary!
    //   for(var i in this._settings) {
    //     for(var j in this._settings[i]) {
    //       if(this._settings[i][j].name===name) {
    //         settings=this._settings[i][j]
    //         break;
    //       }
    //     }
    //   }
    // }

    if (!(settings instanceof Array)) {
      //this may all be not nessecary!
      // if(settings instanceof Object) {
      //   settings = settings._settings
      // } else {
        settings = [settings];
      // }
    }

    for (var i = settings.length - 1, found, _settings = this._settings; i >= 0; i--) {
      if (_settings && _settings[settings[i]] && _settings[settings[i]][name]) {
        found = true;
        break;
      }
    }
    if (found) {
      _set.call(this, {
        name: name,
        _settings: settings
      }, true);
    }
  },

  /**
   * Checks if object has settings and executes them. Arguments are passed to settings.
   * @method setting
   * @param  {String}    name Name of the setting
   * @param  {Arguments} arg  Arguments to pass to settings
   */
  'setting', function(name, arg) { //misschien arg
    var _s = this._settings;
    if (_s && _s[name] && _s[name] !== true) {
      for (var i in _s[name]) {
        _s[name][i][name].apply(this, arg);
      }
    }
  });

/**
 * Base has two default settings
 * new is invoked on construction , remove on removal;
 * @settings
 */
exports.add(['new', 'remove'], base)

},{"../util":"/Users/shawn/Work/vigour-native/node_modules/vigour-js/util/index.js","./":"/Users/shawn/Work/vigour-native/node_modules/vigour-js/base/index.js"}],"/Users/shawn/Work/vigour-native/node_modules/vigour-js/browser/animation/raf.js":[function(require,module,exports){
/*!
 * @license Copyright (c) 2012-2014, Vigour. All rights reserved.
 * @author: Youri Daamen, youri@vigour.io
 */
var ua = require('../ua'),
  RAF = 'equestAnimationFrame',
  CAP = 'R' + RAF,
  util = require('../../util')
  lastFrame = 0;

util.define(ua, 'hasTransition', {
  get:function() {
    if(!ua._hasTransition) {
       var b = document.body || document.documentElement
        , s = b.style
        , p = 'ransition';
      ua._hasTransition = typeof s['t'+p] === 'string' 
        || typeof s[ua.prefix + 'T'+p] === 'string'
    }
    return ua._hasTransition
  }
})
  
RAF = 'r' + RAF;
if (!window[RAF]) { 

  ua.noRaf = true

  //window[ua.prefix + CAP] || 

  window[RAF] = function(callback) {
    return setTimeout(callback, 20);
  };
  window.cancelAnimationFrame = function(id) {
    clearTimeout(id);
  };
}



module.exports = window[RAF]
//check ios 6 paul irish says stuff goes wrong there...
},{"../../util":"/Users/shawn/Work/vigour-native/node_modules/vigour-js/util/index.js","../ua":"/Users/shawn/Work/vigour-native/node_modules/vigour-js/browser/ua.js"}],"/Users/shawn/Work/vigour-native/node_modules/vigour-js/browser/cases/base.js":[function(require,module,exports){
/*!
 * @license Copyright (c) 2012-2014, Vigour. All rights reserved.
 * @author: Jim de Beer, jim@vigour.io
 */

var cases = require('./'),
  element = require('../element'),
  setFlags = require('../element/set'),
  base = require('../../base'),
  util = require('../../util');

//------------------CASES FOR SET-------------------------------
var _css = function(t, name, invert, remove) {
    if (!invert) {
      t.css = remove ? {
        removeClass: name
      } : {
        addClass: name
      };
    }
  },
  methods = cases.methods;

setFlags.remove = function(i, val, copy, top) {
  //this could become a seperate module since remove may be usefull for different purposes
  if (val && val.__remove__) {
    if (this[i] instanceof base) {
      top[i] = false;
    } else if (util.lookup.call(this, i)) {
      delete val.__remove__;
    } else {
      delete val[i];
      return true;
    }
  }
};

setFlags.cases = methods.reader(function(name, val, dynamic, invert) {
  var t = this,
    f = function(obj) {
      obj = base.set(obj, false, true);
      for (var i in obj) {
        if (util.isObj(obj[i])) {
          obj[i] = f(obj[i]);
        }
      }
      return obj;
    },
    method,
    parsed,
    set,
    sVal,
    original;
  val = f(val);

  if (dynamic) {
    if (!t._cases) {
      t._cases = {};
    }
    if (val === null) {
      if (t._cases[name].method) {
        // console.error(name, 'case === null , remove it');
        cases[name].removeListener(t._cases[name].method);
      }
      if (cases[name].val) {
        t.css = {
          removeClass: name
        };
      }
      delete t._cases[name]; //removes case orginal
    } else {
      // console.error('SET CASE',name,t._cases[name]&&t._cases[name].method);
      parsed = methods.original(t, true, val, t._cases, true, name);
      t._cases[name] = {
        val: val,
        orig: parsed[0],
        nested: parsed[1]
      };

      if (!t._cases[name].method) {
        // console.error('this is what i have set for original', t._cases);
        method = t._cases[name].method = function() {
          // console.log('LETS TRY TO RUN METHOD',name);
          if (val) {
            set = methods.merge(true, name, val, t._cases); //arg no val;
            sVal = set [0];
            original = set [1];
            delete sVal.val;
            delete original.val;
            if (cases[name].val) {
              _css(t, name, invert);
              t.set(sVal, true);
            } else {
              _css(t, name, invert, true);
              t.set(original, true);
            }
          }
        };
        // console.error('ADD LISTENER TO',name,  t._cases[name]);
        cases[name].addListener(method);
        //remove setting on remove (saves memory)
        t.setSetting({
          name: '_c' + name,
          remove: function() {
            // console.log('remove from setting case', name);
            cases[name].removeListener(method);
          }
        });
        // } else {
        // console.log(name, 'already got listeners for case',name);
      }
      if (cases[name].val) {
        _css(t, name, invert);
        t.set(val, true);
      }
    }
  } else {
    _css(t, name, invert);
    t.set(val); //maybe copy args?
  }
  return true;
});
},{"../../base":"/Users/shawn/Work/vigour-native/node_modules/vigour-js/base/index.js","../../util":"/Users/shawn/Work/vigour-native/node_modules/vigour-js/util/index.js","../element":"/Users/shawn/Work/vigour-native/node_modules/vigour-js/browser/element/index.js","../element/set":"/Users/shawn/Work/vigour-native/node_modules/vigour-js/browser/element/set.js","./":"/Users/shawn/Work/vigour-native/node_modules/vigour-js/browser/cases/index.js"}],"/Users/shawn/Work/vigour-native/node_modules/vigour-js/browser/cases/index.js":[function(require,module,exports){
/*!
 * @license Copyright (c) 2012-2014, Vigour. All rights reserved.
 * @author: Jim de Beer, jim@vigour.io
 */

var object = require('../../object'),
  util = require('../../util'),
  element = require('../element'), //element /w extend
  value = require('../../value'),
  flags = require('../../value/flags');

/**
 * cases
 * cases are used to set one or more values when a specific case is true
 * there are 2 types of cases , static and dynamic ,
 * static cases are set at initialization of the application , usefull for things such as device type (phone, desktop, tv)
 * dynamic cases can be changed dynamicly and Objects or Bases that use the case will be changed dynamicly as well
 */

util.define(exports, 'methods', {});
//multiple, recursive and original have to become extensions on V.Object.convert so it's possible to use the same for data and events

var _isObj = util.isObj,
  /*
    _recur
    special merge that adds __remove__ if a field has to be removed
  */
  _recur = function(original, merge, fieldExists) {

    // console.log(original, merge, fieldExists)

    var keys, i, key, originalChild, mergeChild;
    if (fieldExists) {
      keys = {};
      for (key in original) {
        keys[key] = true; //keys can be undefined -- code can become shorter
      }
    }
    for (i in merge) {
      if (!fieldExists || keys[i]) {
        originalChild = original[i];
        mergeChild = merge[i];
        if (originalChild instanceof Object) {
          if (originalChild.__remove__ && (mergeChild && !mergeChild.__remove__)) {
            delete originalChild.__remove__;
          }
          if (!(mergeChild instanceof Object)) {
            merge[i] = {
              val: mergeChild
            };
          }
          _recur(originalChild, mergeChild, fieldExists);
        } else {
          original[i] = mergeChild;
          originalChild = 'burn';
        }
      }
    }
  },
  /*
          _multiple
          merge multiple orginals into a new orginal object also resolve nested cases
      */
  _multiple = function(t, nested, cases, currentObj, currentVal, base, name, path, orig) {

    if (!path) {
      orig = t;
      path = [];
    }
    var j, _case, cvChild;

    if((currentVal instanceof object) && !base) {

      // currentObj.val = t._val
      // console.error('VOBJ', currentObj)


    } else if (currentVal instanceof Object) {
      for (j in currentVal) {
        cvChild = currentVal[j];
        if (exports[j]) {
          _case = exports[j];
          if (_case instanceof object) {
            if (!base || !element.set.lookup.call(orig, path[path.length - 1])) { //element is required in cases.base, make this part extendable
              nested[j] = true;
            }
          }
          if (!_isObj(cvChild)) {
            currentObj.val = t && (t._val !== void 0 ? t._val : void 0);
          } else {
            path.push(j);
            //should be possible to use nested for current nested case;
            _multiple(t, nested, cases, currentObj, cvChild, base, name, path, orig);
          }
          currentObj[j] = null;
        } else {
          if (_isObj(cvChild)) {
            if (!currentObj[j]) {
              currentObj[j] = (t && t[j] && t[j].convert && t[j].convert(cvChild)) || (cvChild instanceof Array ? [] : {});
            }
            path.push(j);
            _multiple(t && t[j], nested, cases, currentObj[j], cvChild, base, name, path, orig);
            if (base && (!t || !t[j])) {
              currentObj[j].__remove__ = true;
            }
          } else {
            if (t && currentObj && !currentObj[j]) {
              if (flags[j]) {
                delete currentObj[j];
                currentObj.val = t._val !== void 0 ? t._val : void 0;
              } else {
                currentObj[j] = j === 'val' 
                  ? (t._val !== void 0 ? t._val : void 0) 
                  : (t[j]!==void 0 && t[j].convert && t[j].convert())
              }
            }
          }
        }
      }
    }
  };

/*
      original
      create a orginal store for a new case
    */
exports.methods.original = function(t, isObj, val, cases, base, name) {



  var obj = isObj ? t.convert(val) : t._val,
    i, cflag, nested = {};

  _multiple(t, nested, cases, obj, val, base, name);

  // for(var i in nested) {
  //   console.error('NESTED:::',i);
  // }
  // console.log(base ? 'BASE:': 'PROPERTY:' , name,'ORIGINAL GENERATION','\nval:',val,'\nobj:',obj,'\nnested:',nested,'\ncases:',cases);

  for (i in cases) {
    if (!nested[i]) {
      cflag = cases[i].orig;
      if (!isObj) {
        if (_isObj(cflag)) {
          if (cflag.val) {
            obj = cflag.val;
          }
        } else {
          obj = cflag;
        }
      } else {
        if (_isObj(cflag)) {
          if (!cases[i].nested[name]) {
            _recur(obj, cflag, name);
          }
        } else if (obj.val) {
          obj.val = cflag;
        }
      }
    }
  }



  return [obj, nested];
};
/*
  merge
  merge dynamic cases (overwrite /w cases that are true and further in the order of cases)
*/
exports.methods.merge = function(isObj, name, val, cases) {
  var original = util.clone(cases[name].orig),
    sVal = val,
    overwrite,
    i,
    merge,
    originalChild;
  for (i in cases) {
    if (i !== name && !cases[name].nested[i]) {
      if (exports[i].val) {
        merge = cases[i].val;
        if (_isObj(original) || _isObj(merge)) {
          if (!_isObj(original)) {
            original = {
              val: original
            };
          }
          if (!_isObj(merge)) {
            merge = {
              val: merge
            };
          }
          _recur(original, merge, true);
          for (i in exports) {
            originalChild = original[i];
            if (originalChild !== null && originalChild !== void 0) {
              delete original[i]; //delete is pretty slow
            }
          }
          if (overwrite) {
            if (isObj) {
              if (sVal === val) {
                sVal = util.clone(sVal);
              }
              merge = util.clone(merge);
              for (i in exports) {
                if (merge[i] !== null && merge[i] !== void 0) {
                  // console.error('REMOVE FIX', i);
                  delete merge[i]; //delete is pretty slow
                }
              }
              _recur(sVal, merge, true);
            } else {
              if (merge.val) {
                sVal = merge.val;
              }
            }
          }
        } else {
          original = merge;
        }
      }
    } else {
      overwrite = true;
    }
  }
  return [sVal, original];
};
/*
  reader
  abstraction for use in cases.object and cases.base
*/
exports.methods.reader = function(fn, dynamic, _static) {
  return function(name, val) {
    var invert = (name[0] === '!'),
      vCase = invert ? exports[(name.slice(1))] : exports[name],
      ret;
    if (vCase) {
      if (vCase instanceof object) {
        if (invert && !exports[name]) {
          exports[name] = new value({
            val: function() {
              return !vCase.val;
            },
            listen: vCase
          });
        }
        ret = fn ? fn.call(this, name, val, true, invert) : dynamic;
      } else {
        ret = invert ? !!fn : fn ? fn.call(this, name, val) : _static
      }
    } else if (invert) {
      ret = fn ? fn.call(this, name, val, false, invert) : _static;
    }
    if (vCase === false && fn) {
      ret = true;
    }
    return ret;
  };
};

require('./object');
require('./base');
},{"../../object":"/Users/shawn/Work/vigour-native/node_modules/vigour-js/object/index.js","../../util":"/Users/shawn/Work/vigour-native/node_modules/vigour-js/util/index.js","../../value":"/Users/shawn/Work/vigour-native/node_modules/vigour-js/value/index.js","../../value/flags":"/Users/shawn/Work/vigour-native/node_modules/vigour-js/value/flags/index.js","../element":"/Users/shawn/Work/vigour-native/node_modules/vigour-js/browser/element/index.js","./base":"/Users/shawn/Work/vigour-native/node_modules/vigour-js/browser/cases/base.js","./object":"/Users/shawn/Work/vigour-native/node_modules/vigour-js/browser/cases/object.js"}],"/Users/shawn/Work/vigour-native/node_modules/vigour-js/browser/cases/object.js":[function(require,module,exports){
/*!
 * @license Copyright (c) 2012-2014, Vigour. All rights reserved.
 * @author: Jim de Beer, jim@vigour.io
 */

var flags = require('../../value/flags'),
  Cases = require('./'),
  object = require('../../object'),
  util = require('../../util'),
  methods = Cases.methods,
  dynamic = {
    set: function(val, stamp, reset, name) {

      if(!this._flag) this._flag = {}

      var t = this,
          //selection for t._flag easy maken
          
          
        flags = t._flag.case || (t._flag.case = [
          'case',
          t._val,
          false, {},
          dynamic
        ]),
        cases = flags[3],
        isObj = util.isObj(val),
        setVal = (isObj && !val.val) ? false : true;
      if (val === null) {
        if (cases[name]) {
          Cases[name].removeListener(cases[name].method);
        }
        delete cases[name];
      } else {
        flags[5] = true;
        if (!cases[name]) {
          var x = methods.original(t, isObj, val, cases, false, name);
          cases[name] = {
            val: val,
            orig: x[0],
            nested: x[1],
            method: function() {
              var set = methods.merge(isObj, name, val, cases),
              sVal = set[0],
              original = set[1];
              flags[5] = true; //the closures here are not really nessecary better to avoid
              if (Cases[name].val) {
                if(!sVal) console.warn(name,'wrong in cases!', sVal, Cases, flags)
                if (setVal && sVal) {
                  flags[1] = sVal.val || sVal;
                }
                t.val = sVal;
              } else {
                if (setVal) flags[1] = original && original.val || original
                t.val = original;
              }
              flags[5] = null;
            }
          };
          Cases[name].addListener(flags[3][name].method);
        }
        if (Cases[name].val) {
          if (setVal) {
            flags[1] = val.val || val;
          }
          object.set.call(t, val, stamp, false, true);
          //not always
          t._ignorefornow = true

        }
        flags[5] = null;
      }
    },
    // reset:function() {
      // console.error('reset')
    // },
    //add reset later
    remove: function(flags, name) {
      // console.log(flags, name)
      var cnt = 0
      for (var i in flags[3]) {
        // if(flags[3])
        cnt++
        if(!this._ignorefornow && !name || i===name) {
          cnt --
          Cases[i].removeListener(flags[3][i].method);
        } else {
          delete this._ignorefornow
        }
      }
      if(cnt) {
        // console.log('CASE OBJECT REMOVAL --- IT IS NOT EMPY')
        return true
      }
    },
    stack: 'case'
  },
  _static = {
    set: function(val, stamp, reset, name) {
      if (val !== null) {
        object.set.call(this, val, stamp, false, true);
      }
    }
  };

flags.dynamic.cases = methods.reader(false, dynamic, _static);
},{"../../object":"/Users/shawn/Work/vigour-native/node_modules/vigour-js/object/index.js","../../util":"/Users/shawn/Work/vigour-native/node_modules/vigour-js/util/index.js","../../value/flags":"/Users/shawn/Work/vigour-native/node_modules/vigour-js/value/flags/index.js","./":"/Users/shawn/Work/vigour-native/node_modules/vigour-js/browser/cases/index.js"}],"/Users/shawn/Work/vigour-native/node_modules/vigour-js/browser/css.js":[function(require,module,exports){
/*!
 * @license Copyright (c) 2012-2014, Vigour. All rights reserved.
 * @author: Jim de Beer, jim@vigour.io
 */

/*
  gets and caches values for css classes, also possible to change styles of classes
  return an array of multiple css objects corresponding to the class name
  when you pass field it searches the field trough all the classes selected, always takes first argument
  maybe have to make this for things such as div selectors / nested stuff --- will be cpu intensive!;
*/
var selector = 'cssRules',
  parseclass = function(slctr) {
    slctr = '.' + slctr.replace(/\./g, ' .').toLowerCase();
    for (var robj, select = document.styleSheets, length = select.length, i = 0, selectItem; i < length; i++) {
      selectItem = select[i][selector] || select[i][(selector = 'rules')]; //location of this polyfill can be improved
      if(selectItem) {
        for (var j = 0, l = selectItem.length, item; selectItem, j < l; item = selectItem[j++], item.selectorText === slctr && (robj = item.style));
      }
    }
    return robj;
  },
  c = function(cssClass, cache) {
    var t = exports;
    cache.push(t[cssClass] || (t[cssClass] = parseclass(cssClass)) || {});
    return cssClass;
  };

module.exports = function(slctr, field) {
  if (slctr) {
    var cache = this[slctr];
    if (!cache) {
      cache = [];
      for (var selectarray = slctr.split(' '), i = 0, l = selectarray.length, cssClass; i < l; i++) {
        if ((cssClass = c(selectarray[i], cache).split('.')) instanceof Array) {
          c(cssClass[cssClass.length - 1], cache);
        }
      }
      this[slctr] = cache;
    }
    if (field) {
      if(!(cache instanceof Array))
        return
      for (var ret, i = cache.length - 1; !ret && i >= 0; ret = cache[i--][field]);
      cache = ret;  
    }
    return cache;
  }
};
},{}],"/Users/shawn/Work/vigour-native/node_modules/vigour-js/browser/element/index.js":[function(require,module,exports){
/*!
 * @license Copyright (c) 2012-2014, Vigour. All rights reserved.
 * @author: Jim de Beer, jim@vigour.io
 */
var base = require('../../base')
  , valueBase = require('../../value/base')
  , vigour = require('../../')
  , util = require('../../util')
  , elementBase = new base()

elementBase.defaultType = valueBase.type

module.exports = exports = vigour.Element = elementBase.Class
exports.base = elementBase

var _doc = typeof document !== 'undefined' ? document : 'no document', //reference to document is faster than using window.document;
  /**
   * Removes children from parent node
   * @method _removeChildren
   */
  _removeChildren = function() {
    for (var c = this._node.childNodes, i = 0, l = c.length; i < l; i++) {
      if (c[i].base) {
        // console.log
        c[i].base.remove(false, false, true);
      }
    }
  };

/**
 * node
 * adds and clones html nodes;
 * @attribute
 */
exports.base.extend({
    name: 'node',
    type: false ,
    /**
     * Defines what happens when node is set
     * @method set
     * @param  {*} val Defines the value of this._node
     */
    set: function(val) {
      //changing node bugs /w conversions
      //iframe selectors dont evaluate to a string
      if (val instanceof Object || !val.length) {
        this._node = val;
      } else {
        this._node = _doc.createElement(val);
      }
      this._node.base = this;
    },
    /**
     * Defines what happens when you get node
     * @method get
     */
    get: function() {
      if (!this._node) {
        this.node = _doc.createElement('div');
      }
      return this._node;
    },
    /**
     * Defines what happens when you create a new node
     * @method new
     * @param  {Object} from    Target
     * @param  {[type]} newnode [description]
     */
    "new": function(from, newnode) {
      if (!newnode) {
        var node = from._node;
        if (node) {
          this._node = node.cloneNode(true); //especialy good to do for memory (also saves 20% on cpu)
          this._node.base = this;
        }
      } else {
        this._node = newnode;
      }
      if (from._node && from._node.hasChildNodes()) {
        var i, c = this._node.childNodes,
          cf = from._node.childNodes,
          l = c.length,
          ci, cfb;
        for (i = 0; i < l; i++) {
          cfb = cf[i].base;
          if (cfb) {
            c[i].base = new cfb.Class(false, false, c[i]);
            //maybe call children new stuff with a custom setting as well?
            if (cfb._name) {
              c[i].base._name = cfb._name;
              this[cfb._name] = c[i].base;
            }
            c[i].base.setting('parent', [this]);
          }
        }
      }
    },
    /**
     * Defines what happens when you remove a node
     * @method remove
     * @param  {*}  [param] If param doesn't remove node from parent
     */
    remove: function(param) {
      _removeChildren.call(this);
      if(this._node) this._node.base = null //little slow optimize later
      if (!param) {
        var _p = this._node.parentNode;
        if (_p) {
          _p.removeChild(this._node);
          if (this._name && _p.base) {
            _p.base[this._name] = null;
          }
        }
      }
    }
  },
  /**
   * Set css class of a div
   * Use addClass or removeClass to add/remove a class
   * @attribute css
   * @param  {Object} val [description]
   * warning: the add operator in css is currently used by .name,
   * and will be replaced when you try to build a string
   * using {val: .... add: ....}
   */
  {
    css: function(val) {
      var _val = val.val || '';
      val._skip = true; //_skip is an ugly name
      if (val.addClass && !~_val.indexOf(val.addClass.val)) {

        val._val = ((_val.length > 0 ? _val + ' ' : '') + val.addClass.val);

        if(val.add) val._val = val._val.replace(val.add.val,'')

        val._lval = false;
        val.__lval = false;
        val.addClass.remove();
        _val = val.val;
        // console.error('???? RESULT CLASS!', val._val )
      }
      if (_val && val.removeClass && val._val) {
        val._val = val._val.replace(new RegExp(' ?' + val.removeClass.val), '');
        val._lval = false;
        val.__lval = false;
        val.removeClass.remove();
        _val = val.val;
      }
      this.node.className = _val;
    }
  },
  /**
   * Makes it possible to reference a child by name
   * Setting on a class does not update names of instances
   * Element[NAME]
   * @attribute name
   */
  {
    name: 'name',
    type: false,
    set: function(val) {
      var _p = this.parent;
      if (this._name) {
        if (_p) {
          _p[this._name] = null;
        }
      }
      this._name = val;
      if (!this._node || val !== this.node.nodeName.toLowerCase()) {
        //name does not inherit, beware!
        // console.log('WHATS THIS?',val);
        // this.css = {addClass:val};
        // this.className = this._name;
        if(!this.css || this.css._val!==val)this.css = { add: ' ' + val }
        //special name field?
      }
      if (_p) {
        _p[val] = this;
      }
    },
    get: function() {
      return this._name;
    }
  },
  /**
   * Returns parent base element
   * @attribute parent
   */
  {
    name: 'parent',
    type: false,
    get: function() {
      if (this._node) {
        var _p = this._node.parentNode || this._p;
        return _p ? _p.base || _p._p : false;
      }
    }
  },
  /**
   * Returns childNodes /w base classes array slow, cache if possible
   * @attribute children
   */
  {
    name: 'children',
    type: false,
    get: function() {
      if(!this._node) return []
      var c = this._node.childNodes,
        l = c.length,
        _c = new Array(l),
        i;
      for (i = 0; i < l; i++) {
        _c[i] = c[i].base || c[i];
      }
      return _c;
    }
  });

var recurRender = function(parent) {

  if (!this.lastindex) this.setting('render', [parent]) //execute render settings

  if (this.renders) {

    // console.error('RENDER ---', this.name, this.renders)

    for (var p
      , c = this.node.childNodes
      , cl
      , arr = this.renders
      , obj
      , i = this.lastindex || 0, l = arr.length; i < l; i++) {
      obj = arr[i]

     if(obj) {
        p = util.checkArray(c, obj, 'base')
        if (p !== false) {
          recurRender.call(obj, this)
        } else if(obj._from) {

          // console.log('CLASS!',obj, obj.name && this[obj.name] && this[obj.name] === cl)

          cl = obj.Class

          if(obj.name && this[obj.name] && this[obj.name] === cl) {
            recurRender.call(this[obj.name], this)
          } else {
           for (var j in c) {
             if (c[j].base && c[j].base instanceof cl) {
               recurRender.call(c[j].base, this)
               break;
             }
            }
          }
        }
      }
      // arr.splice(i,1)
    }
  }

  this.lastindex = l
},

setRender = function() {
  var p, pp;
  if (this.parent) {
    p = this.parent;
    if (p.renders) {
      p.renders.push(this);
    } else {
      p.renders = [this];
      pp = p.parent;
      if (pp && !(pp._settings && pp._settings.render !== true)) {
        setRender.call(p);
      }
    }
  }
},

valRender = function(val) {
  var _settings = (val.__ && val.__._settings || val._._settings)
  if (val._.renders || val.__ && val.__.renders || _settings.render !== true) {
    if (!this.renders) this.renders = []
    if (!(this.__ && this.__.renders)) this.renders = util.clone(this.renders)
    // console.log(this.renders===this.__.renders, this.__.renders, this._.renders)

    // console.log(util.checkArray(this.renders,val._from))
    // console.log('XXXXXX',val)
    // if(util.checkArray(this.renders,val._from._from,'_from._from')===false&&util.checkArray(this.renders,val._from,'_from')===false) {
      this.renders.push(val)
    // }
    // console.log('renders push --- creates leaks!')
  }
}

//define vanuit base (korter!)
util.define(exports,
   'append', function(arr) {

    // alert('APPEND')
    // console.log('APPEND'.inverse,arr)

      var args = arguments

      if(arguments.length>1) {
        arr = util.arg(arguments)
      } //else if(arr )

      var insertbefore
      if(!arr.length && !(arr instanceof exports) && arr.val) {
        insertbefore = arr.before
        arr = arr.val
      }
      var Class = arr[0]
      , i = 0
      , l = arr.length
      if(!arr.length) {
        this.add(arr, insertbefore)
      } else if(typeof Class === 'function') {
        for(var i=1, l = arr.length;i<l;i++) {
          this.add(new Class(arr[i]), insertbefore)
        }
      } else {
        for(;i<l;i++) {
          this.add(arr[i], insertbefore)
        }
      }
  },
  'checkRender', function(val, notRendered) {
    if (val) valRender.call(this, val)
    if (!notRendered) {
      var _renders = (this.__ && this.__.renders || this._.renders)
      if ( ( (_renders  || ((this.__ && this.__._settings)  || this._._settings).render !== true)
          && (!this.lastindex || (_renders && this.lastindex < _renders.length))
        ) && this.rendered) {
        recurRender.call(this, this)
      } else {
        if(this.parent) valRender.call(this.parent, this)
      }
    }
  },
  'checkParent', util.checkParentFactory('parent'),
  'get',function(path, self) { //get does not need an array as path
    return util.get(this, path, self);
  },
  'find', function(get, match, level) {
    if(level === void 0) level = true
    var children = this.node.childNodes
      , i = 0
      , found
      , child
      , len = children.length
      , passOn = level===true ? true : level-1
    for(;i<len;i++) {
      child = children[i].base
      if(child) {
        if(child.get(get, true)==match) {
          return child
        } else if(level) {
          found = child.find(get, match, passOn)
          if(found) return found
        }
      }
    }
  },
  'setRender', function(name, val) {
    this.setSetting({
      name: name,
      render: val
    });
    setRender.call(this);
    this.eachInstance(function() { //look for current caller instance perhaps?
      setRender.call(this)
    }, name);
  },
  'renders', false,
  /**
   * Add element as child
   * @method
   * @param  {Object}  val  Object to be added
   * @return {Object}       Returns the V.element
   */
  'add', function(val, insertbefore) {
    
    if(insertbefore) {
      if(typeof insertbefore === 'string') insertbefore = this[insertbefore]
      if(insertbefore) {
        this.node.insertBefore(val.node, insertbefore.node || insertbefore)
      } else {
        console.error('cannot find insertbefore')
      }
    } else {
              // console.error(val)

      this.node.appendChild(val.node)
    }

    val.setting('parent', [this]) //execute parent settings
    if (val.name) this[val.name] = val
    //--------------------
    //needs cleaning costs 3% now...
    this.checkRender(val)
    //--------------------
    return this
  },
  /**
   * Removes all children
   * @method empty
   * @param  {Boolean} instances True will remove all instances of children removed
   */
  'empty',
  function(instances) {
    var c = this.node.childNodes
      , i
    this.node.innerHtml = ''
    for (i = c.length - 1; i >= 0; i--) {
      if (c[i].base) c[i].base.remove(instances)
    }
  });

exports.base.addSetting('parent')
exports.base.addSetting('render')
require('./set')
},{"../../":"/Users/shawn/Work/vigour-native/node_modules/vigour-js/index.js","../../base":"/Users/shawn/Work/vigour-native/node_modules/vigour-js/base/index.js","../../util":"/Users/shawn/Work/vigour-native/node_modules/vigour-js/util/index.js","../../value/base":"/Users/shawn/Work/vigour-native/node_modules/vigour-js/value/base.js","./set":"/Users/shawn/Work/vigour-native/node_modules/vigour-js/browser/element/set.js"}],"/Users/shawn/Work/vigour-native/node_modules/vigour-js/browser/element/properties/collection/index.js":[function(require,module,exports){

var collection = require('./util')
  , util = require('../../../../util')

/**
 * collection
 * links arrays or object to elements
 * use filter if you want to convert
 * @attribute
 */

exports.extend = util.extend(
  require('../data'),
  function(base){

    base.extend({
      name:'collection',
      // render:function() {
      //   this.update('collection') 
      // },
      remove:function() {
        if(this._colElem) this._colElem.remove()
      },
      set: function(val, stamp, from, remove, change, added) {

        val._skip = true

        var hasFilter = collection.filter(val, this)
          , data = this.filter || val.val
          , options = this._colOptions || val.options 
              && (this._colOptions = val.options.convert())
          , orig =  val.element
          , el = this._colElem 
              || (orig && orig._val) && (this._colElem = new (orig._val.Class || orig._val)())
          , firstRun = !this._colInit
          , slStamp
          , elVal
          , colElem = this._colElem

          // console.log('!!!OPTIONS!', options)

        //dirty block! clean it FAST

        // || !this.rendered 

        if(!(data && el)) return //||!this.rendered
        
        slStamp = orig._slStamp
        elVal = orig._val

        if(slStamp) {
          orig._slStamp = stamp
        } else if(colElem && orig._slStamp !== stamp) {
          if(!(elVal.Class && (colElem instanceof elVal.Class)) 
            && !(!elVal.Class && (colElem instanceof elVal))) {
            el = this._colElem = new (elVal.Class || elVal)()
            orig._slStamp = stamp
          }
        }



        // console.log('ook leuk ff update', val, stamp, from, remove, change, added)
          // console.log('pass!')
          
        if(firstRun) {

          options && options.prepare && options.prepare(el)

          this._colInit = true
          this.node.appendChild(collection.fragment( data, el, this, false, options
            , hasFilter ))

        } else {

          if(from && from._parent === data.from) {
            if(remove) {
              var r = util.checkArray(collection.children(this),from,'_d',true)
              if(r) {
                if(!(options && options.rem && options.rem(r, this, hasFilter))) {
                  r.remove()
                }
              }
            } else if(util.checkArray(collection.children(this),from,'_d')===false) {

              collection.element( from, el, this, true, this.node, options, hasFilter, true )
            } else if(hasFilter && options && options.indexChange) {

                options.indexChange(
                  util.checkArray(collection.children(this),from,'_d',true)
                  , this, hasFilter )
            }
            
          } else {
            
            // console.log('122XXXXX', from, hasFilter, collection.filter(val, this)) //try to fix order by name better

            if(!from) {

              if(remove) {
                collection.clear(this, options)
              } else {

                var c = collection.children(this)
                  , exclude = {}
                  , name
                  , fField
                  , keys
                  , child

                // console.log('XXXXX',hasFilter) //try to fix order by name better
                if(hasFilter===true) {
                  keys = data.keys
                }

                for(var j in c) {
                  child = c[j]
                  name = c[j]._d._name

                  // console.log(c[j], hasFilter, keys, util.checkArray(data,child._d) === false)

                  if(hasFilter && !keys ? util.checkArray(data,child._d) === false : !data[name] || data[name]!==child._d ) {

                    // console.log('CHECK!---',j)

                    if(!(options && options.rem && options.rem(child, this, hasFilter, hasFilter))) {
                      child.remove()
                    }
                  } else {
                    //this is more efficient
                    // if(data[name]!==c[j]._d) c[j].data = data[name] 
                    exclude[name]=true
                    if(hasFilter) {
                      if(options && options.indexChange) {
                        if(child._d._indexCache[hasFilter][0]!==child.i) {
                          options.indexChange(child, this, hasFilter, true)
                        }
                      } else if(hasFilter===true) {
                        if(j!=util.checkArray(keys,name,true)) {
                          delete exclude[name]
                          if(!(options && options.rem && options.rem(c[j], this, hasFilter, hasFilter))) {
                            child.remove()
                          }
                        } 
                      }
                    }
                  }
                }

                this.node.appendChild(
                  collection.fragment(data, el, this, exclude, options, hasFilter)
                )
              }

            }
          }
        }
      }
    })
})
},{"../../../../util":"/Users/shawn/Work/vigour-native/node_modules/vigour-js/util/index.js","../data":"/Users/shawn/Work/vigour-native/node_modules/vigour-js/browser/element/properties/data.js","./util":"/Users/shawn/Work/vigour-native/node_modules/vigour-js/browser/element/properties/collection/util.js"}],"/Users/shawn/Work/vigour-native/node_modules/vigour-js/browser/element/properties/collection/util.js":[function(require,module,exports){
var element = require('../')
  , Data = require('../../../../data').inject(require('../../../../data/selection'))
  , util = require('../../../../util')

var r = function() {
  return String(~~(Math.random()*9))+''
}

exports.element = function (data, element, t, update, node, options, hasFilter, resolve) {
  var elem
  if(options && options.newElement) {
    elem = options.newElement.apply(this,arguments)
    if(elem===true) return
  }
  elem = elem || new element.Class()
  
  elem._col = true

//   console.log( '---->', data )

  if (data !== void 0) elem._dSet(data)
  if (node) node.appendChild(elem.node)
  elem.setting('parent', [t])
  ;options&&options.element&&options.element(elem, t, hasFilter, resolve)
  if (update && data !== void 0) elem.updateData()
  t.checkRender(elem, true)
  return elem
}

exports.fragment = function (data, element, t, exclude, options, hasFilter) {
  var frag = document.createDocumentFragment()
    , item = function(i) {
        //if you use the passed i it is a different value for selections
        if(this._name) i = this._name
        if(!(options&&options.fragment&&options.fragment(t,this,exclude,i))
          && (!exclude || !exclude[i]) ) {
          var elem = exports.element( this || null, element, t, false, frag, options
              , hasFilter)
          if(elem) frag.appendChild( elem.node )
        }
      }
  frag._p = t

  if(data.each) {
    data.each(item)
  } else {
    //normal data
    for(var i in data) {
      item.call( data[i] ,i )
    }
  }

  element.updateData(true)
  return frag
}

exports.children = function (t, options) {
  if(!t) return
  var ch = []
  for(var i in t.node.childNodes) {
    var child = t.node.childNodes[i].base
    if(child && child._col) {
      ch.push(child)
    }
  }
  ;options&&options.children&&options.children(ch)
  return ch
}

exports.clear = function (t, options) {
  t.colInit = null
  var c = exports.children(t)
  for(var i in c) { c[i].remove() }
  ;options&&options.clear&&options.clear(t)
}

exports.filter = function (val,t) {


  var data = val.val


  // console.log('DO I HAVE FULTER!>?',data,  val, t)


  if(val.filter && val.filter.val===true) {
    // console.log('sort by name') moet beter
        // console.log('got it!DATAx!')

    return true
    //different vibes
  }

  if (data && val.filter && !t.filter) {

    // console.log('MAKE NEW STYUFFF')

    var a = val.filter.raw
    //dit is kapot
    data = t.filter = new Data(data, a)

    // console.log('FILTERSSSS!', a, t)
    // debugger

    a._col = true
    
    data.addListener(function (val, stamp, from, remove) {
      t.collection._update(val, stamp, from, remove)
    })
    
    t.setSetting({
      // name: 'collecitonfilter',
      remove: function () {
        t.filter.remove()
        t.filter = null
      }
    })

    // console.log('DATAx!')
    return data._uid
    // return t.filter._uid//data is filter
  } else if(data && data._filter) {
        // console.log('DxxxATAx!')

    return data._uid
  } 
  else if(t.filter) {

    return t.filter._uid
  }

    // console.log('NO DATAX! FILTER', t)

}

// exports.indexChange = function(el, t, hasFilter, noResolve) {
// var oldIndex = el._d._indexCache[hasFilter][1]
//     , newIndex = el._d._indexCache[hasFilter][0]
//     , ch = !noResolve && collection.children(t,exports)
//     , l


//   exports.xy(el)

//   if(noResolve) return

//   l = ch.length
  
  
//   var clone = el.node.cloneNode(true)
//   t.node.removeChild(el)
//   el._node = clone


   
//   // t.h = t.node.scrollHeight
// }
},{"../":"/Users/shawn/Work/vigour-native/node_modules/vigour-js/browser/element/properties/index.js","../../../../data":"/Users/shawn/Work/vigour-native/node_modules/vigour-js/data/index.js","../../../../data/selection":"/Users/shawn/Work/vigour-native/node_modules/vigour-js/data/selection.js","../../../../util":"/Users/shawn/Work/vigour-native/node_modules/vigour-js/util/index.js"}],"/Users/shawn/Work/vigour-native/node_modules/vigour-js/browser/element/properties/data.js":[function(require,module,exports){
/*!
 * @license Copyright (c) 2012-2014, Vigour. All rights reserved.
 * @author: Jim de Beer, jim@vigour.io
 */
var data = require('../../../data/base')
  , util = require('../../../util')
  , flags = require('../../../value/flags')

/**
  * extends updateData to take childNodes into account
  * may need to add extra argument for go deep
  * @method
*/
exports.extend = util.extend([data, {
  updateData: function ( instances, data, fmodel ) {

    // console.log('????----------->>>>>')
    if (this._d) {
      this._subscribed = false
      data = this._d
    }

    var ffmodel = false

    // console.log(fmodel, this.model)
    //dit is omdat er geen model property is op het ding waar data op wordt gebinded dan default ie naar models die er wel zijn
    //oplossing maak model aan altijd als data en niet dfrom

    if (!fmodel && !this.model && !this._fmodel) ffmodel = true
    //fmodel is first model
    for (var children = this.node.childNodes
      , i = children.length - 1
      , base; i >= 0; i--) {
      base = children[i].base
      if (base
      && (!(base.model && base.model.inherit && base.model.inherit.val===false))
      && (base._d === void 0 || base._dfrom)) {
        if (base.model && data) {
          if (ffmodel) base._fmodel = true

          // console.log('FMODEL! -- dSet', data)
          // console.log('------ XXXXXXXXXXXXXXXXX', ffmodel, base._name, '\n', base, data )
          base._dSet(data, true)
        }
        base.updateData(instances, data, base._fmodel || fmodel)
      }
    }
  }
}])

},{"../../../data/base":"/Users/shawn/Work/vigour-native/node_modules/vigour-js/data/base.js","../../../util":"/Users/shawn/Work/vigour-native/node_modules/vigour-js/util/index.js","../../../value/flags":"/Users/shawn/Work/vigour-native/node_modules/vigour-js/value/flags/index.js"}],"/Users/shawn/Work/vigour-native/node_modules/vigour-js/browser/element/properties/index.js":[function(require,module,exports){
/*!
 * @license Copyright (c) 2012-2014, Vigour. All rights reserved.
 * @author: Jim de Beer, jim@vigour.io
 */

  /*
    here some basic html properties are added to V.Element.Nessecary
    for values that you want to be able to bind to V.Objects
    Uses base.extend -- see core.base for more information
  */

var ua = require('../../ua')
  , css = require('../../css')
  , Value = require('../../../value')
  , util = require('../../../util')
  , hash = require('../../../util/hash')
  , raf = require('../../animation/raf')
  , _load = require('../').images = {}
  , _transform = ua.prefix + 'Transform'
  , _cssTransform = ua.prefix + '-transform'
  , body = document.body.style
    //think about doc ready event or fallback if no body
  , _translate = body.perspectiveProperty != void 0
                 || body.WebkitPerspective != void 0
                    ? ['translate3d(', ',0px)']
                    : ['translate(', ')']
  , _coordinate = function(style) {
      var margin = 'margin' + (style[0].toUpperCase() + style.slice(1));
      return function(val) {
        if(val.clean) {
          _cleanCoordinate.call(this,style,margin)
          val.clean = null
        }
        if (val.translate) {
          this.translate(val)
        } else {
          this.node.style[this.relative ? margin : style] = val.val + 'px'
        }
      }
    }
  , _clearTransform = new RegExp(_cssTransform+'(.*?);')
  , _clear =
    { x: /(margin-left(.*?);)|(left(.*?);)/g
    , y: /(margin-top(.*?);)|(top(.*?);)/g
    }
  , _cleanCoordinate = function( check ) {
      var t = this._t
      , keep = false
      , val = this[check]
      , cssText = this.node.style.cssText.replace( _clear[check], '' )

    if( val && val.translate && val.translate.val===false) val.translate = null

    if(this.node.style[_transform] && !val.translate) {
      if(t) {
        if(!this[check].translate) {
          for(var i = 2 ; i < 6 ; i++) {
            if(t[i])keep=true
          }
        } else {
          keep=true
        }
      }
      if(!keep) cssText = cssText.replace(_clearTransform,'')
    }
    this.node.style.cssText = cssText
  }

exports.extend = util.extend(function(base) {
  util.define(base.Class,
    'cleanCoordinates', function(coord) {
       if(this._node) {
        if(!coord) {
          _cleanCoordinate.call(this,'x')
          _cleanCoordinate.call(this,'y')
        } else {
          _cleanCoordinate.call(this,coord)
        }
      }
    },
    'translate', function(val) {
    var _x
      , _y
      , _val =  val.val
      , _scale
      , _rotate
      , _rotateY
      , _rotateX
      , _str = ''
      , _name = val && val._prop.name
      , _t = this._t = this._t || []
      , nope = false

    //cirtical performance point hence use of | 0
    if (_name === 'x') {
      _x = _val | 0
      if (_x === _t[0]) nope = true
    } else if (_name === 'y') {
      _y = _val | 0
      if (_y === _t[1]) nope = true
    } else if (_name === 'rotate') {
      _rotate = _val
      if (_rotate === _t[2]) nope = true
    } else if (_name === 'scale') {
      _scale = _val
      if (_scale === _t[3]) nope = true
    } else if (_name === 'rotateY') {
      _rotateY = _val
      if (_rotateY === _t[4]) nope = true
    } else if (_name === 'rotateX') {
      _rotateX = _val
      if (_rotateX === _t[4]) nope = true
    }

    if (!nope) {
      _t[0] =  _x || (this.x.translate && this.x.val | 0) || 0
      _t[1] =  _y || (this.y.translate && this.y.val | 0) || 0
      _t[2] = _rotate || this.rotate.val
      _t[3] = _scale || this.scale.val
      _t[4] = _rotateY || this.rotateY.val
      _t[5] = _rotateX || this.rotateX.val
      if (_t[0] || _t[1]) {
        _str = _str
          .concat(
            _translate[0]
          + _t[0] + 'px,'
          + _t[1] + 'px'
          + _translate[1]
          )
      }
      if (_t[2]) { _str = _str.concat(' rotate(' + _t[2] + 'deg)') }
      if (_t[3]) { _str = _str.concat(' scale(' + _t[3] + ')') }
      if (_t[4]) { _str = _str.concat(' rotateY(' + _t[4] + 'deg)') }
      if (_t[5]) { _str = _str.concat(' rotateX(' + _t[5] + 'deg)') }
      this.node.style[_transform] = _str
    }
    return this
  }, 'update', function() {
    for (var i = 0, _args = util.arg(arguments), l = _args.length, p; i < l; i++ ) {
      if (_args[i] instanceof Array) {
        this.update.apply(this, _args[i]);
      } else {
        p = util.get(this, _args[i]);
        if (p) {
          p.update(this);
        }
      }
    }
    return this;
  });

  function createScroll(dir){
    var s = 'scroll'
      , sdir = s + dir //scrollLeft or scrollTop

    return {
      name:sdir,
      set:function(val) {
        var v = val.val
          , self = this
        if(v !== void 0) self.node[sdir] = v
        if(!self.__sT){
          self.__sT = true
          self.addEvent(s,function(){
            if(val._listeners !== void 0) val.val = self.node[sdir]
            else self[sdir].__lval = void 0
          })
        }

      },
      get:function(val){
        if(val.__lval === void 0) val.val = this.node[sdir]
        return val
      },
      render:function() {
        var self = this
          , val = self[sdir].__lval
        if(val){
          raf(function(){
            self.node[sdir] = val
          })
        }
      }
    }

  }

  base.extend({
    name: 'relative',
    type: false,
    get: function() {
      var s = this.position !== false ? this.position.val : (this.position = {
        css: true,
        val: css(this.css.val, 'position')
      })
      return s !== 'absolute'
    }
  },
  {
    type: false,
    name: 'rendered',
    get: function() {
      var ret = this._rendered || (this.node === document.body),
        parent;
      if (!ret) {
        parent = this.node.parentNode;
        while (!ret && parent) {
          if (parent.base && parent._rendered) {
            ret = true;
          }
          if (parent == document.body) {
            ret = true;
          }
          parent = parent.parentNode;
        }
        if (ret) {
          this._rendered = true;
        }
      }
      return ret;
    }
  },
  createScroll('Left'),
  createScroll('Top'),
  {
    position: function(val) {
      // console.log('?????',val.css.val)
      // if (!val.css) { //check when ignoring this becomes a problem
        this.node.style.position = val.val;
      // }
    },
    // scrollTop:function(val) {
    //   console.error(val.val)
    //   this.node.scrollTop = val.val
    // },
    rotate: function(val) {
      this.translate(val);
    },
    rotateY: function(val) {
      this.translate(val);
    },
    rotateX: function(val) {
      this.translate(val);
    },
    scale: function(val) {
      this.translate(val);
    },
    src: function(val) {
      var v = val.val;
      if (v && v[v.length - 1] !== '/') {
        this.node.src = v;
      }
    },
    attr:function(val) {
      var t = this
      val.each(function(i) {
        t.node.setAttribute(i,this.val)
      })
    },
    backgroundPos: function(val) {
      this.node.style.backgroundPosition = val.val
    },
    backgroundBatch: function(val) {


    },
    background: function(val) { //optional maybe in a seperate module
      var v = val.val
        , t = this
        , style = this.node.style
        , url
        , hashed
        , parentBatch
        , batch

      if(val.gone && val.gone.val) {
        val._skip = true
        style.backgroundImage = ''
      } else if (v && v[v.length - 1] !== '/') {
        url = 'url(' + v + ')'
        if(style.backgroundImage===url) return

        //Value
        if (val.size) style.backgroundSize = val.size.val

        if (val.load) {

          hashed = hash(v)
          parentBatch = this.checkParent('backgroundBatch')
          if(parentBatch) batch = parentBatch.backgroundBatch

          if(!_load[hashed]) {
            this._loaded = null
            //also remove setting

            if(batch) {
              window.cancelAnimationFrame(batch._raf)
              if(!batch.batch) batch.batch = []
              batch.batch.push(hash)
            }

            _load[hashed]=new Value(false)
            var img = document.createElement('img')
            img.onload = function() {

             if(batch) {
               batch.batch.splice(util.checkArray(batch.batch,hashed),1)
               if(batch.batch.length===0) {
                batch.batch = null
                batch._raf = raf(function() {
                  if(parentBatch._node) batch._val.call(parentBatch)
                })
               }
             }

              _load[hashed].val = true
              img.onload = null
              img = null
              _load[hashed].remove(false,false,false,false,false,true)
              _load[hashed] = true
            }
            img.src = v
          }

          if(_load[hashed]!==true) {
             this._loaded = null

            _load[hashed].addListener([function() {
              if(val.load && val.load.val!==true) val.load._val.call(this, t);
            },val._base], true)
          } else {

            this._loaded = true

            if(batch) {
              if((!batch.batch) || batch.batch.length===0) {
                batch.batch = null
                window.cancelAnimationFrame(batch._raf)
                batch._raf = raf(function() {
                   if(parentBatch._node) batch._val.call(parentBatch)
                })
              }
            }

            if(val.load.val!==true) val.load._val.call(this, t);

          }
        }

        style.backgroundImage = url

      }
    },
    padding: function(val) {
      this.node.style.padding = val.val + 'px';
    },
    y: _coordinate('top'),
    x: _coordinate('left'),
    display: function(val) {
      this.node.style.display = val.val;
    },
    w: function(val) {
      // console.log('w');
      var v = val.val
      this.node.style.width = (v > -1 ? (v | 0)  + 'px' : v ) || '100%' 
    },
    h: function(val) {
      var v = val.val | 0
      this.node.style.height = (v > -1 ? (v | 0)  + 'px' : v ) || '100%'
    },
    opacity: function(val) {
      var v = val.val;
      this.node.style.opacity = v > -1 ? v : 1;
    },
    html: function(val) {
      var v = val.val || ''
      if( v.replace )
      {
        //add some injection prevention as option? (no script etc)
        v = v.replace(/\t/g, '    ')
             .replace(/\r\n|\n|\r/g, '<br/>')
             .replace(/  /g, '&nbsp; ')
             .replace(/  /g, ' &nbsp;') // second pass
                                        // handles odd number of spaces, where we
                                        // end up with "&nbsp;" + " " + " "
        this.node.innerHTML = v
      }

    },
    href: function(val) {
      this.node.href = val.val;
    },
    text: function(val) {

      // console.log('SETTING TEXT'.green.inverse. val.val, val)

      var node = this.node
        , nodes = node.childNodes
        , v = val.val || ''

      if(v instanceof Object) v = ''

      if (/text/.test(node.type)) {
        node.value = v;
        return;
      }

      if (nodes) {
        for (var i = 0, l = nodes.length; i < l; i++) {
          if (nodes[i].nodeType === 3) {
            // console.log('BLABLA'.inverse,v)
            nodes[i].nodeValue = v;
            return;
          }
        }
      }
      node.appendChild(document.createTextNode(v));
    }
  });
});
},{"../":"/Users/shawn/Work/vigour-native/node_modules/vigour-js/browser/element/index.js","../../../util":"/Users/shawn/Work/vigour-native/node_modules/vigour-js/util/index.js","../../../util/hash":"/Users/shawn/Work/vigour-native/node_modules/vigour-js/util/hash.js","../../../value":"/Users/shawn/Work/vigour-native/node_modules/vigour-js/value/index.js","../../animation/raf":"/Users/shawn/Work/vigour-native/node_modules/vigour-js/browser/animation/raf.js","../../css":"/Users/shawn/Work/vigour-native/node_modules/vigour-js/browser/css.js","../../ua":"/Users/shawn/Work/vigour-native/node_modules/vigour-js/browser/ua.js"}],"/Users/shawn/Work/vigour-native/node_modules/vigour-js/browser/element/properties/process.js":[function(require,module,exports){
/*!
 * @license Copyright (c) 2012-2014, Vigour. All rights reserved.
 * @author: Jim de Beer, jim@vigour.io
 */
var util = require('../../../util')

exports.extend = util.extend(function(base) {
  var proto = base.Class.prototype
    , add = proto.add

  util.define
  ( proto
  , 'add'
  ,  function(val) {
       if( !val.process )
       {
          add.apply( this, arguments )
       } else
       {
          val.__tempAdd = util.arg( arguments )
          val.__tempAdd.unshift(this)
       }
     }
  )

  base.extend({
    process: function(val) {
      console.log('xxxx___xxxx')
      if(this.__tempAdd && !this.parent) {
        add.apply(this.__tempAdd[0], this.__tempAdd.slice(1))
        this.__tempAdd = null
      }
    }
  })

})

//process wordt mischien meer een operator?
//soort field eigenlijk
},{"../../../util":"/Users/shawn/Work/vigour-native/node_modules/vigour-js/util/index.js"}],"/Users/shawn/Work/vigour-native/node_modules/vigour-js/browser/element/properties/scrollbar.js":[function(require,module,exports){
/*!
 * @license Copyright (c) 2012-2014, Vigour. All rights reserved.
 * @author: Jim de Beer, jim@vigour.io
 */
var events = require('../../events')
  , cases = require('../../cases')
  , ua = require('../../ua')
  , global = false
  , NONE = 'none'
  , _ios = ua.platform==='ios'
  , _android = ua.platform==='android'
  , VISIBLE = 'visible'
  , extend = require('../../../util').extend
  , doc = events.document
  , timer
  , fn

if(cases.touch){

  function blur (e){
    if(!document.activeElement){
      doc.removeEvent(false,'blur')
    }else if(e.target.tagName!=='INPUT' && e.target.tagName!=='FORM'){
      document.activeElement.blur()
      doc.removeEvent(false,'blur')
    }
  }

  events.preventDown = 
  { val:
    { down:function(e,method) {
        if(document.activeElement) doc.addEvent('up',blur,'blur')
        else if(e.target.tagName!=='INPUT' && e.target.tagName!=='FORM' && !events._maybescroll) e.preventDefault()
      }
    }
  }

  events.scrollbar = 
  { val: 
    { down:function(e,method,val) {

        var scrollStart
          , t = this
          , scrollStr
          , xAxis = (val._val === 'x')
          , axis
          , otheraxis
          , move
          , d
          , bottomPrevent
          
        if(xAxis) {
          axis = 'x'
          otheraxis = 'y'
          scrollStr = 'scrollLeft'
          d = t.node.scrollWidth - t.node.offsetWidth
        }else{
          axis = 'y'
          otheraxis = 'x'
          scrollStr = 'scrollTop'
          d = t.node.scrollHeight - t.node.offsetHeight
        }

        scrollStart = t.node[scrollStr] //<======== less efficient but more predictable for compensation

        if(d > 0){
          events[axis] = true
          events._maybescroll = true
          if(!xAxis){
            if (!scrollStart){
              scrollStart = t.node[scrollStr] =  1
            }else if(scrollStart===d) {
              scrollStart = t.node[scrollStr] = d - 1
            }else if(scrollStart > d){
              bottomPrevent = true
            }
          }

          var y = e.y
            , x = e.x
            , moveid = scrollStr + axis
          
          doc.addEvent('move',function(e){
            var dx = Math.abs(x-e.x)
              , dY = y-e.y
              , dy = Math.abs(dY)

            if(xAxis){
              if(dy > dx){
                events[axis] = false
                if(!events[otheraxis]) e.preventDefault()
              }
            }else{
              if(dx > dy){
                events[axis] = false
                if(!events[otheraxis]) e.preventDefault()
              }
              if(bottomPrevent && dY > 0){
                e.preventDefault()
              }
            }
            console.log('move')
            move = true
            blur(e)
            doc.removeEvent(false,moveid)
          },moveid)

          doc.addEvent('up',function(e) {
            var ms = events._maybescroll, msl, arr

            if(!move){
              var scrll = t.node[scrollStr]
              move = !(scrll === scrollStart) || scrll < 0 || ( scrll > d && !bottomPrevent )
            }

            if( !move && !events[otheraxis] && !events.click.block && ms && ms.length ){
              msl = ms.length
              while(msl--)
              { if(!e.prevent){
                  arr = ms[msl]
                  arr[0].call(arr[1],e)
                }
              }
            }

            if(!events[otheraxis] || move) events._maybescroll = false

            events[axis] = false
            doc.removeEvent(false,scrollStr)

            window.requestAnimationFrame(function(){
              document.body.scrollTop = 0
            })
          },scrollStr)
        }
      }
    }
  }

  fn = function (val) {
      
    var style = this.node.style

    if (val.val === 'x') {
      style.msTouchAction = 'pan-x'
      style.touchAction = 'pan-x'
      style.overflowY = 'hidden'
      // style.overflowX = 'scroll'
    }else if (val.val === 'y') {
      style.msTouchAction = 'pan-y'
      style.touchAction = 'pan-y'
      style.overflowX = 'hidden'
      // style.overflowY = 'scroll'
    }

    style.overflow = 'scroll'

    style.webkitOverflowScrolling = 'touch'
    style.msTouchAction = 'auto'
    style.touchAction = 'auto'

    this.events = { scrollbar:val.val }
    if(!global) {
      global = true
      doc.events = { preventDown:true }
    }
  }

}else{
  fn = function (val) {
    var style = this.node.style;
    style.overflow = 'auto';
    style.overflowY = val.val !== 'x' ? 'scroll' : 'hidden';
    style.overflowX = val.val !== 'y' ? 'scroll' : 'hidden';
  }
}

exports.extend = extend(function(base) {
  base.extend({ scrollbar:fn })
})  
},{"../../../util":"/Users/shawn/Work/vigour-native/node_modules/vigour-js/util/index.js","../../cases":"/Users/shawn/Work/vigour-native/node_modules/vigour-js/browser/cases/index.js","../../events":"/Users/shawn/Work/vigour-native/node_modules/vigour-js/browser/events/index.js","../../ua":"/Users/shawn/Work/vigour-native/node_modules/vigour-js/browser/ua.js"}],"/Users/shawn/Work/vigour-native/node_modules/vigour-js/browser/element/set.js":[function(require,module,exports){
/*!
 * @license Copyright (c) 2012-2014, Vigour. All rights reserved.
 * @author: Jim de Beer, jim@vigour.io
 */

var util = require('../../util')
  , element = require('./')
  , object = require('../../object')

/**
 * flags
 * add keywords to set objects which are checked using a function in flags
 * simply add fields to the set module
 */
var flags = exports
  /**
   * _flag
   * function that calls flag functions on element.set.flags
   */
  , _flag = function(name, val, copy, top) {
      var f;
      for (var i in flags) {
        f = flags[i].call(this, name, val, copy, top);
        if (f) {
          return f;
        }
      }
    }

util.define(element,
  /**
   * set
   * adds children for non existing attributes
   * _original are original values changed by cases and events
   * instances - add or remove children from instances;
   */
  '_set', function(val, i, instances) {

    if (!_flag.call(this, i, val[i], instances, val)) {
      if ( !this.isProperty( i, val ) ) {
        if (val[i] instanceof element) {
          var before
          if (this[i]) {
            for(var c=this.node.childNodes,node$=0,len=c.length;node$<len;node$++) {
              if(c[node$]===this[i].node) {
                before = c[(node$+1)]
                break;
              }
            }
            this[i].remove && this[i].remove();
          }
          //replace element if its already there
          // console.error(add, instances, val[i])
          var add = instances ? new val[i].Class : val[i];
          add.name = i;
          this.add(add, before);
          if (instances) {
            this.eachInstance(function() {
              var a = new add.Class();
              a._name = i;
              this.add(a);
            });
          }
        } else {
          if( this[i] instanceof object ) 
          {
            //TODO: torough testing
            this[i].val = val[i]
          } 
          else if( val[i] instanceof object ) 
          {
            console.warn('are you sure you want to set using a vObject? maybe require some stuff (e.g. data)')
            this[i] = val[i]
          } 
          else if( this[i] instanceof element ) 
          {
            this[i].set(val[i], instances)
          } 
          else 
          {
            var add = new element().set(val[i], instances)
            add.name = i;
            this.add(add)
            if (instances) 
            {
              this.eachInstance( function() {
                var a = new add.Class()
                a._name = i
                this.add(a)
              })
            }
          }
        }
      } else {
        if (val[i] === false && (this[i] instanceof element)) {
          if (instances) {
            this.eachInstance(function() {
              if (this[i]) this[i].remove()
            })
          }
          this[i].remove()
          this[i] = null
        } else {
          //hier ff checkken voor functie
          if(typeof this[i] === 'function') {

            // alert('CALL FUNCTION')

            if(val[i] instanceof Array) {
              this[i].apply(this,val[i])
            } else {
              this[i](val[i])
            }
          } else {
            this[i] = val[i]
          }
        }
      }
      //dynamic changes to the _original set object pool
      //if (!copy && this._original) {
      //this._original[i] = val[i]; //check if stuff /w classes is nessecary;
      //}
    }
  },
  /**
   * convert
   * for each fields in val convert back to a setObject;
   */
  'convert', function(val) {
    var setObj = {},
      isObj;
    for (var i in val) {
      isObj = util.isObj(val[i])
      if (this[i] instanceof element) {
        setObj[i] = isObj ? this[i].convert(val[i]) : this[i]
      } else if (this[i] instanceof object) {
        setObj[i] = this[i].convert(isObj && val[i])
      } else if (this[i] === void 0 || (util.lookup.call(this, i) && this[i] === false)) {
        setObj[i] = false
      } else {
        setObj[i] = this[i]
      }
    }
    return setObj
  })
},{"../../object":"/Users/shawn/Work/vigour-native/node_modules/vigour-js/object/index.js","../../util":"/Users/shawn/Work/vigour-native/node_modules/vigour-js/util/index.js","./":"/Users/shawn/Work/vigour-native/node_modules/vigour-js/browser/element/index.js"}],"/Users/shawn/Work/vigour-native/node_modules/vigour-js/browser/events/basic.js":[function(require,module,exports){
/*!
 * @license Copyright (c) 2012-2014, Vigour. All rights reserved.
 * @author: Jim de Beer, jim@vigour.io
 */
var events = module.exports = require('./')
  , cases = require('../cases')
  , util = require('../../util')
  , ua = require('../ua')

cases.touch =
( ( 'ontouchstart' in window )
  || window.DocumentTouch
  && document instanceof DocumentTouch
)
|| navigator.msMaxTouchPoints
|| false

function _basic(e, method, val) {
  e.x = e.pageX
  e.y = e.pageY
  method.call(this, e, val)
}

util.define
( events
, '_out'
, { value: [] }
)
//clickout cannot be used to create complex events! it's too custom 
//tried to fix

function keyBoardEvent( name, domEvent, wrapper ) {

  var _name = '_'+name

  util.define( events, _name, { value:[] } )

  var event = 
  {
    create: function( field, from ) {
      var exec = function( e ) {

        //dit gaat heel snel fout hiero
        // console.log('nu ff ook de wrapper callen!', field, from, events[from])
         if( this.rendered ) {

          if( wrapper ) {
            wrapper.call(this, e, this.events[from]._val )
            //this.events[from]._val.call(this, e)
          }
          else if( events[from] && events[from].val) {
            var method = events[from].val
            for(var i in events[from]) {
              if( cases[i]) {
                method = events[from][i]
              }
            }
            method = method[field]
            if( method ) {
              method.call(this, e, this.events[from]._val )
            } 
          } else if( this.events[from] ) {
            this.events[from]._val.call(this, e)
          }

        }
      }
      events.document.addEvent( domEvent, function(e) {

        for ( var arr = events[ _name ], i = arr.length - 1; i >= 0; i-- ) {
          exec.call( arr[i], e )
          
          if( arr[i] ) {
            // console.log( 'do it now!', _name, arr, arr[i], e)
            arr[i].eachInstance( exec, 'events', e )
          }

        }
      }, name )
    },
    add: function( id, field ) {

      field = _name

      this.setSetting(
      { name: field
      , remove: events[ name ].remove
      })

      if ( !util.checkArray( events[ _name ], this ) ) 
      {
        events[ _name ].push(this)
      }

    },
    remove: function() {
      // console.log('WRONGWRONGWRONG!!!!!', _name, events[_name], events)
      //selected moet mischein alleen vanuit Value $focused -- niet op elk item op key up....
      //doe dit smart -- for now zou auto remove kunnen doen als iets er niet meer is?
      var index = util.checkArray( events[ _name ], this, true ) 
      if( ~index ) {

        var noRemove

        // console.log('this:', this )
        // console.log('from base:', this._from.base)
        // console.log('event name:', name)
        // console.log('events:', this.events )
        if(this.events && this._from.base.events) { 
          noRemove = this.events[name] === this._from.base.events[name]
          // console.log('events equals class:', noRemove )
        } else {
          // console.error('no nice events')
        }
        
        if(!noRemove) {
          events[ _name ].splice( index, 1 )
        }
        else {
          console.log(noRemove, 'noRemove evnt, are we sure - fix this asap')
        }
        // debugger
        // this.removeSetting( name ) --- redo this later
      }
    }
  }

  events[ name ] = event

}

events.$makeKeyBoardEvent = keyBoardEvent

keyBoardEvent( 'keyboard', 'keyup' )
keyBoardEvent( 'keyboardDown', 'keydown' )
keyBoardEvent( 'keyboardDown$down', 'keydown' )
keyBoardEvent( 'keyboardDown$click', 'keydown' )

//-----dit ff echt goed fixen!

function basicDown(e, method, val) {
  if( e.which !== 1 || events.down.block ) return
   _basic.call(this,e, method, val)
}

events.down =
{ touch:
  { touchstart: function(e, method, val) {
      if(events.down.block) return
      var targetTouches = e.targetTouches[0] || {}
      e.x = targetTouches.pageX
      e.y = targetTouches.pageY
      method.call(this, e, val)
    }
  }
, val: { mousedown: basicDown }
// , tv: 
//   {  // mousedown: basicDown //combineren binnen kort moet voor LG
//      keyboardDown$down: function( e, method, val ) {
//       //this._$focused && 
//       if( this._$focused && util.checkArray( [ 13, 29443 ] , e.keyCode ) !== false ) 
//       {
//         method.call(this, e, val)
//       }

//     }
//   }
}

//right-down
events.rdown =
{ touch:
  { touchstart: function () {
      //2 fingers?
    }
  }
, val:
  { mousedown: function (e, method, val) {
      if(e.which===3) {
        document.oncontextmenu = function() { return false }
        e.preventDefault()
        // e.rdown = true
        _basic.call(this,e,method,val)
        setTimeout(function() { document.oncontextmenu = false }, 0)
      }
    }
  }
}

//move
events.move = {
  touch:
  { touchmove: function (e, method, val) {
      var targetTouches = e.targetTouches[0]
      e.x = targetTouches.pageX
      e.y = targetTouches.pageY
      method.call(this, e, val)
      // document.write(e.targetTouches[0].pageX);
    }
  }
  , val: {
    mousemove: _basic
  }
}

//up
events.up = {
  //keyUp
  touch: {
    touchend: function(e, method, val) {
      var ct = e.changedTouches
      e.x = ct[0].pageX
      e.y = ct[0].pageY
      method.call(this, e, val)
    }
  }
, val: {
    mouseup: _basic
  }
}

//click
events.click = {
  // tv: {
  //   keyboardDown$click: function(e, method, val ) {

  //     if( this._$focused && util.checkArray( [ 13, 29443 ] , e.keyCode ) !== false ) {
  //       method.call(this, e, val)
  //     }

  //   }
  // },
  val: {
    down: function(e, method, val) {
      var t = this
        , name = 'click'
      if( !events.click.block )
      {
        t.addEvent('up', function(e) {
          t.removeEvent('up', name)
          var ms = events._maybescroll
          if(ms){
            if(ms.length) events._maybescroll.unshift([method,t])
            else events._maybescroll = [[method,t]]
          }else if(!events.click.block) method.call(t, e, val)
        }, name);

        setTimeout(function() {
          t.removeEvent('up', name)
        }, 300)
      }
    }
  }
}

events.rclick = {
  val: {
    rdown:events.click.val.down
  }
}

var _outRemove = function() {
    var index = util.checkArray(events._out, this, true)
    if (~index) {
      events._out.splice(index, 1)
      this.removeSetting('_out', _outSetting)

      // debugger

    }
  }
, _outSetting = {
  name: '_out',
  render: function() {
    if (!util.checkArray(events._out, this)) {
      events._out.push(this)
    }
  },
  remove: _outRemove
}

events.out = {
  create: function() {
    this.m = true;
    events.document.addEvent('up', function(e) {

      var base = e.target,
        exec = function() {
          var p = base
            , t
          while (p && !t) {
            if (p.base && this === p.base) {
              t = true;
            } else {
              p = p.parentNode;
            }
          }
          if (!t && this.rendered) this.events.out._val.call(this, e)
        }
      for (var arr = events._out, i = arr.length - 1; i >= 0; i--) {
        exec.call(arr[i])
        if (arr[i]) arr[i].eachInstance(exec, 'events')
      }
    },'out')
  },
  add: function() {
    var t = this
     // events._out.push(this)
    this.setSetting(_outSetting)
  },
  remove:_outRemove
};
},{"../../util":"/Users/shawn/Work/vigour-native/node_modules/vigour-js/util/index.js","../cases":"/Users/shawn/Work/vigour-native/node_modules/vigour-js/browser/cases/index.js","../ua":"/Users/shawn/Work/vigour-native/node_modules/vigour-js/browser/ua.js","./":"/Users/shawn/Work/vigour-native/node_modules/vigour-js/browser/events/index.js"}],"/Users/shawn/Work/vigour-native/node_modules/vigour-js/browser/events/index.js":[function(require,module,exports){
/*!
 * @license Copyright (c) 2012-2014, Vigour. All rights reserved.
 * @author: Jim de Beer, jim@vigour.io
 */
var element = require('../element')
  , cases = require('../cases')
  , util = require('../../util')
  , FieldStore = function () {}

util.define(FieldStore, '_uid', { value: 0 })

exports._r = {} //list of basic (raw) events e.g. 'mousedown'

//remove events if there are no children that use them anymore

exports.document = new element({ node: document })

exports.document.exec = function( event ) {
  if( this.__e[event] )
  {
    var args = util.arg( arguments, 1 )
    for( var i in this.__e[event] )
    {
      this.__e[event][i].apply( this, args )
    }
  }
}

function _create( i, from ) {
  if( exports[i] )
  {
    // console.log('complex', i, from)
    _createComplex( i, from )
  }
  else
  {
    // console.log('_basic', i)

    exports[i] = { _basic: true }
    _createBasic( i )
  }
}

function _createWhile (i, m) {
  return function(e) {
    var parent = e.target
      , base, events
    while (parent) {
      base = parent.base
      if (base) {
        events = base.events
        if (events[i]) {
          if (m) {
            exports[i]._m.call(base, e, events[i])
          } else if (events[i]._val) {
            events[i]._val.call(base, e)
          }
          if (e.prevent) return
        }
        events = base.__e
        if (events && events[i]) {

          for (var j in events[i]) {
            if(j!=='_uid') {
              if (m) {
                exports[i]._m.call(base, e, events[i][j])
              } else {
                // console.log('?what', i, j, base, base._node)
                events[i][j].call(base, e)
              }
              if (e.prevent) return
            }
          }
        }
      }
      parent = parent.parentNode
    }
  }
}

function _createBasic (i, r) {
  var type = i || r

  // console.log('createBasic', type)

  exports._r[i] = true
  if(type === 'scroll') {
    document.addEventListener(type, function(e){
      var base = e.target.base
        , events
      if(base) {
        events = base.events
        if(events && events[i]) events[i]._val.call(base, e)
        events = base.__e
        if (events && events[i]) {
          for (var j in events[i]) {
            if(j!=='_uid') events[i][j].call(base, e)
          }
        }
      }
    },true)
  }else document.addEventListener(type, (exports[i].m = _createWhile(i)))
}

function _setComplex ( i, m, r, from ) {
  var met = exports[i]._m = function (e, val) {
    if (e.prevent) return
    m.call(this, e, (val._val || val.val || val), val)
  }
  exports[i].m = _createWhile(i, true)
  exports._r[i] = true
  if (exports[r]) {
    if (!exports[r].m) {
      _create(r, from )
    }
    if (!exports[r]._basic) {
      exports[i].__e = exports[r].__e
      exports[i]._m = function (e, m) {
        exports[r]._m.call(this, e, function(e) {
          met.call(this, e, m)
        })
      }
    } else {
      exports[i].__e = r
    }
  }
  document.addEventListener((exports[r] && exports[r].__e) || r, exports[i].m)
}

var addWrapper = function( add, field, orig ) {
  return function() {
    // console.log( 'ADD WRAP!', field, orig , arguments )
    return add.apply(this, arguments)
  }
}

function _createComplex( field, from ) {

  // console.log('_createComplex' ,field, from )

  if( exports[field].create ) exports[field].create( field, from)
  var m
    , i
    , j
  for ( i in exports[field] ) {
    if (cases[i] === true) m = exports[field][i]
  }
  if ( m || ( m = exports[field].val ) ) {
    for (j in m) //only one
    ;exports[field].__e = j

    if (m[j] === true) 
    {
      exports[field]._basic = true
      _createBasic(field, j)
    } 
    else 
    {
      //basic en non basic ijn niet te combineren -- combineren nog kapot
      // console.log('set complex field', field, m, j,  exports[j]) 
      //!!!tripple check dit!!!
       for( j in m ) 
       { 
        if( exports[j] && exports[j].add 
         && exports[field] && !exports[field].add
        ) 
        {
          exports[field].add = addWrapper( exports[j].add, field, j )
        }
        _setComplex(field, m[j], j, from )
      }
      //!!!danger loop!!!
    }

  }
}

exports._set = function (val, stamp, from, remove, cval, blacklist) {
  var t = this
  val.each(function (i) {
    if (!blacklist || !blacklist[i]) {
      if (this._val === false) {
        if (exports[i]) {
          if (exports[i].remove) exports[i].remove.call(t)
          t.eachInstance(exports[i].remove, val._prop.name)
          this.remove()
        }
      } else {
        
        // console.log('_cre', i, exports[i])

        if (!(exports[i] && exports[i].m)) {
          // console.log('---pass', i)
          _create(i, i)
        }
        //add wrapper?


        // console.log('_set',i, exports[i].add, exports[i])

        if (exports[i].add) exports[i].add.call( t, false, i )
      }
    }
  })
}

element.base.extend(
{ name: 'events'
, set: exports._set
})

util.define(element
, 'addEvent', function(field, fn, id) {
          // console.log('XXXX',field)

    if (!(exports[field] && exports[field].m)) _create(field)
    var events = this.__e || (this.__e = {})
      , f = events[field] || (events[field] = new FieldStore())

    if (!id) {
      f._uid++
      id = f._uid
    }
    f[id] = fn

    // console.log('addEvent!!!', field)

    if (exports[field].add) exports[field].add.call(this, id, field)
    return this
  }
, 'removeEvent', function (field, id, fn) {
    var events = this.__e
      , remove
    if (events) {
      if (field && events[field]) {
        remove = (exports[field] && exports[field].remove)
        if (id) {
          if (events[field][id] && (!fn || events[field][id] === fn)) {
            if (remove) exports[field].remove.call(this, id)
            delete events[field][id]
          }
        } 
        else {
          for (id in events[field]) {
            if (!fn || events[field][id] === fn) {
              if (remove) exports[field].remove.call(this, id)
              delete events[field][id]
            }
          }
        }
        if (util.empty(events[field])) delete events[field]
      } 
      else if (!field) {
        for (field in events) {
          this.removeEvent(field, id, fn)
        }
      }
    }
    if (util.empty(events)) delete this.__e
    return this
  })

require('./basic')

},{"../../util":"/Users/shawn/Work/vigour-native/node_modules/vigour-js/util/index.js","../cases":"/Users/shawn/Work/vigour-native/node_modules/vigour-js/browser/cases/index.js","../element":"/Users/shawn/Work/vigour-native/node_modules/vigour-js/browser/element/index.js","./basic":"/Users/shawn/Work/vigour-native/node_modules/vigour-js/browser/events/basic.js"}],"/Users/shawn/Work/vigour-native/node_modules/vigour-js/browser/network/ajax.js":[function(require,module,exports){
/*!
 * @license Copyright (c) 2012-2014, Vigour. All rights reserved.
 * @author: Jim de Beer, jim@vigour.io
 */
var _a = 'addEventListener'
  , util = require('../../util')
  , ua = require('../ua')
  , cnt = 0

/**
 * xhr wrapper, adds some nice extras such as multiple requests to a single api call
 * xhr wrapper will include jsonp in a later stage
 * @method extend
 * @param   {String|Array} params.url         Specifiy the url, array fetches multiple url's
 * @param   {String}   [params.api]           Repeat this string for the url that needs to be called
 * @param   {Function} [params.complete]      Specify a callback when an array is passed to url complete is called when all items are complete
 * @param   {Function} [params.error]         On error callback
 * @param   {Function} [params.change]        Function called on xhr.onreadystatechange
 * @param   {Boolean}  [params.async]         If set to false will call an syncronous request (not recommended!)
 * @param   {String}   [params.user]          User parameter
 * @param   {String}   [params.pass]          Password parameter
 * @param   {Boolean}  [params.parse]         If set to false will not try to parse response to JSON
 * @param   {String}   [params.type|.method]  POST or GET, default is get;
 * @param   {String}   [params.contentType]   request content type default id "application/x-www-form-urlencoded"
 * @param   {String}   [params.mime]          defines mime type
 * @param   {Function} [params.progress]      Progress callback
 * @param   {Boolean|String} [params.jsonp]   Use jsonp , if passed as a string determines script+?callback=
 * @param   {Object}   [params.header]        Sets request headers
 * @param   {*}        [params.data]          Pass data to the request, defaults to ? on get;
 */

var iframes
  , ajax = module.exports = function(params, urlset) {
    var _url = params.url;
    if (!urlset && _url instanceof Array) {
      params.m = function() {
        if ((++params.r) === params.n) {
          for (var i = 0, arr = [], l = _url.length; i < l; arr.push(params.d[_url[i++]]));
          params.complete(arr);
        }
      };
      params.r = 0;
      params.d = {};
      for (var i = 0, l = params.n = _url.length; i < l; module.exports(params, _url[i++]));
    } else {
      var data = params.data
        , encode = params.encode
        , url = (params.api || '') + (urlset || _url)
        , headers = params.headers
        , success = params.complete
        , progress = params.progress
        , error = params.error
        , change = params.change
        , mime = params.mime
        , user = params.user
        , pass = params.pass
        , jsonp = params.jsonp
        , parse = params.parse
        , iframe = params.iframe
        , reqdata = null
        , fallback = params.fallback
        , fallbackIndex = params._fallbackIndex
        , method = params.type || params.method || 'GET'
        , contentType = params.contentType || encode === 'json'
          ? 'application/json'
          : 'application/x-www-form-urlencoded'
        , async = (params.async === false) ? false : true
        
      if( jsonp ) 
      {
        ajax.jsonp( url, success, error )  
        //function( url, success, error, context, cbName ) {
      } 
      else 
      {
        // ------------------------------------------------------------ DATA
        var xhr = new XMLHttpRequest()
        if(iframe) {
          cnt++
          var elem
            , msg = {}
            , reqid = cnt

          for(var field in params) {
            if(field!=='error'&&field!=='iframe'&&field!=='complete') {

              msg[field]=params[field]
            }
          }
          var setmsg = function() {
            var elem
            iframes[iframe].onload = null
            var msgcomplete = function(e) {
              // console.error('IFRAME REQ MSG COMPLETE',e.data)
              if(e.data) {
                var d
                try {
                  d = JSON.parse(e.data)
                } catch(e) {
                  if(error) error(e)
                  return
                }
                if(d.id!==reqid) return
                if(d.err) {
                  if(error) {
                    error(d.err)
                  }
                  return
                }
                var resp = d.msg
                if(success) {
                  if (parse !== false) {
                    try {
                      resp = JSON.parse(resp)
                    } catch (e) {}
                  }
                  success(resp,e)
                }
                removeEventListener('message', msgcomplete)
              }
            }
            if(window.addEventListener) {
              addEventListener("message", msgcomplete, false)
              elem = iframes[iframe].contentWindow
              msg = JSON.stringify({
                msg:msg,
                id:reqid
              })
              elem.postMessage(msg, '*')
            }
          }

          if(!iframes) iframes = {}
          if(!iframes[iframe]) {
            elem = iframes[iframe] = document.createElement('iframe')
            elem.src = iframe
            elem.cListeners = [
              setmsg
            ]
            elem.onload = function() {
              for(var h in elem.cListeners) {
                elem.cListeners[h]()
              }
              elem.cListeners = null
            }
            elem.style.visibility='hidden'
            elem.style.width = '0px'
            elem.style.height = '0px'
            elem.style.position = 'absolute'
            document.body.appendChild(elem)
          } else if(iframes[iframe].cListeners) {
            iframes[iframe].cListeners.push(setmsg)
            //elem.cListeners[i]
          } else {
            setmsg()
          }
          return;
        }

        if (data) {

          if (method === 'GET') {
            url += '?' + enCode(data, 'GET', encode)
          } else {
            reqdata = enCode(data, 'POST', encode)
  //           console.log( reqdata )
          }
        }

        // ------------------------------------------------------------ METHOD, URL, ASYNC, USER & PASS
        xhr.open(method, url, async, user, pass)
        // ------------------------------------------------------------ HEADERS
        xhr.setRequestHeader('Content-Type', contentType)
        if (headers) {
          for (var f in headers) {
            xhr.setRequestHeader(f, headers[f]);
          }
        }

        // ------------------------------------------------------------ EVENTS
        if (success) {
          xhr[_a]("load", function(e) {
            var resp = (e.target || e.srcElement).response;
            if (parse !== false) {
              try {
                resp = JSON.parse(resp)
              } catch (e) {}
            }
            if (params.m) {
              params.d[urlset] = resp
              params.m()
            } else {
              success(resp, e)
            }
          }, false)
        }
        if (error) {
          if(!fallbackIndex) params._fallbackIndex = 0
          if(fallback && fallbackIndex!==fallback.length) {
            params._fallbackIndex++
            params = util.merge(params,fallbackIndex)
            ajax(params, urlset)
          } else {
            xhr[_a]("error", error, false)
          }
        }
        if (progress) {
          xhr[_a]("progress", progress, false)
        }
        if (change) {
          xhr.onreadystatechange = change
        }
        // ------------------------------------------------------------ MIME
        if (mime) {
          xhr.overrideMimeType(mime)
        }
        // ------------------------------------------------------------ SEND

        xhr.send(reqdata)
      }
    }
  }

var jsonpStamp = 0

ajax.jsonp = function( url, success, error, context, cbName ) {

  if( !cbName || cbName === true ) cbName = 'callback'

  var name = '_jsonp_' + jsonpStamp++
    , script = document.createElement('script')
  
  if (url.match(/\?/)) 
  { 
    url += '&'+cbName+'='+name
  }
  else 
  {
    url += '?'+cbName+'='+name
  }
  
  script.type = 'text/javascript'
  script.src = url
  
  if(error) {
    script.onerror = function( e ) {
      error( e )
    }
  }

  window[name] = function(data){
    success.call(( context || window ), data)
    document.getElementsByTagName('head')[0].removeChild(script)
    script = null
    delete window[name]
  }
  
  document.getElementsByTagName('head')[0].appendChild(script)

}

var enCode = ajax.encode = function(data, method, encode) {
  var result = ''

  if(encode === 'json'){
    result = JSON.stringify(data)
  } else if(data instanceof Object) {
    if (!util.isNode && (window.FormData && data instanceof FormData) && method !== 'GET') {
      result = data
    } else if (data instanceof Array) {
      result = JSON.stringify(data[f])
      if(encode === 'uri') result = encodeURIComponent(result)
    } else {
      for (var f in data) {
        var val = data[f]
        if(val instanceof Object) val = JSON.stringify(val)
        if(encode === 'uri'){
          f = encodeURIComponent(f)
          val = encodeURIComponent(val)
        }
        result += f + '=' + val + '&'
      }
      result = result.slice(0, -1)

    }
  } else {
    result = (encode === 'uri') ? encodeURIComponent(data) : data
  }
  // console.log('encoded:', result)
  return result
}
},{"../../util":"/Users/shawn/Work/vigour-native/node_modules/vigour-js/util/index.js","../ua":"/Users/shawn/Work/vigour-native/node_modules/vigour-js/browser/ua.js"}],"/Users/shawn/Work/vigour-native/node_modules/vigour-js/browser/ua.js":[function(require,module,exports){
/*
 * @license Copyright (c) 2012-2014, Vigour. All rights reserved.
 * @author: Jim de Beer, jim@vigour.io
 */
/*
/*
  useragent sniffing is never used for feature detection, for a multi-screen app you do need information about the device also when running in the browser
  has fields V.ua.platform, device, browser and version. This implementation when compiled, is only 700 bytes
*/
var util = require('../util')
/**
 * test
 * search for regexps in the userAgent
 * fn is a on succes callback
 * check http://www.useragentstring.com/ to test for userAgents
 * @method
 */
, test = exports.test = function( _ua, fn ) {

  for
  ( var tests = util.arg( arguments, 1 )
      , i = tests.length - 1
      , query = tests[i][0]
    ; query !== true && !new RegExp( query ).test( _ua )
    ; query = tests[--i][0]
  )

  ;if( fn.slice || fn.call( this, query, tests[i] ) )
  {
    this[fn] = tests[i][1]
  }

}
, parse = exports.parse = function(_ua, obj) {

  if( !_ua )
  {
    obj = exports
    _ua = typeof navigator !== 'undefined'
        ? navigator.userAgent.toLowerCase()
        : 'no navigator'
  }

  _ua = _ua.toLowerCase()

  if( !obj ) obj = {}

  // _ua = 'webos; linux - large screen'

  var _ff = 'firefox'
    , _android = 'android'
    , _mobile = '.+mobile'
    , _webkit = 'webkit'
    , _ps = 'playstation'
    , _xbox = 'xbox'
    , _linux = 'linux'
    , _castDetect = 'crkey'
    , _chromecast = 'chromecast'
    , _tablet = 'tablet'
    , _windows = 'windows'
    , _phone = 'phone'
    , _iphoneVersion

  test.call
  ( obj
  , _ua
  , function( query, arr ) {

      obj.browser = arr[2] || query

      var _v = _ua.match
      ( new RegExp
        ( '((([\\/ ]version|'
        + arr[0]
        + '(?!.+version))[\/ ])| rv:)([0-9]{1,4}\\.[0-9]{0,2})'
        )
      )

      obj.version = _v ? Number( _v[4] ) : 0
      obj.prefix = arr[1]
      //TODO: add prefix for opera v>12.15;
      //TODO: windows check for ie 11 may be too general;
    }
  , [ true, _webkit ]
  , [ '\\(windows', 'ms', 'ie' ]
  , [ 'safari', _webkit ]
  , [ _ff, 'Moz' ]
  , [ 'opera', 'O' ]
  , [ 'msie', 'ms', 'ie' ]
  , [ 'chrome|crios\/', _webkit, 'chrome' ]
  )

  /**
  * platform detection
  */
  test.call
  ( obj
  , _ua
  , 'platform'
  , [ true, _windows ]
  , [ _linux, _linux ]
  , [ 'lg.{0,3}netcast', 'lg' ] //TODO:propably need to add more!
  , [ _ff + _mobile, _ff ]
  , [ 'mac os x', 'mac' ]
  , [ 'iphone|ipod|ipad', 'ios' ]
  , [ _xbox, _xbox ]
  , [ _ps, _ps ]
  , [ _android, _android ]
  , [ _windows, _windows ]
  , [ _castDetect, _chromecast ]
  , [ 'smart-tv;|;samsung;smarttv', 'samsung' ] //SmartTV2013
  )

  /**
  * device detection
  */
  test.call
  ( obj
  , _ua
  , 'device'
  , [ true, 'desktop' ]
  , [ _windows + '.+touch|ipad|' + _android,  _tablet ]
  , [ 'iphone|(' + _android + _mobile + ')|(' + _ff + _mobile + ')|' + _windows + ' phone|iemobile'
    , _phone
    ]
  , [ _xbox + '|' + _ps, 'console' ]
  , [ 'tv|smarttv|googletv|appletv|hbbtv|pov_tv|netcast.tv|webos.+large', 'tv' ]
  , [ _castDetect, _chromecast ]
  , [ 'amazon-fireos', _tablet ]
  )

  //TODO: amazon firetv and phone
    // alert(window.innerWidth*window.innerHeight +  '  '+ 414 * 736)
  
  //414 × 736
  var iphone6plus = 414 * 736
  if
  ( obj.platform === _android
    && !util.isNode
    && obj.device === _phone
    && window
    && window.innerWidth * window.innerHeight > iphone6plus
    // && ~_ua.indexOf('crosswalk')
  )
  {
    obj.device = 'tablet'
  }

  return obj
}

if( !util.isNode ) 
{ 
  parse()
  //TODO: this is very ugly, try to find a better solution
  if( window && window.__ua__ ) 
  {
    for( var field in window.__ua__ )
    {
      exports[field] = window.__ua__[field]
    }
  }
}

/**
 * prop
 * re-writes js properties to their css counterpart
 * e.g. webkitTransform --> -webkit-transform
 * now its commented since its not nessecary yet
 * @method
 */
// this.prop = function(str) {
//  return str.replace(this.prefix,'-'+this.prefix+'-').toLowerCase();
// }

},{"../util":"/Users/shawn/Work/vigour-native/node_modules/vigour-js/util/index.js"}],"/Users/shawn/Work/vigour-native/node_modules/vigour-js/data/base.js":[function(require,module,exports){
/*!
 * @license Copyright (c) 2012-2014, Vigour. All rights reserved.
 * @author: Jim de Beer, jim@vigour.io
 */
var  data = require('./')
  , base = require('../base')
  , util = require('../util')
  , flags = require('../value/flags/data')
  , vObject = require('../object')

exports.extend = util.extend( function(base, extensions, modelblacklist) {

    var removeMethod = function( reset, fieldCorrected ) {

      // if( reset )
      // {
      //   // console.log('RESET REMOVE!'.inverse, this.__checkKeys__, this )
      //   // debugger
      // }
      // else {
      //   // console.log( this.__checkKeys__, this._d )
      // }

      // if(this._d && this._d._listeners) {
      //   console.log( 'START REMOVING LISTENERS'.blue.inverse, DEBUG$.countListeners(this._d) )
      // }

      var excludes 
      //if type === '$reset'

      if( this._d )
      {
        // console.log('2 REMOVE!'.inverse)

        if ( this._d.__t )  
        {
          // console.log('removeListener FROM myself', reset === this._d , this._d, reset)


          // console.log('REMOVE!'.red.inverse, this._d._listeners.length)
          this._d.removeListener( void 0, this )
          // console.log('REMOVE!', this._d._listeners.length)

          if( !this._d.cloud )
          {
            var _this = this
            this._d.each(
              function( key ) { 
                // _this.__checkKeys__ = true
                if( reset && reset[key] !== this ) 
                {
                  // console.log('removeListener ---')
                  if(this.__t === 4 ) this.removeListener( void 0, _this ) 
                }
                else if( reset )
                {
                  if( !excludes ) excludes = []
                  excludes.push( key )
                }
              }
            )
          }

          this.__checkKeys__ = null//TODO: only remove listeners if checkkeys === true

        }
        else if( this.__checkKeys__ ) 
        {
          // console.log('22222 REMOVE!'.inverse)

          for( var key$ in this.__checkKeys__ ) 
          {
                              // console.log('removeListener --- 2')

            if( this._d[this.__checkKeys__[key$]] instanceof vObject )
            {

                                            // console.log('removeListener --- 22')


               if( ( reset && reset[ this.__checkKeys__[key$] ] ) !== this._d[ this.__checkKeys__[key$] ] ) 
               {
                  // console.log('removeListener ---')
                  this._d[this.__checkKeys__[key$]].removeListener( void 0, this )
               }
               else if( reset )
               {

                  if( !excludes ) excludes = []
                  // console.log('EXCLUDE RESET REMOVE!'.inverse, this.__checkKeys__[key$] )
                  excludes.push( this.__checkKeys__[key$] )

               }
              
            }
          }

          this.__checkKeys__ = null

        }
      }

      // if(this._d && this._d._listeners) {
      //   console.log( 'DONE REMOVING LISTENERS'.blue.inverse, DEBUG$.countListeners(this._d) )
      // }

      //things that are excluded
      return excludes

    }

  // var _blacklist = util.add(['flags', 'ref', 'parse', 'parsing'], modelblacklist),
    var _compare = util.compareArrays,
    methods = {
      _dUpdate: function(obj, val, stamp, from, remove, added, oldval, instances, argx1, argx2 ) {
        // if(window.here) console.log('X',stamp)
        if (this.model) {

          //$ndata

          //TODO: very dirty fix get rid of this!
          if( obj === '$ndata' ){
            val = from
            stamp = remove
            from = added
            remove = oldval
            added = instances
            oldval = argx1
            instances = argx2
            // console.log('!@#!@#!@#!@#@!#!@#!@#!@#'.red.inverse)
          }

          // var non = 0
          //   , cnt = 0
          // for( var i in arguments ) 
          // {
          //   cnt++
          //   if(!arguments[i]) {
          //     non++
          //   }
          //   console.log( arguments[i] )
          // }
          // if(non === cnt) {
          //   alert('no args')
          //   return true
          // }

          if (!this._d && this.parent) {
            var p = this.parent;
            while (!this._d && p) {
              if (p._d) {
                // console.error('SET DATA')
                this._dSet(p._d, true);
              } else {
                p = p.parent;
              }
            }
          }
          var t = this,
            model = t.model,
            f = model.flags,

            // f = model ? model.flags : false be carefull with updates in values that have data

            path = t._d && t._d._path || [],
            name = (from || (from = (t._d && t._d._updateOrigin)) && !(from === t._d && (from = false))) && from.updatePath,
            fromPath = from && from._path,
            method = function(i, field) {

              var select, pass, fr, lfield;
              // if( field._flag[2].__t) {
              //multiple flags!
                // console.log('FLAG'.inverse, name, field._flag)
              // }

              if(!field._flag.data) {
                console.error('NO DATA FLAG', name, field._flag, val, obj, remove, added, oldval)
                return
              }
              field = field._flag.data[2];

               // console.log('DATA UPDATE'.magenta.inverse,
               //      'obj:', obj
               //    , 'val:', val
               //    , 'stamp:', stamp
               //    , 'from:', from
               //    , 'remove:', remove
               //    , 'added:', added
               //    , 'field:', field
               //  )
              // var test = (i==='text' && field === 'real.duration')
              // if(test) console.log(field,i)
              // if(test) pass = true

              if (i === 'collection' && t._colFilter) return
              //if not own colfilter --> handle yourself!;
              // if data has changed change colfilter adn send update
              //be carefull /w changes!; too crude

              if (field === true) {
                // console.log('PASS'.inverse,name)
                pass = true;
              } else if (field.pop) {
                // console.log(name,'???')

                // console.log('--->',field, field.pop)

                field = field.concat();

                for (var j = field.length - 1; j >= 0; j--) {
                  if (!lfield !== void 0) {
                    select = util.get(t._d, field[j]);
                    if (select !== void 0) {
                      lfield = true;
                      // break;
                    }
                  }
                  field[j] = field[j].split('.');
                }
              } else {

                // console.log('DO DO!'.inverse,name, t._d && t._d._updateOrigin)

                // console.log(name, path, select, obj, val, stamp, from, remove, added, oldval, instances)

                field = field.split('.')

                select = util.get(t._d, field)

                if(!select && t._d && t._d.from && field ) {
                  // console.log('NO SELECT'.red.inverse, t._d )
                  select = util.get(t._d.from, field)
                  // if(select) {
                  //   // console.log('FOUND SELECT'.green.inverse, select)
                  // }
                } 

                if(select && from && from.__t === 4) lfield = true //test dit of het alles slow maakt

                // if(test&&select) console.log(select._val)
              }

              if (!pass && from) {

                // console.log('testing....?', name, from, select, lfield)
                // if(test) console.log(name, select, lfield, from);

                fr = true;
                var fromFrom

                if ( from === select || ( fromFrom = from.from ) === select ) {
                  pass = true;
                } else {
                  if (t._d._filter && select && select._ancestor(from)) {
                    pass = true;
                    //field ook voor arrays!;
                  } else if (lfield) {

                    // console.log('got lfield!!!!')

                    for (var n = 0; n < field.length; n++) {
                      // console.log('compa222re')
                      if (name && _compare(name, field[n]) || field[n][0] === name[0] && util.get(val, field[n].concat().shift())) 
                      {
                        fr = false;
                        break;
                      } 
                      else if ((_compare(path.concat(field[n]), fromPath) || _compare(field[n], fromPath))) 
                      {
                        fr = false;
                        break;
                      } 
                      else {

// <<<<<<< HEAD
                        // console.log('HERE?', '\n\n\n', select.from, '?', select, 'val:', this._path, val, path, fr )
// =======
                        // console.log('HERE?', '\n\n\n', select, 'val:'
                        //   , val, 'field:', field, 'fn', field[n], 'n:', n, 'check field:', val && val[field[n]], 'ref:', val.from)
                        // console.log('coming trugh', select && from._val !== null && val, field[n]
                        //   , select && from._val !== null && val && ( val[field[n]] || val.__t === 4 && val.from[field[n]] ) )
// >>>>>>> c116e06969017fd9c1d8d85778e716bf91b7274c
                        //TODO: need to add more gaurding for val.$path check if this is cloud and ref

                        if(select && from._val !== null && val && (val[field[n]] || val.$path || val.__t === 4) && (select._ancestor(from) || select.from._ancestor( fromFrom )  ))  //
                        {
                          // console.log(val, field);
                          pass = true;
                          break;
                        }
                      }
                    }
                  } else {

                    // console.log( '---', select, val, field, from, 'fromPath:' , fromPath, field, field )

                    if(val===null) {
                      // if(DEBUG$) t._d.DEBUG$log('data/base ---> ERROR val is null  --->'+t._d._removed )
                    } else if(val === void 0) {
                      // console.log('\n\n\n undefined what to do now?'.red.inverse)
                      // pass = true
                      // pass = true
                    } else if (name && _compare(name, field) || field[0] === name && name[0] && util.get(val, field.concat().shift())) {
                      fr = false;
                    } else if (fromPath && path && (_compare(path.concat(field), fromPath) || _compare(field, fromPath))) {
                      fr = false;
                    } else if (select && (val[field[0]]) && select._ancestor(from)) {
                      // console.log(val, field);
                      pass = true
                    } else if( t.__checkKeys__ ) {
                      // console.log('lets checkj the keys!')
                      // console.log( field, name, val, path, select, val[field[0]], from, this )
                      for( var key$ in t.__checkKeys__ ) {
                        if( field === t.__checkKeys__[key$] || field[0] === t.__checkKeys__[key$] ) {
                          // console.log('maybe??!!@#!@', i, t.__checkKeys__[key$])
                          pass = true
                        }
                      }

                    }
                    // console.log(val, field[0], from);
                  }
                }
              }
              // pass = true;
              // console.log('PASS>>>>>>>>>?'.magenta.inverse, pass ? 'OK!'.green.inverse : 'NO!'.red.inverse  
              //   , 'val:'.blue, val
              //   , 'obj._path:'.blue, obj && obj._path
              //   , 'field:'.blue, field
              //   , 'fromPath:'.blue, fromPath
              //   , 'from:'.blue, from
              //   , 'select'.blue, select
              //   )

              // if(! pass && )

              // pass = true

              if (pass || (instances || remove || select !== void 0) && ( !fr || remove === 1)) {

                // console.log('updating!'.cyan.inverse, i, val, instances, remove, select, fr, from)
                // debugger
                //stamp meegeven????
                // console.log( 'FROM!!!!!'.green.inverse, from )
                // console.l
                t[i]._update(val, false, from, remove, added, oldval, !instances, t);
                return true;
              }
            };
          //----------------------------------------------------
            //add advanced models (like on website)
            //not tested and still pretty broken
           var parser = function() {
            if (this._d) {
              var t = this, a
              //if added or first run
              t.model.val //set _caller
              // if (model.field) console.log('????', this.field, model.field)

              if (model.field && model.field.val) { 

                if(t._ignoreFieldInSubscription && t._d instanceof vObject ) {
                  // console.log('IGNOREFIELD'.inverse, t._d)

                } else {
                
                // console.log('FIELD PARSING! LETS GET AGAIN!'.cyan.inverse, model.field.val, t._d, this.__checkKeys__ )
                a = util.get( t._d, model.field.val, true )
                                // console.log('LETS GET AGAIN!2'.cyan.inverse, a )
                              // }
                            }

                if(!a) {
                  // console.log('BADBADBAD'.red.inverse)
                  // a = util.get( t._d, model.field.val )
                } 
                else if( t._d && !t._d.cloud ) 
                {
                  // console.log('NOW lets set flag!'.cyan.inverse)
                  this._ignoreFieldInSubscription = true
                  // debugger
                } else if(t._d.cloud) {
                  this._ignoreFieldInSubscription = null
                }
              }

                // console.log( a ) 
              //make if not a --- do without self

              // if (model.field) {
                // // console.log( 'field getter!!'.red.inverse, model.field.val
                //  , 'field'.blue , this._d[model.field.val]
                //   ,  this._d._path &&  this._d._path.join(' , ') )
              // }


              // console.log('??????')

              if (model._val) a = model._val.call(t, a || t._d) || a


              if (a && t._d !== a) {

                              // console.log('????33332222??')

                model.parsing = true
                if(model.field) model.parsed = model.field.val




                // _dSet: function( val, dfrom, modelField ) { //field

                //deze moet ook blijven changen!
                // console.log('PARSE MODEL!!!!!'.green.inverse, this._dfrom, this.__checkKeys__ )
                //hier moet het gebeuren!!!!

                // if(this.)
                this._dSet(a, this._dfrom, true )
                //dit is parsing dan word er niet op gesubscribed
                model.parsing = false
              }
              // console.log('end')
            }
          }
          parser.call(t)
          if (instances) t.eachInstance(parser, 'model')
          //----------------------------------------------------

          //----------------------------------------------------
          if (f && (instances || t._d)) {
            for (var i in f) {
              if (!f[i].__t) {
                for (var j = 0, l = f[i].length; j < l; j++) {
                  if (method(i, f[i][j])) {
                    break;
                  }
                }
              } else {
                method(i, f[i]);
              }
            }
          }
          //----------------------------------------------------

         if(this.model.complete) this.model.complete._val.call(this,data)

        }
      },
      _dSet: function( val, dfrom, modelField ) { //field


        // if(val) {
        //   console.log('_Dset'.cyan.inverse, val._path, dfrom)
        // }
        // if(this.model._flag && this.model._flag.process && !this.__processing) {
        //   console.log('oo2')
        //   this.model._update()
        //   return
        // }

        if(this.model._flag && this.model._flag.defer  && !this.__processing) {
          this.__pFlag = [ val, dfrom ]
          return
        }

        //dfrom moet niet nog een subscribe doen! -- als het goed is is zn parent al subscribed

        // if (this._d && this._d.__t) this._d.removeListener(true, this)
        var reset

        if (this._d) {

          // if( modelField ) console.log('MODELFIELD'.yellow.inverse, modelField, '!!!!!!!!!!'.blue )

          if( this._d === val ) {
            // console.log('VALUE IS THE SAME ABORT _dSet'.red.inverse )
            return false
          }
          reset = true
          // console.log('IM RESETTING _dSet'.cyan.inverse, this._d , '------>'.blue , val )
       
        }

        // var bla
        //reset
          //fieldCorrected
          // console.log('IM RESETTING _dSet'.cyan.inverse )
        // }

        // removeMethod.call( this )  


          //this.__checkKeys__ &&
        // if(  this.model && this.model.field && this.model.field.val && this._d ) {
        //   console.log(this._d, val, this.model.field)
        //   //TODO: this is a tempfix! -- can also refire ofcourse
        //   if( this._d === val[ this.model.field.val ] ) 
        //   {

        //     // if(this._d)

        //       if (dfrom) this._dfrom = true
        //     return this._d
        //   }
        // }



        var excludes 

        excludes = removeMethod.call( this, val )  

        //removeMethod
        // console.log( '!@!@#!@#!@#!@#!@#!@#!@#!@#!@#', removeMethod  )

        // if(excludes) {
        //   console.log('EXCLUDES'.green.inverse, excludes)
        // }

//        console.log('SETTING DATA', val , !!dfrom, reset)
        this._d = val

     

        if (dfrom) {
          this._dfrom = true
          // console.log('DFROM'.yellow.inverse, dfrom)

          if(dfrom.__checkKeys__) {
            console.log(dfrom.__checkKeys__)
          }

        }


        // console.log('!!!!!!!!!!!!!!!!!!!!!!!!!!!')
        this._dListen( excludes )

      

        return val
      },
      _dListen: function( excludes ) {

          // console.log('HEEEEEE', this.model)


          // console.log('D LISTEN!'.inverse, excludes)

        // if(this.model._flag && this.model._flag.process && !this.__processing) {
        //   console.log('oo2')
        //   this.model._update()
        //   return
        // }

        //hier gaan we s fftjes werken met each

        // this._dfrom = true;
        var _this
        var dataUpdate


        if (this.model && this._d && this._d instanceof vObject) 
        { //this model maybe not nessecary?



          dataUpdate = true
          // console.log('----->'.cyan.inverse, this._d )

          //hier ff meegeven dat je vanuit field werkt incm met een each check
          //--remove field uit de equation
          var arr = [this._dUpdate, this ]

          if(this.model.field && this.model.field.val) {
            // console.log('FIELD',this.model.field.val)
            // arr.push(this.model.field.val)
          }


          this._d.addListener(arr)

          _this = this
          
          //hier filteren op cloudData --- ook werken vanuit remove!!!
            //never do for cloud data
          if( !this._d.cloud )
          {
            this._d.each(
              function( key ) { 
                if( !excludes || !util.checkArray( excludes, key ) )
                {
                  // dataUpdate=true
                  //dit gaat ngo wrong (this)
                  if( this.__t === 4 ) {
                   
                    this.addListener([ _this._dUpdate, _this, '$ndata', this ]) 

                    // if(!this._d.cloud) {

                    //   this.each()

                    // }

                  }
                  //  else if( !this.cloud ) {
                  //   var __this = this
                  //   this.each(function(key$) {
                  //     if( this.__t === 4 ) {
                  //       console.log('go go go!', key$)
                  //       this.addListener([ _this._dUpdate, _this, '$ndata', [ this , __this ]  ]) 
                  //     }
                  //   })
                  // }
                } 
               
                // console.log('SET CHECK KEYS'.inverse, key )
                // debugger
                _this.__checkKeys__ = true
              }
            )
          }
          //eventueel .val gebruiken voor Values *awesjume!
          //eventueel hier dingen adden aan model

        } 
        else if( this.model && this._d && typeof this._d === 'object' ) 
        {
          for( var key in this._d ) 
          {
            // console.log( '!??????????????????????'.red.inverse )
            if(!this.__checkKeys__ || this.__checkKeys__===true)
            {
              this.__checkKeys__ = [] //TODO: remove listeners here
            }
            if( this._d[key] instanceof vObject )
            {
              this.__checkKeys__.push( key ) 
              if( !excludes || !util.checkArray( excludes, key ) ) 
              {
                // dataUpdate = true
                // console.log('LETZ ADD IT NOW LISTENER LISTENER!!!!')
                this._d[key].addListener([ this._dUpdate, this, '$ndata', key ])
                // console.log(this.__checkKeys__)
              } else {

                // console.log('IM EXCLUDE'.red.inverse, key)
              }
              
            }
          }

          return true//dataUpdate

        }
      },
      updateData: function(instances) {

        if(this.model._flag && this.model._flag.defer && !this.__processing) {
          // console.log('oo2')
          // console.log('DEFERED DATA BE CAREFULL'.red.inverse )
          this.__pFlagU = [ instances ]
          this.model._update()
          return
        }
        // console.log('!DOIT updateData'.cyan.inverse)

        this._dUpdate(this._d, void 0, false, false, false, false, false, instances)
      }
    },
    extend = function(i) {
      base.extend({
        name: i,
        type: false,
        value: (extensions && extensions[i]) ? function() {
          methods[i].apply(this, arguments);
          extensions[i].apply(this, arguments);
        } : methods[i]
      });
    };
  for (var i in methods) {
    extend(i)
  }
  base.extend({
    name: 'model',
    set: function(val) {

      if(this.__pFlag || this.__pFlagU) {
        /*
        TODO: test defer better!!!
        this.__pFlag = [ val ]
        this.__pFlagU = [ true ]
        */
        this.__processing = true
        this.model.parsing = false
        if(this.__pFlag) {
          // console.log('P FLAG!!!!! base.data be carefull!!!!'.inverse.red)
          this._dSet.apply(this,this.__pFlag)
        }
        //subscribe helemaal fucked met field erbij
        if(this.__pFlagU) {
          this.updateData.apply(this,this.__pFlagU)
        }
        this.__pFlagU = null
        this.__pFlag = null
        this.__processing = null
      }

      if(val.field && val.field.val !== val.parsed) {

        // console.log( 'FIELD UPDATE!'.red.inverse, val.field.val )

        var a = val.parsed && val.parsed.split('.')
          , parent
        val.parsed = null
        if(this._d) {
          parent = this._d
          if( a ) 
          {
            for(var i = a.length-1; i >=0 ; i--) {
              parent = parent._parent
            }
            if(parent) {
              // console.log( 'FIELD --- PARENT BE CAREFULL!'.red.inverse )
              //parent?
              this._dSet( parent, this._dfrom, val )
              this.updateData(true)
            }
          } 
          else 
          {
            // console.log( 'FIELD BE CAREFULL!'.red.inverse, val.field.val )
            this.updateData(true)
          }
        }
        val.parsed = null
      }
    },
    remove: function() {
      // console.clear()
      // console.log('---------REMOVE!!!!!!!!!'.cyan.inverse, this.__checkKeys__ )

      //console.log('P FLAG!!!!! base.data be carefull!!!!'.inverse.red)

      removeMethod.call( this )
    }
    // parent: function(parent) {
    //   if( parent.data && (!parent.parent || parent.parent.data!==parent.data) ) {

    //     console.error('WTF?')

    //     this.data = parent.data
    //   }
    // }
  }, {
    name: 'data',
    type: false,
    set: function(val) {
        // console.log('?',val)
      if( this._d === val ) return

      // if(!this.model) this.model = {} //dit met het nooit setten van fmodel scheel op show al 3/9 subscriptions
      //nu nog shared subs maken -- 'shows' (ook meteen process) en dan word thet als het goed is nog een stuk minder
    
      // this.model = {} //pas op met deze
      // console.log('?2')

      if( this.model._flag && this.model._flag.defer ) {
        this.__pFlag = [ val ]
        this.__pFlagU = [ true ]
        // console.log('!@#!@#!@# OOOO'.red)
        return
      }

      // console.error('!!!!!MODEL -- dit moet zoveel mogelijk gereduced', this.model)

      this.model.parsing = false
      this._dSet(val) 
      this.updateData(true)
      // }

      //subscribe helemaal fucked met field erbij

    },
    get: function() {
      return this._d
    }
  })
})
},{"../base":"/Users/shawn/Work/vigour-native/node_modules/vigour-js/base/index.js","../object":"/Users/shawn/Work/vigour-native/node_modules/vigour-js/object/index.js","../util":"/Users/shawn/Work/vigour-native/node_modules/vigour-js/util/index.js","../value/flags/data":"/Users/shawn/Work/vigour-native/node_modules/vigour-js/value/flags/data.js","./":"/Users/shawn/Work/vigour-native/node_modules/vigour-js/data/index.js"}],"/Users/shawn/Work/vigour-native/node_modules/vigour-js/data/conditions.js":[function(require,module,exports){
/*!
 * @license Copyright (c) 2012-2014, Vigour. All rights reserved.
 * @author: Marcus Besjes, marcus@vigour.io
 */
var data = require('./'),
  cnt = 0,
  handleTest = module.exports = function(test, subsObj) {
    // console.error('handleTest!', test)
    if (test instanceof Object) {
      var keys = Object.keys(test);
      if (keys.length === 1) {
        var key = keys[0]
          , valcheck = handleField(key, test[key], subsObj)
          
        return subsObj._check = function(doc){
          // console.log('TESTING', test, doc && doc.raw)
          // console.log('checking for key', key)
          var val = getValue(doc)
          return valcheck(val)
        }
      } else {
        var list = [],
          key;
        for (var k = 0, l = keys.length; k < l; k++) {
          key = keys[k];
          list.push(handleField(key, test[key], subsObj));
        }
        return subsObj._check = makeAND(list);
      }
    } else {
      return subsObj._check = function(doc) {
        return getValue(doc) === test;
      }
    }
  }

function handleField(key, value, subsObj) {
  // console.warn('handleField [', key, '] value', value)
  var check;
  switch (key) {
    case '$not':
      if (value instanceof Object) {
        var follow = handleTest(value, subsObj);
        check = function(doc) {
          return follow(doc) === false;
        };
      } else {
        check = function(doc) {
          return doc !== value;
        };
      }
      break;
    case '$ne':
      check = function(doc) {
        return doc !== value;
      };
      break;
    case '$and':
      var list = makeList(value, subsObj);
      check = makeAND(list);
      break;
    case '$nand':
      var list = makeList(value, subsObj);
      check = function(doc) {
        for (var i = 0, l = list.length; i < l; i++) {
          if (list[i](doc) === false) return true;
        }
        return false;
      };
      break;
    case '$or':
      var list = makeList(value, subsObj);
      check = function(doc) {
        for (var i = 0, l = list.length; i < l; i++) {
          if (list[i](doc)) return true;
        }
        return false;
      };
      break;
    case '$nor':
      var list = makeList(value, subsObj);
      check = function(doc) {
        for (var i = 0, l = list.length; i < l; i++) {
          if (list[i](doc)) return false;
        }
        return true;
      };
      break;
    case '$every':
      subsObj.set('$', {});
      // subsObj.$ = {
      //   _up: subsObj
      // };
      var follow = handleTest(value, subsObj.$);
      check = function(doc) {
        if (doc && doc.__t < 3) {
          var result = true;
          doc.each(function() {
            if (!follow(this)) return !(result = false);
          });
          return result;
        } else {
          return false;
        }
      };
      break;
    case '$nevery':
      subsObj.set('$', {});
      // subsObj.$ = {
      //   _up: subsObj
      // };
      var follow = handleTest(value, subsObj.$);
      check = function(doc) {
        if (doc && doc.__t < 3) {
          var result = false;
          doc.each(function() {
            if (!follow(this)) return result = true;
          });
          return result;
        } else {
          return true;
        }
      };
      break;
    case '$':
    case '$some':
      subsObj.set('$', {});
      // subsObj.$ = {
      //   _up: subsObj
      // };
      if (value instanceof Object) {
        var follow = handleTest(value, subsObj.$);
        check = function(doc) {
          if (doc && doc.__t < 3) {
            var found;
            doc.each(function() {
              if (follow(this)) return found = true;
            });
            return found || false;
          }
          return false;
        };
      } else {
        check = function(doc) {
          if (doc && doc.__t < 3) {
            var found;
            doc.each(function() {
              if (this === value) return found = true;
            });
            return found || false;
          }
          return false;
        };
        subsObj.$._check = function(doc) {
          return doc === value;
        };
      }
      break;
    case '$nsome':
      subsObj.set('$', {});
      // subsObj.$ = {
      //   _up: subsObj
      // };
      var follow = handleTest(value, subsObj.$);
      check = function(doc) {
        if (doc && doc.__t < 3) {
          var result = true;
          doc.each(function() {
            if (follow(this)) return !(result = false);
          });
          return result;
        } else {
          return true;
        }
      };
      break;
    case '$lt':
      check = function(doc) {
        // console.log('burk lt', doc, value)
        return doc < value;
      };
      break;
    case '$lte':
      check = function(doc) {
        return doc <= value;
      };
      break;
    case '$gt':
      check = function(doc) {
        return doc > value;
      };
      break;
    case '$gte':
      check = function(doc) {
        return doc >= value;
      };
      break;
    case '$contains':
      var regex = new RegExp(value, 'i');
      check = function(doc) {
        return regex.test(doc);
      };
      break;
    case '$ncontains':
      var regex = new RegExp(value, 'i');
      check = function(doc) {
        return !regex.test(doc);
      };
      break;
    case '$containsall':
      break;
    case '$ncontainsall':
      break;
    case '$has':
      check = function(doc) {
        return doc && doc[value] !== void 0;
      };
      break;
    case '$nhas':
      check = function(doc) {
        return !doc || doc[value] === void 0;
      };
      break;
    case '$exists':
      check = function(doc) {
        return (doc !== void 0 && doc !== null) === value;
      };
      break;
    case '$in':
      check = function(doc) {
        for (var i = 0, l = value.length; i < l; i++) {
          if (doc === value[i]) return true;
        }
        return false;
      };
      break;
    case '$nin':
      check = function(doc) {
        for (var i = 0, l = value.length; i < l; i++) {
          if (doc === value[i]) return false;
        }
        return true;
      };
      break;
    case '$regex':
      check = function(doc) {
        return value.test(doc);
      }
      break;
    default:
      if (value instanceof Object) {
        var dsubsObj = subsObj[key];

        if (dsubsObj) {
          // console.log('already made that dsubsObj with key', key);
          // dsubsObj._up = subsObj
        } else {
          subsObj.set(key, {});
          dsubsObj = subsObj[key];
        }
        var follow = handleTest(value, dsubsObj);

        check = function(doc) {
          // console.log('TESTING: check OBJECT', doc && doc.raw || doc, 'for field', key)
          doc = getField(doc, key)

          // console.log('wups', doc && doc.raw || doc)
          return follow(doc);
        };
      } else {
        check = function(doc) {
          doc = getField(doc, key)
          
          // doc = getValue(doc)
          // console.log('TESTING: check VALUE', doc && doc.raw || doc, value, doc === value)
          return doc === value;
        };
        subsObj.set(key, {});
        subsObj[key]._check = check
        // subsObj[key] = {
        //   _up: subsObj,
        //   _check: function(doc) {
        //     return doc === value;
        //   }
        // };
      }

  }
  return subsObj ? subsObj._check = check : check;
}

function makeList(arr, subsObj) {
  var list = [];
  for (var i = 0, l = arr.length; i < l; i++) {
    list.push(handleTest(arr[i], subsObj));
  }
  return list;
}

function makeAND(list, subsObj) {
  return function(doc) {
    var val = getValue(doc);
    for (var i = 0, l = list.length; i < l; i++) {
      if (list[i](val) === false) return false;
    }
    return true;
  };
}

function getValue(thing){
  var val = thing && thing.from && thing.from.val
  return val !== void 0 ? val : thing
  
}
function getField(thing, field){
  // console.error('getField field', field, 'from', thing && thing.raw || thing)
  thing = getValue(thing)
  return thing ? getValue(thing[field]) : void 0
}
},{"./":"/Users/shawn/Work/vigour-native/node_modules/vigour-js/data/index.js"}],"/Users/shawn/Work/vigour-native/node_modules/vigour-js/data/index.js":[function(require,module,exports){
/*!
 * @license Copyright (c) 2012-2014, Vigour. All rights reserved.
 * @author: Jim de Beer, jim@vigour.io
 */
var V = require('../'),
  object = require('../object'),
  util = require('../util');

module.exports = exports = V.Data = object.new();
exports.prototype._blacklist.push('__sub','__block');
util.define(exports, '_hook', function(val, obj) {
  if (obj.subscription) {
    this.__sub = obj.subscription;
    delete obj.subscription;
  }
  if(obj.block) {
    this.__block = true
    delete obj.block
  }
});


},{"../":"/Users/shawn/Work/vigour-native/node_modules/vigour-js/index.js","../object":"/Users/shawn/Work/vigour-native/node_modules/vigour-js/object/index.js","../util":"/Users/shawn/Work/vigour-native/node_modules/vigour-js/util/index.js"}],"/Users/shawn/Work/vigour-native/node_modules/vigour-js/data/selection.js":[function(require,module,exports){
/*!
 * @license Copyright (c) 2012-2014, Vigour. All rights reserved.
 * @author: Marcus Besjes, marcus@vigour.io
 */

var conditions = require('./conditions')
  , utilHash = require('../util/hash')
  , VObject = require('../object')
  , util = require('../util')

/**
 * Selection
 * Class extention for selection / filtering functionality
 * @Class
 */

exports.SubsObj = VObject.new()
exports.SubsObj.prototype._blacklist.push( '_root'
                                         , '_check'
                                         , '_sort'
                                         , '_uid'
                                         )

exports.extend = util.extend(function(base){

  base.prototype._blacklist.push( '_filter'
                              , '_uid'
                              , '_hash'
                              , '_indexCache'
                              , '_subscnt'
                              )

  var _update = base.prototype._update
    , _hook = base.prototype._hook
    , _remove = base.prototype.remove

  util.define( base
    , 'remove', function() {
        var l
        if(this._filter && (l = this.length)){
          for(var i = 0; i < l; i++)
            delete this[i]
        }
        return _remove.apply(this, arguments)
      }
    , 'filter', {
        get: function() {
          return this._filter
        },
        set: function(val) {
          // console.log('new filter \n from --->', this._filter, '\n to ---->'
          //            , val
          //            )
          this._filter = val //moet ook werken als data nog geen selection is
          this._build(undefined, true)
          _update.call( this, void 0, this.stamp(), void 0, false
                      , false, void 0
                      )
        }
      }
    , '_hook', function(val, filter) {
        if (_hook) {
          _hook.call(this, val, filter)
        }
        if (!util.empty(filter) && val) {
          var selection = this
          selection._subscnt = 0
          selection._filter = filter

          selection._hash = utilHash(val._path + JSON.stringify(
            [ filter.condition
            , filter.range
            , filter.sort
            ])
          )
          //!only nessecary serverside!
          if (!selection._uid) selection._uid = selection._hash
        };
      }
    , '_build', function(val, noupdate) {
        var selection = this
        
        if (!val) val = selection._val
        if(!val) return
        if (selection.length) selection._clear() 

        var list = []
          , itemsHandler = this._itemsHandler
          , filter = selection._filter
          , subsObj = filter.subsObj || new exports.SubsObj({}, selection)
          , stamp = this.stamp()
          , sort, item

        if (val.__t === 4 && !val._filter) {
          val = val.from;
        }

        if (filter.sort) {
          if (typeof filter.sort === 'string') {
            filter.sort = {
              field: filter.sort
            }
          }
          sort = filter.sort
          if (!sort.fn) {
            if (!sort.type) sort.type = 'string'
            sort.fn = sortMakers[sort.type](sort)
          }
          subsObj.path(sort.field.split('.'), {}).set('_sort', true)
        }
        // console.log('building?!')
        if (filter.condition) {
          // console.log('found condition', filter.condition)
          var pcnt = 0
            , rcnt = 0
          var check = filter.check 
                 || ( filter.check = conditions( filter.condition
                                               , subsObj
                                               )
                    )
          filter.subsObj = subsObj
          val.each(function(f) {
            item = this
            if (itemsHandler) itemsHandler(item, subsObj, selection)
            if (check(item)) {
              pcnt++
              list.push(item)
            } else if (selection._has(item) !== void 0) {
              // console.log('-------- > removed from selection by condition:'
              //             , item.raw
              //             )
              unstoreIndex(item, selection)
              if(!noupdate){
                _update.call(selection, item, stamp, selection, item, false, null)
              }
              rcnt++
            } else { 
              rcnt++
            }
          })
          // console.log('ran condition: passed:', pcnt, 'rejects:', rcnt)
        } else {
          val.each(function() {
            if (itemsHandler) itemsHandler(this, subsObj, selection)
            list.push(this)
          })
        }

        filter.subsObj = subsObj

        if (sort && list.length > 1) {
          list.sort(filter.sort.fn)
        }

        var i, item

        var range = filter.range
        if (range) {
          if (!(range instanceof Array)) {
            range = filter.range = [0, filter.range]
          }
          if (list.length) {
            var newlist = list.splice(range[0], range[1])
            for (i = list.length; item = list[--i];) {
              if(selection._has(item) !== void 0){
                unstoreIndex(item, selection)
                // if(!noupdate){
                //   _update.call(selection, item, stamp, selection, item, false
                //               , null
                //               )
                // }
                
              }
            }
            list = newlist
          }
        }

        for (var i = list.length, item; item = list[--i];) {
          selection[i] = item
          var isnew = selection._has(item) === void 0
          storeIndex(item, selection, i)
          // if (isnew) {
          //   if(!noupdate){
          //     console.log('doing update wickeds')
          //     _update.call(selection, item, stamp, selection, false, item, null)  
          //   }
          // }
        }
        selection.length = list.length
      }
    , '_update', function(val, stamp, from, remove, added, oldval) {

        if (this._filter) {
           // if(window.here) console.log('hups _update on selection!')

          var selection = this
            , upath = selection.updatePath

          if (upath[0] !== void 0) {
            var shortpath = upath.length === 1
              , itemremove = shortpath && remove
              , item = itemremove ? selection._lfrom : selection.val[upath[0]]
              , relevant

            if (selection._val._filter) {
              if (selection._val._has(item) === void 0) {
                if (selection._has(item) !== void 0) {
                  selection._checkItem(item, false, val, stamp)
                }
                return
              }
            }
            var hint = itemremove ? false : (shortpath && added) ? void 0 : upath

            if (selection._checkItem(item, hint, val, stamp) === true) {
              _update.apply(selection, arguments)
            }
          } else {
            // console.log('hit on selection itself?!')
            if (!from) {
              // console.log('\n>>>>>> hit on selection itself (V.Data)')
              if (remove) {
                if (selection.length) selection._clear()              
              }else{
                selection._build()
              }
            }
            _update.apply(this, arguments)
          }
        } else {
           // if(window.here) console.log('hups _update on selection!',this)
           // console.log('SELECT', this, arguments, this._path)
          _update.apply(this, arguments)
        }
      }
    , '_has', function(item) {
        var indexCache = item._indexCache
          , uid = this._uid
          , ic

        if (indexCache && uid && (ic = indexCache[uid])) {
          return ic[0]
        }
      }
    , '_clear', function() {
        var self = this
        self.each(function(f) {
          self[f] = void 0
          delete self[f]
        })
        self.length = 0
      }
    , '_checkItem', function(item, hint, val, stamp) {
        if(!item) { return }
        // console.log('_checkItem!', item.raw, hint)
        var selection = this
          , from = item
          , filter = selection._filter
          , sort = filter.sort
          , range = filter.range
          , ranged = range && !(  range[0] === 0 
                               && range[1] >= selection._val.length 
                               || selection.length < range[1] - range[0]
                               )
          , removed = hint === false || item._removed
          , added, index, isin
          , result = isin = (index = selection._has(item)) !== void 0

        var check = filter.check
          , pass = removed 
                   ? false 
                   : (!ranged && hint === 1) 
                     ? isin 
                     : !check || check(item)

        // console.log('================ checkitem in', selection._path)             
        // console.log('isin', isin, 'pass', pass, 'result', result)
        // console.log('---------- checked item', pass)
        // console.log('removed?', removed)
        // console.log('ranged? (pass == already in)', (!ranged && hint === 1), isin)
        // console.log('ok time for checking', check)
        // console.log('conditions', filter.condition)
        // console.log('check?', check && check(item))
        // console.log('----------')
        
        if (isin !== pass) {
          if (isin) {
            result = 1
            unstoreIndex(item, selection)
            removed = item
            var mark
            while (mark = selection[++index]) {
              selection[index - 1] = mark
              storeIndex(mark, selection, index - 1)
            }

            var end = index - 1
            selection[end] = null
            delete selection[end]

            var replacement
            if (ranged) {
              if (sort) {
                selection._val.each(function() {
                  if (  selection._has(this) === void 0 
                     && (!selection[end] || sort.fn(this, selection[end]) < 0) 
                     && (!check || check(this))
                     ) {
                    replacement = selection[end] = this
                  }
                })
              } else {
                selection._val.each(function() {
                  if ( selection._has(this) === void 0 
                     && (!check || check(this))
                     ) {
                    return replacement = selection[end] = this
                  }
                })
              }
            }
            if (!replacement) {
              selection.length--
            } else {
              storeIndex(replacement, selection, index - 1)
              added = replacement
            }
          } else {
            var newindex
            if (sort) {
              var sortfn = sort.fn
              if (selection.length) {
                selection.each(function(f) {
                  if (sortfn(item, this) < 0) {
                    return newindex = f
                  }
                })
              }
              if (newindex !== void 0) {
                result = 1
                newindex = Number(newindex)
                storeIndex(item, selection, newindex)
                added = item
                if (ranged) {
                  removed = selection[selection.length - 1]
                  unstoreIndex(removed, selection)
                } else {
                  this.length++
                }
                var index = selection.length - 2
                while (index >= newindex) {
                  storeIndex(selection[index], selection, index + 1)
                  selection[index + 1] = selection[index--]
                }
                selection[newindex] = item
              } else if (!ranged) {
                result = 1
                newindex = selection.length++
                selection[newindex] = item
                storeIndex(item, selection, newindex)
                added = item
              }
            } else if (!ranged) {
              result = 1
              newindex = selection.length++
              selection[newindex] = item
              storeIndex(item, selection, newindex)
              added = item
            }
          }
        } else if (isin && sort) {
          // console.log('isin + sort! resort?')
          if (hint.length && sort.field) {
            if (~sort.field.indexOf('.')) {
              var sortpath = sort.field.split('.')
              if (!util.compareArrays(hint.slice(1), sortpath)) {
                return result
              }
            } else {
              if (hint[1] !== sort.field) return result
            }
          }

          var newindex
          selection.each(function(f) {
            if (f != index) {
              var s = sort.fn(item, this)
              if (s === -1) {
                if (f == index + 1) return true
                newindex = f < index ? f : f - 1
                return true
              } else if (f >= index + 1 && s === 0) {
                return true
              } else if (f > index) {
                newindex = f
              }
            }
          });
          // console.log('newindex', newindex)
          if (newindex !== void 0) {
            result = 1
            var tmp
            if (index > newindex) {
              while (index > newindex) {
                tmp = selection[index] = selection[--index]
                if (tmp) storeIndex(tmp, selection, index + 1)
              }
            } else {
              while (index < newindex) {
                tmp = selection[index] = selection[++index]
                if (tmp) storeIndex(tmp, selection, index - 1)
              }
            }
            selection[newindex] = item
          }

          var end = selection.length - 1

          if (  ranged 
             && (newindex == end || newindex === void 0 
             && index == end)
             ) {
            var replaced
            selection._val.each(function() {
              if (  selection._has(this) === void 0 
                 && sort.fn(this, item) === -1 
                 && (!check || check(this))
                 ) {
                if (!replaced) replaced = item
                selection[end] = item = this
              }
            })
            storeIndex(item, selection, end)
            if (replaced) {
              unstoreIndex(replaced, selection)
              removed = replaced
              added = item
              result = 1
            }
          } else if (newindex !== void 0) {
            storeIndex(item, selection, Number(newindex))
          }

        }
        if (result === 1) {
          // console.log('update from _checkItem!')
          selection.__update(val, stamp, from, removed, added)
        }
        return result
      }
    )

})

var storeIndex = exports.storeIndex = function(item, selection, index) {
  // console.log('storeIndex! item', item._name, '@', index)
  var indexCache = item._indexCache
    , ic
  if (indexCache) {
    ic = indexCache[selection._uid]
    if (ic) {
      ic[1] = ic[0]
      ic[0] = index
    } else {
      indexCache[selection._uid] = [index]
    }
  } else {
    item._indexCache = {}
    item._indexCache[selection._uid] = [index]
  }
}

var unstoreIndex = exports.unstoreIndex = function(item, selection) {
  var indexCache = item._indexCache
  if (indexCache) {
    var ic = indexCache[selection._uid]
    ic[1] = ic[0]
    ic[0] = void 0
  }
}

var sortMakers = {
  number: function(sort) {
    var field = sort.field
    return function(a, b) {
      var va = a[field] && a[field].val
        , vb = b[field] && b[field].val
      if (va === void 0 || vb === void 0) {
        return va === vb 
               ? 0 
               : va === void 0 
                 ? 1 
                 : -1
      }
      return sort.order 
             ? (va - vb) * -1 
             : va - vb
    }
  },
  string: function(sort) {
    var field = sort.field
    if (~field.indexOf('.')) {
      var path = field.split('.')
      return function(a, b) {
        a = getDotFieldVal(a, path)
        b = getDotFieldVal(b, path)
        if (a === void 0 || b === void 0) {
          return a === b 
                 ? 0 
                 : a === void 0 
                   ? 1 
                   : -1
        }
        var re = a > b 
                 ? 1 
                 : a === b 
                   ? 0 
                   : -1
        return sort.order ? re * -1 : re
      }
    } else {
      return function(a, b) {
        a = getFieldVal(a, field)
        b = getFieldVal(b, field)
        var weakA = a === void 0 || a === null
          , weakB = b === void 0 || b === null
        if (weakA || weakB) {
          return a === b ? 0 : weakA ? 1 : -1
        }
        var re = a > b 
                 ? 1 
                 : a === b 
                   ? 0 
                   : -1
        return sort.order ? re * -1 : re
      }
    }
  }
}

function getFieldVal(obj, field) {
  var v = obj.val
  return v && v[field] && v[field].val
}

function getDotFieldVal(obj, field) {
  var v = obj.path(field)
  return v && v.val
}

function putSort(path) {
  var obj = part = {}
  for (var i = 0, l = path.length; i < l; i++) {
    part = part[path[i]] = {
      _up: part
    }
  }
  part._sort = true
  return obj
}

},{"../object":"/Users/shawn/Work/vigour-native/node_modules/vigour-js/object/index.js","../util":"/Users/shawn/Work/vigour-native/node_modules/vigour-js/util/index.js","../util/hash":"/Users/shawn/Work/vigour-native/node_modules/vigour-js/util/hash.js","./conditions":"/Users/shawn/Work/vigour-native/node_modules/vigour-js/data/conditions.js"}],"/Users/shawn/Work/vigour-native/node_modules/vigour-js/index.js":[function(require,module,exports){
//V only used as a reference now...

},{}],"/Users/shawn/Work/vigour-native/node_modules/vigour-js/object/array.js":[function(require,module,exports){
/*!
 * @license Copyright (c) 2012-2014, Vigour. All rights reserved.
 * @author: Jim de Beer, jim@vigour.io
 */
var util = require('../util'),
  object = require('./');

util.define(object,
  /**
   * V.Object's equivalent to Array.push()
   * @method push
   * @param  {Arguments}  The item(s) to add to the array
   * @return {Number}     The new length of the array
   */
  'push', function() {
    if (this.__t === 1) {
      if (this.length === void 0) {
        this.length = 0;
      }
      for (var i = 0, l = arguments.length; i < l; i++) {
        this._push(arguments[i]);
      }
      return this.length;
    }
  },
  '_push', function(val, vobj, stamp, noupdate, from) {
    //ame, val, vobj, stamp, noupdate, from
    this.length++;
    this.set((this.length - 1), val, vobj, stamp, noupdate, from);
    return this[this.length - 1];
  },
  /**
   * V.Object's equivalent to Array.pop()
   * @method pop
   * @return {*}  The removed array item
   */
  'pop', function() {
    if (this.__t === 1) {
      var l = this.length
      if(l !== 0){
        t = this[l - 1];
        this.length--;
        t.remove();
      }
      // return t; //pretty weird since this object always has value null;
    }
  },
  /**
   * V.Object's equivalent to Array.splice()
   * @method splice
   * @param  {Number}    index   An integer that specifies at what position to add/remove items, Use negative values to specify the position from the end of the array
   * @param  {Number}    howmany The number of items to be removed. If set to 0, no items will be removed
   * @param  {Arguments}         The new item(s) to be added to the array
   * @return {Array}             A new array containing the removed items, if any
   */
  'splice', function(index, howmany) { //can become shorter;
    if (index > -1 && this.__t === 1) { //how many and -i are ignored
      for (var i = 0, l = this.length, shift; i < l; i++) {
        if (shift) {
          if (i === l - 1) {
            // this.length--;
            this[i] = null;
          } else {
            this[i] = this[i + 1];
            this[i]._name = i;
          }
        } else {
          if (i === index) {
            if (i === l - 1) {
              this.pop();
            } else {
              shift = true;
              this.length--;
              this[i].remove();
              this[i] = this[i + 1];
              this[i]._name = i;
            }
          }
        }
      }
    }
  },
  /**
   * Adds value to array if it is not contained in array, executes handler on encountering val in array
   * @method include
   * @param  {*}         val       Value to add
   * @param  {Function}  [handler] Function to execute on encountering val in array
   * @return {Boolean}             True/false
   */
  'include', function(val, handler, arr) {
    return util.include(this, val, handler, arr);
  },
  'concat', function(val) { 

    // if(!val) {
    //   return
    // }
    
    var arr = this
    var ll = arr.length;
    for (var i = 0, l = val.length; i < l; i++) {
      arr._push(val[i], false, false, true);
    }
    arr._update(val);
    return arr;
  },
  'moveItem', function(from, to) { var arr = this
    if(to === void 0) to = arr.length - 1
    if(from === to) return
    var mover = arr[from]
    if(!mover) return
    var step = from < to ? 1 : -1
    do {
      arr[from] = null
      arr.set(from, arr[from + step], true)
      from += step
    } while(from !== to)
    arr[to] = null
    arr.set(to, mover, true)
  }
)

},{"../util":"/Users/shawn/Work/vigour-native/node_modules/vigour-js/util/index.js","./":"/Users/shawn/Work/vigour-native/node_modules/vigour-js/object/index.js"}],"/Users/shawn/Work/vigour-native/node_modules/vigour-js/object/flags.js":[function(require,module,exports){
/*!
 * @license Copyright (c) 2012-2014, Vigour. All rights reserved.
 * @author: Jim de Beer, jim@vigour.io
 */
var util = require('../util')

/**
 * Flags are special properties where a function is called
 * different from operators since flags may have nothing to do with value calculation
 * extends default set from V.Object
 * @property
 */
/**
 * Adds new flags to V.Object
 * @method extend
 * @param  {Object}   object V.Object to extend flags to
 * @param  {Function} [set]  [description]
 * @return {[type]}          [description]
 */
exports.extend = util.extend(function(object, set) {
  
  //multiple flags 
  
  // abstract flags array away!
  // 
  // flags object --> field
  // 
  // check /w cases
  // check /w parent
  // flag4 is dynamic has stack as option
  
  var _proto = object.prototype
    , _convert = _proto.convert
    , _set = _proto._set
    , _remove = _proto._remove
    , _check = function(name) {
      var f;
      for (var i in object.flags.dynamic) {
        f = object.flags.dynamic[i](name)
        if(f) break
      }
      return f
    }
    , checkIfFlagOverwrite = function(val) {
      for(var i in val) {
        if(object.flags[i] || _check(i)) return true
      }
    }

  if (!set) set = _proto.set

  _proto._blacklist.push('_flag');
  util.define(object,
    /**
     * [description]
     * @method convert
     * @param  {[type]} val [description]
     * @return {[type]}     [description]
     */
    'convert', function(val) {

      //hier ook weer for
      var obj = _convert.call(this, val);

      // console.log('I SHOULD BE CONVERTING!', val, obj, this._flag)





      if (this._flag && (!val || !util.isObj(val) || val.val || checkIfFlagOverwrite(val) )) {

        // console.log('I SHOULD BE CONVERTING! step 2')

        //ff useVal gebruiken

        for(var i in this._flag) {
          var flag = this._flag[i]
          if (!flag[4] || !flag[4].stack) {

            // console.log('CONVERT NEEDS FIX'.red.bold.inverse)

            if (obj === flag[1]) {
              // console.log('2 CONVERT NEEDS FIX'.red.bold.inverse)
              obj = {};
            }
            if (obj.val === flag[1]) {
              // console.log('3 CONVERT NEEDS FIX'.red.bold.inverse)
              delete obj.val;
            }


            obj[flag[0]] = flag[2]
          }
          else {
            //still have to take care of this situation
            // console.error('trying convert a stack-dynamic flag', flag);
          }
        }

        // console.log('CONVERTED ---->',obj)

      }
      return obj;
    },
    /**
      @property __flags__
    */
    '__flags__', {},
    /**
     * [description]
     * @method remove
     * @param  {[type]} from   [description]
     * @param  {[type]} update [description]
     * @param  {[type]} stamp  [description]
     * @return {[type]}        [description]
     */
    '_remove', function(from, update, stamp) {

      if(this._flag) {
        for(var i in this._flag) {
          // console.log(i, this._flag)
          var flag = this._flag[i]
          //for 
          // console.log('_remove')
          if (flag) {
            //dit moet wel ff lukken
            if (object.flags[flag[0]]) {
              object.flags[flag[0]].remove && object.flags[flag[0]].remove.call(this, flag);
            } else {
              flag[4].remove.call(this, flag);
            }
          }
        }
        this._flag = null
      }

      _remove.call(this, from, update, stamp);
    },
    /**
     * [description]
     * @method _set
     * @param  {[type]} val      [description]
     * @param  {[type]} stamp    [description]
     * @param  {[type]} from     [description]
     * @param  {[type]} remove   [description]
     * @param  {[type]} noupdate [description]
     * @return {[type]}          [description]
     */
    '_set', function(val, stamp, from, remove, noupdate) {
      // console.log('make _set',this._name,val);
      _set.call(this, val, stamp, from, remove, noupdate)

      //flag moet dus ook meer een copied value worden

      // console.log('_set', this._flag, val)


      if(this._flag) {

        // console.log('overwrite>?----', this._flag, val)

        for(var i in this._flag) {
          var flag = this._flag[i]
          if (flag) {
            var setFl = object.flags[flag[0]] || flag[4]
            //what to do with reset?
            //change fixen bij cases?
            
            // console.log('2 overwrite>?----', flag, this._val, this._val !== flag[1])
            
            if (this._val !== flag[1] && setFl.useVal) {

              // nu ff hier ook nog!

              if (object.flags[flag[0]]) {

                // console.log('remove flag normal',flag, flag[4], i, this)

                object.flags[flag[0]].remove && object.flags[flag[0]].remove.call(this, flag)
                //if this empty
                // delete this._flag;
                delete this._flag[i]
                if(util.empty(this._flag)) {
                  delete this._flag
                }
                // this._update()
              } else if (!flag[5]) {
                // console.log('remove flag /w flag[4] and not flag[5]',flag, flag[4], i)
                flag[4].remove.call(this, flag);
                // if(this.)
                //delete this._flag;
                delete this._flag[i]
                if(util.empty(this._flag)) {
                  delete this._flag
                }
              }
            } else if (object.flags[flag[0]] && object.flags[flag[0]].reset && flag[3] !== this) {
              // console.error('RESETTING -- ingnore /w a clear!',flag[0]) 
              object.flags[flag[0]].set.call(this, flag[2], stamp, true, this._name)
            }
          }
        }
      }

    },
    /**
     * [description]
     * @method set
     * @param  {[type]} name     [description]
     * @param  {[type]} val      [description]
     * @param  {[type]} vobj     [description]
     * @param  {[type]} stamp    [description]
     * @param  {[type]} noupdate [description]
     * @return {[type]}          [description]
     */
    'set', function(name, val, vobj, stamp, noupdate) {
      var fl = object.flags[name] || _check(name)
        , r
        , same

        // console.log(name, val, vobj)

      if (fl) {

        // console.log('set>?----', name, val, this._flag)
       
      if(val===false) {
          //stack -- alle flags name providen!
          var i = fl.stack||name 
            , flag = this._flag && this._flag[i]
          if(flag && fl.remove) {
            var d = fl.remove.call(this, flag, name)
            // console.log('REMOVE FLAG FROM FALSE'.inverse, fl, name, val, stamp, this)
            if(!d) {
              delete this._flag[i]
              if(util.empty(this._flag)) {
                // console.log('flag is empty, delete')
                delete this._flag
              }
            }
          } 
          r = true
          // if(this._flag)
      } else {
       if(this._flag) {
          //check if need to remove! -- only in case
          for(var i in this._flag) {
            var flag = this._flag[i]
            if (flag && fl.remove) {

              if(!fl.stack && name === flag[0]) {
                // console.log('--->',flag[0])
                if(val!==flag[2]) {
                  // console.log('remove flag! ---> overwrite bymyself --->', flag[0],  setFl, 'by:' ,name, fl, val, flag[2])
                  fl.remove.call(this, flag);
                } else {
                  same = true
                }

              } else if (!fl.stack || fl.stack !== flag[0]) {

                //this._flag

                //if val:true 
                //go check if you need to remove mofos

                var setFl = object.flags[flag[0]] || flag[4]

                if(setFl.useVal && fl.useVal) {

                  // console.log('remove flag! -- clearly has some useVal', flag[0],  setFl, 'by:' ,name, fl)

                  setFl.remove.call(this, flag);
                  delete this._flag[i]
                  if(util.empty(this._flag)) {
                    // console.log('flag is empty, delete')
                    delete this._flag
                  }
                }


                // console.log('remove flag!', flag, flag[0], flag[4],  object.flags[flag[0]]  , fl, name) //check if it needs to be removed
                // var fl 
                
                //fl = object.flags[name] || _check(name)
                //
                //hier iets mee doen weer zoeken naar flag set


                //do the special check if value is tight to flag check (for both! fl.value)

                // fl.remove.call(this, flag);
              }
            }
          }
        }

      if(!same) {
          // console.log('SET FLAG'.inverse, name, val, stamp, this)
          fl.set.call(this, val, stamp, false, name);
          r = true //niet altijd waar ofcourse!
          // console.log('---------')
        } else {
          // console.log('FLAG IS SAME'.red.inverse, name, val, stamp, this)
        }
      }
        this[name] && this[name].remove(false, false, false, false, false, true);
      } else {
        r = set.call(this, name, val, vobj, stamp, noupdate);
      }
      return r;
    });
  object.flags = _proto.__flags__;
  util.define(object.flags, 'dynamic', {});
})
},{"../util":"/Users/shawn/Work/vigour-native/node_modules/vigour-js/util/index.js"}],"/Users/shawn/Work/vigour-native/node_modules/vigour-js/object/index.js":[function(require,module,exports){
/*!
 * @license Copyright (c) 2012-2014, Vigour. All rights reserved.
 * @author: Jim de Beer, jim@vigour.io
 */
var util = require('../util')
  , vigour = require('../')
  , inject = require('../util/inject')
/**
 * V.Objects are used instead of normal objects in vigour listeners are automatically added and removed
 * type: __t : 1 = array , 2 = object , 3 = has field (can never be an array) , 4 = field ref to other V.Object
 * note you can make an object out of a field or field ref the type will be 3 or 4 though!
 * @constructor
 * @param  {*}      [val]    Value
 * @param  {Object} [parent] Parentobject
 */
var object = module.exports = exports = vigour.Object = function(val, hook, parent) {
  if (parent) this._parent = parent
  if (hook && this._hook) this._hook(val, hook)
  if (val !== void 0) this.val = val
}
object.inject = inject
/**
 * Used to set .val
 * @method _set
 * @param  {*}              val                  [description]
 * @param  {Number}         [stamp = new stamp]  [description]
 * @param  {Object|Boolean} [from]               [description]
 * @param  {Boolean}        [noupdate]           When true, no updates
 * @param  {Boolean}        [add]                When true, this is an add
 */
var _set = function(val, stamp, from, noupdate, add) {

  if(val===null) {
    if (!stamp) stamp = this.stamp()
    this.remove(false, false, false, from, stamp, noupdate)
  }

  if (!this.__t || this.__t < 3 || ( val !== this._val || this._ignoreValue ) ) {

    // console.error(this)
    if(!this.stamp) {
      //moet allemaal event emitters worden (on('error'))
      //this._update('error') en anders V.debug.error._update( 'object' )
      console.error( 'ERROR in vigour-js/object,  OBJECT no .stamp', this )
      return
    }

    if (!stamp) stamp = this.stamp()

    var oldval = this._val
      , nestedval
      , noset
      , isSet
      , isArray
      , valIsSet

    if (this._changevobj 
      && ((this.__t < 4 && val instanceof object) 
      || this.__t === 4 && ((!this._mixed||this._mixed===4) || val instanceof Array 
        || (val instanceof Object 
          && (val instanceof object || val.val))))) { //try to make this shorter
         this._changevobj(val, stamp)
         if(this._mixed===4) this._val = null
    }

    if (vigour.Base && (val instanceof vigour.Base)) {
      this.remove(true, true, false, false, stamp)
      this.__t = 5
      this._val = val
    } else if (val instanceof object) {
      if ((this.__t < 3 && !this._mixed) || this.__t === 1) {
        this.remove(true, true, false, void 0, stamp) //check if 2nd param true is absolutely nessecary (else it will be removed)
      }
      this._val = val
      this.__t = 4
      if (this._setvobj) this._setvobj(val)
    } else {

      if (val instanceof Object && typeof val !== 'function') {
        if (val instanceof Array) {
          this._val = void 0
          this.__t = 1
          this.length = val.length
          noset = this.remove(true, true, val, false, stamp)
          for (var i = 0, l = this.length; i < l; i++) {
            if (!this.set(i, val[i], false, stamp, noupdate, true) && noset !== false) {
              noset = true
            } else {
              noset = false
            }
          }
        } else {

          //normal object

          if (val.clear) {
            noset = this.remove(true, true, false, false, stamp)
            delete val.clear
          } else {

            if (this.__t === 1) {
              if (this._mixed !== 1 && this._mixed!==4) {
                this.remove(true, true, false, false, stamp) //ommiting stamp can be a problem
              } else {
                isArray = true
              }
            } else if (!this._merge && (!this._mixed || this.__t === 2)) {
              noset = this.remove(true, true, val, false, stamp)
            }
          }
          if (val.val && util.isObj(val.val)) {
            valIsSet = true
            _set.call(this, new this._class(val.val, false, this), stamp, from, true)
            this._val._contained = true
          } else if (!this._mixed) {
            this._val = void 0 //this messes up property updates!! (youri)
          }

          if (!isArray) this.__t = 2

          for (var j in val) {
            if (!util.checkArray(this._blacklist, j)) {
              if (j === 'val') {
                if(!valIsSet) isSet = _set.call(this, val.val, stamp, from, true)
                nestedval = true;
              } else {
                //do not always ignore updates at this point
                if (!this.set(j, val[j], false, stamp, noupdate, true) && noset !== false) {
                  noset = true
                } else {
                  noset = false //this is the place where set is passed
                }
              }
            }
          }
        }

      } else {
        if ((this.__t < 3 && !this._mixed) || this.__t === 1) {
          this.remove(true, true, false, false, stamp)
          if (this.__t === 1) delete this.length
        }
        if (val === this._val && !this._ignoreValue ) {
          //maybe use stamp for ignoreValue as well?
          if (noset !== false) {
            this.__t = 3
            return false
          }
        } else {
          this._val = val
          this.__t = 3
        }
      }
    }
    if (nestedval) {

      if (this._set && (isSet !== false || noset === false)) {
        this._set(val, stamp, from, false, noupdate, add, oldval)
      }
    } else if (this._set) {
      if (!noset) {
        this._set(val, stamp, from, false, noupdate, add, oldval)
      } else {
        return false;
      }
    }
  } else {
    return false;
  }

},
/**
 * stamp
 * paint the set origin
 * @method
 */
_stamp = 0,
_params = function(params, list) {
  for (var i = list.length - 1, p; i >= 0; i--) {
    if (params && params[list[i]]!==void 0) {
      p = '_' + list[i]
      util.define(this, p, params[list[i]])
    }
  }
}
/**
* Generates unique stamp
* @method stamp
* @return {Number} Returns stamp
*/
exports.stamp = function() {
//if stamp > x reset ?
return _stamp++
}

exports.set = _set

// objectUtils.extend(exports);  
/**
 * Creates a new constructor based on a V.Object
 * Params can be passed
 * Mixed creates mixed types for the new class i.e having a string and properties
 * @method new
 * @param  {Object} params Parametersobject
 * @return {Object}        Returns V.Object
 */


object.new = function(params, constructor) {
  var vObj = function(val, hook, parent) {
      if (parent) this._parent = parent
      if (constructor) constructor.apply(this,arguments)  
      if (hook && this._hook) this._hook(val, hook)
      if (this._onConstruct) this._onConstruct(val, hook)
      if (val !== void 0) this.val = val
      // console.log(constructor)
    },
    proto = vObj.prototype = new this()
  vObj.new = object.new
  vObj.inject = inject //not handeled well yet
  util.define(vObj, '_blacklist', proto._blacklist.concat())
  _params.call(vObj, params, ['mixed', 'merge'])
  util.define(vObj, '_class', vObj)
  return vObj
}

util.define(object,
/**
 * Items in the blacklist skipped in each function
 * @method _blacklist
 */
'_blacklist', ['_', '__', '__t', '_val', 'length', '_name', '_parent', '_contained', '_removed','extensions', '__cachedPath', '_ignoreValue', '_indexCache'],
/**
 * Replaces default constructor property ,necessary for classes made with V.Object.new
 * @constructor _class
 */
'_class', object,
/**
 * Stamp is a method of VObject so that it can be extended in subclasses
 * @return {*} a unique identifier for a mutation
 */
'stamp', object.stamp,
/**
 * Used to get .val which returns field values i.e. a string
 * @method _get
 * @return {*} Returns value
 */
'_get', function() {
  var self = this
    , type = self.__t
    , val

  if (type < 3) {
    return self
  } else {
    val = self._val
    return (type !== 4) ? val : val && val._get()
  }
},
/**
 * Used to get .val which returns field values i.e. a string
 * Set creates instances of the _class for nested properties
 * @property
 */
'val', {
  set: _set,
  get: function() {
    return this._get()
  }
},
/**
 * Add a property to a object
 * @method set
 * @param  {String}  name                [description]
 * @param  {*}       val                 [description]
 * @param  {Boolean} [vobj]              [description]
 * @param  {Number}  [stamp = new stamp] [description]
 * @param  {Boolean} [noupdate]          [description]
 * @return {Boolean}                     [description]
 */
'set', function( name, val, vobj, stamp, noupdate, from ) {

  //function( name, val, vobj, stamp, noupdate, from ) 

  // console.log(name, stamp)

  from = from && this
  if (!vobj && (this[name] instanceof object)) {
    if (_set.call(this[name], val, stamp, from, noupdate) === false && stamp) {
      return false
    }
  } else {
    if (vobj) {
      if(this[name]) this[name].remove()
      this[name] = val
      this[name]._name = name
      this[name]._parent = this
      if(!noupdate) val._update(val, stamp || this.stamp(), from, void 0, true)
    } else {
      this[name] = new this._class(void 0, false, this)
      this[name]._name = name
      _set.call(this[name], val, stamp, from, noupdate, true)
    }
    if (this.__t === 1 && this._setArrayItem) {
      this._setArrayItem( this[name], val )
    }
  }
  return true
},
/**
 * Removes a V.Object including all nested fields and values
 * @method remove
 * @param  {Boolean}        [nested]             When true remove nested objects
 * @param  {Boolean}        [bl]                 When true doesn't remove blacklisted items
 * @param  {Boolean}        [not]                [description]
 * @param  {Boolean|Object} [from]               [description]
 * @param  {Number}         [stamp = new stamp]  [description]
 * @param  {Boolean}        [noupdate]           [description]
 * @return {Boolean}                             [description]
 */
 //    this.remove(false, false, false, from, stamp, noupdate)

'remove', function(nested, bl, not, from, stamp, noupdate) { //no update first > (extended in selection.js)
  if (!nested) this._removed = true
  var r, i, oldval
  if (!stamp) stamp = this.stamp()
  // console.log('START',stamp,this._name);
  if (!nested) {
    if (this._parent) {
      this._parent[this._name] = null
      delete this._parent[this._name]
    }
    if (this._val !== void 0) {
      if (this._val instanceof object && this._val._contained) {
        this._val.remove(false, false, false, from || this, stamp, noupdate)
      }
      oldval = this._val
      this._val = null
    }
  }
  for (i in this) {
    if ((!not || !not[i]) && !util.checkArray(this._blacklist, i)) {
      if (this[i] instanceof object) {
        r = false
        // console.log('DELETE',stamp,i,this[i]);
        this[i].remove(false, false, false, from || this, stamp, noupdate)
      }
      this[i] = null
      delete this[i] //delete is pretty nasty for performance
    }
  }
  if (!nested) {
    if (this._remove) {
      //r
      this._remove(from, noupdate ? false : from /*||r*/ , stamp, oldval);
      if (!bl) {
        for (var j in this) {
          if (this[j] !== void 0) {
            if (j !== '_parent' && this[j] instanceof object && this[j]._contained) {
              this[j].remove()
            }
            this[j] = null
            delete this[j]
          }
        }
      }
    }
    this._removed = true
  }
  return r
})


//----this has to be initialized after defining the blacklist property;
exports.listen = require('./listen')
require('./array')
require('./util')
},{"../":"/Users/shawn/Work/vigour-native/node_modules/vigour-js/index.js","../util":"/Users/shawn/Work/vigour-native/node_modules/vigour-js/util/index.js","../util/inject":"/Users/shawn/Work/vigour-native/node_modules/vigour-js/util/inject.js","./array":"/Users/shawn/Work/vigour-native/node_modules/vigour-js/object/array.js","./listen":"/Users/shawn/Work/vigour-native/node_modules/vigour-js/object/listen.js","./util":"/Users/shawn/Work/vigour-native/node_modules/vigour-js/object/util.js"}],"/Users/shawn/Work/vigour-native/node_modules/vigour-js/object/listen.js":[function(require,module,exports){
var util = require('../util')
  , vObject = require('./')
  , V = require('../')


function _addListener( obj, fn, mark, original ) {
  //val, mark, skipcheck, ignoreval, orginal
  if( mark ) 
  {
    // console.log('hey got orginal!', original)
    obj.addListener([ fn, mark ], true, false, false, original  )
  } 
  else 
  {
        // console.log('hey got orginal!', original)

    obj.addListener( fn, false, false, false, original )
  }
}

/*
  _update calls listeners on a given Object (listeners include linking fields in other V.Objects)
  V.Object._update can be modified to change update behavior:
    - standard: update Object and it's parents / ancestors recursively.
    - parentOnly: update Object and only its direct parent.
    - just _update: update only the Object.
*/
var _update = exports._update = function(val, stamp, from, remove, added, oldval, test) {

  // if(window.here) console.log('UPDATE!',this._path)

  var _l = this._listeners
    , i
    , listener

  if (_l) {
    for (i = _l.length; listener = _l[--i];) { //order is irrelevant
      if (listener instanceof vObject) {

        // console.log('update?????', listener._path, this._path, from)

        if (from) listener._lfrom = from
        listener._update(val, stamp, false, remove, added, oldval)
        if (listener) listener._lfrom = null
      } else if (listener[0]) {
        if(!test || !test(listener)) {
          if (listener.length > 2) {
            for (var l = listener.length - 2
              , l2 = arguments.length
              , a = [], j = -1
              , la = l + l2
              ; j < la
              ; a[++j] = j < l
                ? listener[j + 2]
                : j === l ? this : arguments[j - l - 1]
              );

            listener[0].apply(listener[1], a)
          } else {
            listener[0].call(listener[1], this, val, stamp, from, remove, added, oldval)
          }
        }
      } else {
        listener.call(this, val, stamp, from, remove, added, oldval)
      }
    }
  }
}


// util.define(vObject, 
//   '_nodePath_', function() {
//     if(this._caller) {

//       var arr = []
//       var p = this._caller

//       while(p) {
//         arr.push( p._name || p._node && p._node.className )
//         p = p._node && p.parent
//       }
//       arr.reverse()
//       return arr


//     }
//   }

// )


vObject.prototype._blacklist.push('_listeners', '_listens', '_lfrom', '_listenMap');

util.define(vObject,
  /**
   * _set
   * is called when a value is set
   * @method
   */
  '_set', function(val, stamp, from, remove, noupdate, added, oldval) {
    if (!noupdate) {
      // console.log(this._path, val)
      this._update(val, stamp, from, remove, added, oldval);
    }
  },
  /**
   * __update
   * calls listeners attached to the Object
   * types -- function or V.Object
   * @method
   */
  '__update', _update,
  /**
   * _update
   * escalates an update up it's structure and calls __update to call listeners
   * types -- function or V.Object
   * @method
   */
  '_update', function(val, stamp, from, remove, added, oldval, test) { //here you can see if its an update from another object (from)
    // console.log('V.Object OG _update', val, stamp, from, remove, added, oldval)
    var curr = this,
    s = true

    while (curr) {
      // var p = curr._path
      // _update ["clients", "V_2pxcewv3g4k"] 
      // console.log('_update', p, val, from || ((!s && this) ? this : void 0, this) )

      //TODO 10 double check this
      curr.__update(val, stamp, from || (s!==true) ? this : false , remove, added, oldval, test)
      curr = from ? false : curr._parent
      s = false
      if (remove) remove = 1
    }
  },
  /**
   * _remove
   * called on remove
   * @method
   */
  '_remove', function(from, update, stamp, oldval) {
    if (update !== false) {
      this._update(null, stamp, from, true, false, oldval);
    }
    this.removeListener();
    var _l = this._listens,
      i, listener;
    if (_l) {
      //optimize later
      //this,this is weird to always use this...
      for (i = _l.length - 1; i >= 0; _l[i--].removeListener(this, void 0, false, true));
    }
  },
  /**
   * _setvobj
   * if a value is set to a V.Object
   * @method
   */
  '_setvobj', function(val) {
    val.addListener(this);
  },
  /**
   * _changevobj
   * if a value is changed from a V.Object
   * @method
   */
  '_changevobj', function(val) {
    if (this.__t === 4) {
      var _l = this._listens,
        _val = this._val,
        i;
      if (_l) {
        for (i = _l.length; i >= 0; _l[--i] && _l[i].removeListener(this, this));
      }
      if (_val instanceof vObject && _val._contained) {
        _val.remove();
      }
    }
  },
  /**
   * addListener
   * adds a listener to an object can be a function or V.Object
   * @method
   */
  'addListener', function( val, mark, skipcheck, ignoreval, original ) {
    var _l = this._listeners || (this._listeners = []),
      target, g;

    if(original) {
      // console.log('ORGINAL!', original)
      if(!this._listenMap) {
        this._listenMap = []
      }
    }

    //more speed voor checkarray
    if (mark) {
      g = util.checkArray(_l, val[1], 1);
      if (g === false
        || !ignoreval && util.checkArray(_l, val[0], 0) === false
        || (mark !== true && mark.call(this, _l[g], _l, g, val) === true)) {
        
        //TODO: fix this ultra dirty stuff
        if( original && val !== orginal ) {
          this._listenMap.push([ orginal, val ])
        }

        _l.push(val);
      } else  {
         return _l[g];
      }
    } else if (!val.__t || !util.checkArray(_l, val)) {

      if( original && val !== original ) {
        this._listenMap.push([ original, val ])
      }

      _l.push(val);
    }
    if (mark || val instanceof vObject) {
      target = mark ? val[1] : val;
      if (target instanceof vObject) {
        _li = target._listens || (target._listens = []);
        if (skipcheck || !util.checkArray(_li, this)) {

          if( original && val !== original ) {
            this._listenMap.push([ original, val ])
          }

          _li.push(this);
        }
      }
    }
  },
   'once', function( val, method, mark ) {

    //val, mark, skipcheck, ignoreval, orginal

    //TODO:unify /w on
    var mval

    var listen = function() {
      mval.apply( this, arguments )
      //original perhaps????
      this.removeListener( mval, mark )
    }

    if( method ) {
      mval = method
      this.on( val, listen, false, mval ) //deze fn moet wel geremoved worden gebeurd nu niet!
    } else {
      mval = val
      this.on( listen, false, false, mval )
    }

    return this

  },
  'on', function( val, method, mark, original ) {
      /**
        * val can be a condition or a comparison or a method
      **/
      if( V.Base && method instanceof V.Base ) 
      {
        mark = method //make exception for values!
        method = null
      }

      if(!original) {
        original = method
      } else {
        // console.log('set original!', original, method )
      }

      if( !method ) 
      {
        _addListener( this, val, mark, original )
      }
      else 
      {
        if( util.isObj( val ) )
        {
          console.warn('this will become a condition later on for now its not supported!, conditions will be used eveyrwhere')
          //Has to become a condition
        }
        else if( typeof val === 'function' )
        {
          _addListener( this, function( nval ) {
            if( val.apply( this, arguments ) ) //more checks
            {
              method.apply( this, arguments )
            }
          }, mark, original )
        }
        else 
        {

          if( util.isObj( method ) )
          {

            mark = val

            console.warn('untested -- add as mark')
            _addListener( this, function( nval, stamp, from, remove, added, oldval ) {
              if( remove ) //more checks
              {
                method.apply( this, arguments )
              }
            }, mark, original )


          }
          else if( val === 'remove' )
          {
            //val, stamp, false, remove, added, oldval
            _addListener( this, function( nval, stamp, from, remove, added, oldval ) {
              if( remove ) //more checks
              {
                method.apply( this, arguments )
              }
            }, mark, original )
          }
          else if( val === 'added' )
          {
            _addListener( this, function( nval, stamp, from, remove, added, oldval ) {
              // console.log( added ) //werkt niet!;
              if( added ) //more checks
              {
                method.apply( this, arguments )
              }
            }, mark, original )
          }
          else if( val === 'self' )
          {
            _addListener( this, function( nval, stamp, from, remove, added, oldval ) {
              // console.log( added ) //werkt niet!;

              //TODO: put on in a different file
              // console.log('SHOULD DO SELF!', arguments, from ) //zo wrong!

              if( this._val === nval ) //more checks
              {
                method.apply( this, arguments )
              }
            }, mark, original )
          }
          else
          {
            _addListener( this, function( nval ) {
              if( nval === val || this.val === val || this._val === val ) //more checks
              {
                method.apply( this, arguments )
              }
            }, mark, original )
          }
        }
      }
      return this
    },

  /**
   * removeListener
   * if no val removes all listeners
   * mark checks in array on position 1 for uniqueness
   * remove is used in combination with mark
   * @method
   */
  'removeListener', function(val, mark, remove, nobreak) {
    // console.log('removeListener!', this._path, this._listeners && this._listeners.length
    //   , '\nmark:\n', mark && mark.raw
    //   , '\nval:\n', val && val.name
    //   , '\nval:\n', val
    // )
    var _l = this._listeners,
      i;
    if (_l) {
      for (i = _l.length - 1; i >= 0; i--) {
        //maybe checking mark all the time is too slow?
        var listener = _l[i]
        if (
          (!mark && !val)
          || (val && listener === val) //false voor mark
          || (mark!==false && ((listener instanceof Array) && ((mark && listener[1] === mark && (!val||listener[0]===val)) || val && listener[1] === val))
            && (!remove
              || (remove === true  //dit moet later weg is dan alleen een functie is nu overbodig (check boven)
                ? listener[0] === val
                : remove.call(this, listener, mark))))
        ) {
          // console.log('mark._listens?', !!(mark && mark._listens)
          //     , '\nis vObject?', listener instanceof vObject
          //     , '\nis marked?', listener instanceof Array
          //   )
          var focus = mark
            ? mark
            : listener instanceof vObject
              ? listener
              : listener instanceof Array
                ? listener[1]
                : false
          var listens = focus && focus._listens
          if(listens){
            for(var j = listens.length-1 ; j >= 0 ; j--){
              if(listens[j] === this){
                listens.splice(j, 1)
                if(listens.length === 0)
                  focus._listens = null
                if(focus.__t === 4 && listener._val === this)
                  listener._val = void 0
                break
              }
            }
          }
          _l.splice(i, 1)
          if (_l.length === 0) this._listeners = null;
          if (val && !nobreak) break
        }
      }

      //TODO: this has to be refactored ASAP! do when new design phase for vobject+base is going down
      if( this._listenMap && val ) {
        // console.log('im here!', val)
        var piv
        for(var i = 0, _len = this._listenMap.length; i < _len; i++ ) {
          if( this._listenMap[i][0] === val ) {
             this.removeListener( this._listenMap[i][1] )
             piv = i
             break;
          }
        }
        if( piv !== void 0 ) {
          this._listenMap.splice(piv, 1)
          if(this._listenMap.length === 0) {
            this._listenMap = false
          }
        }
      }

    }
  });
},{"../":"/Users/shawn/Work/vigour-native/node_modules/vigour-js/index.js","../util":"/Users/shawn/Work/vigour-native/node_modules/vigour-js/util/index.js","./":"/Users/shawn/Work/vigour-native/node_modules/vigour-js/object/index.js"}],"/Users/shawn/Work/vigour-native/node_modules/vigour-js/object/util.js":[function(require,module,exports){
/*!
 * @license Copyright (c) 2012-2014, Vigour. All rights reserved.
 * @author: Jim de Beer, jim@vigour.io
 */
var util = require('../util'),
  VObject = require('./'),
  V = require('../')
  _c = util.checkArray

/**
 * Gets/sets VObject origin
 * In a chain of V.Objects e.g. x.val = y, y.val = z ---> x.from returns z;
 * @method from
 * @param  {Object} obj [description]
 * @return {Object}     [description]
 */
var _coreSet = VObject.set,
  _from = this.from = function(obj) {
    var val = obj,
      last;
    while (val instanceof VObject) {
      last = val;
      val = val._val;
    }
    return last !== obj ? last : false;
  },
  _lastLFrom = function(obj) {
    while (obj && obj.__t === 4) {
      if (obj._lfrom) {
        return obj._lfrom;
      } else {
        obj = obj._val;
      }
    }
  },
  /**
   * Returns path
   * @method _updatePath
   * @param  {Object}    till [description]
   * @return {Object}         Returns path
   */
  _updatePath = function(till, start) {
    var parent = this,
      lfrom,
      path = []; //reduce amount of new arrays
    while (parent && (parent._name !== void 0 || start)) {
      lfrom = parent._lfrom || _lastLFrom(parent)
      if (lfrom) {
        var a = _updatePath.call(lfrom),
          c = parent.from._name;
        util.add(a, path);
        path = a;
        if (c) {
          c = a.indexOf(c);
          a.splice(c, a.length - c);
        }
      }
      if (parent !== till) {
        path.push(parent._name);
        parent = parent._parent;
      } else {
        parent = false;
      }
    }
    // console.log('----->',path)
    return till ? path.reverse() : path;
  }

util.define(VObject,
  /**
   * Removes all linked containers, uses slice on arrays
   * Removes all _listeners
   * @method destroy
   */
  'destroy', function(nested, bl, not, from, stamp, noupdate) {
    if(!stamp)
      stamp = this.stamp()

    this._removed = true
    this.destroyReferences(nested, bl, not, from, stamp, noupdate)
    this.remove(nested, bl, not, from, stamp, noupdate)
  },
  'destroyReferences', function(nested, bl, not, from, stamp, noupdate) {
    if(!stamp)
      stamp = this.stamp()

    var _l = this._listeners
      , parent
      // , item
    if (_l) {
      for (var i = _l.length, ref; ref = _l[--i];) {
        // if(listener instanceof Array){
        //   if(listener)
        // }
        // ref =  instanceof Array ? _l[i][1] : _l[i];
        if (ref instanceof VObject) {
          parent = ref._parent;
          if (parent && parent.__t === 1) {
            parent.splice(ref._name, 1);
          } else {
            ref.remove(nested, bl, not, from, stamp, noupdate);
          }
        }
      }
    }
  },
  /**
   * Performs passed function on each item.
   * Skips items in the blacklist.
   * @method
   * @param  {Function}  fn   function to perform on each
   * @param  {Boolean}   deep If true, repeats eachmethod on nested fields
   * @param  {Arguments} arg  Arguments to pass to the function
   * @return {Boolean}        [description]
   */
  'each', function(fn, deep, arg) {
    //try to make this a lot shorter
    var i, item;
    if (arg !== void 0) {
      arg = util.arg(arguments, 2);
      for (i in this) {
        if (!_c(this._blacklist, i)) {
          item = this[i];
          if (fn.apply(item, arg)) {
            return true;
          }
          if (deep && (item.__t !== 4 || item._contained)) {
            if (item.each.apply(item, arg)) {
              return true;
            }
          }
        }
      }
    } else {
      for (i in this) {
        if (!_c(this._blacklist, i)) {
          item = this[i];
          if (fn.call(item, i)) {
            return true;
          }
          if (deep && (item.__t !== 4 || item._contained)) {
            if (item.each(fn, deep, arg)) {
              return true;
            }
          }
        }
      }
    }
  },
  /**
   * Returns the real path
   * @attribute _path
   */
    '_path', {
      get: function() {
        var parent = this
          , path = []

        while (parent && parent._name !== void 0) {
          path.push(parent._name);
          parent = parent._parent;
        }

        return path.reverse();
      }
    },
    '_cachedPath', {
      get: function() {
        return this.__cachedPath || (this.__cachedPath = this._path.join('.'))
      }
    },
  /**
   * Returns the update path
   * @attribute updatePath
   */
  'updatePath', {
    get: function() {
      var a = _updatePath.call(this, this, true),
        name = this._name;
      name !== void 0 && a.unshift(name);
      return a;
    }
  },
  /**
   * Returns the keys of an object
   * @attribute keys
   */
  'keys', {
    get: function() {
      var i, arr = [];
      for (i in this) {
        if (!_c(this._blacklist, i)) {
          arr.push(i);
        }
      }
      return arr;
    }
  },
  /**
   * Returns true if object is Ancestor
   * also return true when object is object to be compared to
   * @attribute keys
   */
  //t._d === from._parent || t._d === from
  '_ancestor', function(obj) {
    // console.log('ANCESTOR'.red.inverse, obj, this)
    var p = this
    while (p) {
      if (obj === p) return true
      p = p._parent
    }
  },
  /**
   * Get a field at first occurence in the parent chain
   * @method checkParent
   * @param  {String}  field [description]
   * @param  {Boolean} get   When true returns found instead of current
   * @return {Object}        [description]
   */
  'checkParent', util.checkParentFactory('_parent'),
  /**
   * Returns a normal object, and keeps links to V.Objects
   * @method
   * @param  {*}      [val] [description]
   * @return {Object}       [description]
   */
  'convert', function(val) {
    var obj = {}, l = 0
    if (!val || val.val) obj.val = this._val
    if (this.__t === 1) {
      obj = []
      for (var i = 0; i < this.length; i++) {
        l++
        obj[i] = this[i].convert()
      }
    } else {
      this.each(function(i) {
        if (!val || val[i]!==void 0) {
          l++
          obj[i] = this.convert()
        }
      })
    }
    if (val) {
      for (var i in val) {
        if (obj[i] === void 0) obj[i] = void 0
        l++
      }
    }
    if (!l && (!val || val.val)) obj = obj.val
    return obj
  },
  /**
   * Returns a normal object
   * @attribute raw
   */
  'raw', {
    get: function() {
      var self = this,
        type = self._filter ? 2 : self.__t,
        obj, i, l;
      if (type === 4) {
        return self._val && self._val.raw;
      } else if (type === 3) {
        return self.val; //when the type is mixed always uses val
      } else {
        if (type === 1) {
          obj = [];
          for (i = -1, l = self.length - 1; i < l; self[++i] && obj.push(self[i].raw));
        } else {
          obj = {};
          for (i in self) {
            if (!_c(self._blacklist, i) && self[i]) {
              obj[i] = self[i].raw;
            }
          }
        }
        return obj;
      }
    }
  },
  /**
   * Gets/sets object origin
   * In a chain of V.Objects e.g. x.val = y, y.val = z ---> x.from returns z;
   * @attribute from
   */
  'from', {
    set: function(val) {
      var found = _from(this)
      _coreSet.call(found || this, val)
    },
    get: function() {
      return _from(this) || this
    }
  },
  /**
   * Merge any object into another object
   * Shallow for a shallow merge
   * @method merge
   * @param  {Object}  obj      [description]
   * @param  {Boolean} shallow  [description]
   * @param  {Number}  stamp    [description]
   * @param  {Boolean} noupdate [description]
   * @return {Object}           [description]
   */
  'merge', function merge( obj, shallow, stamp, noupdate, block, sorted, deferUpdates ) {

    // console.log('MERGE---->', obj )

    var mergeArray = this._mergeArray
      , r
      , i
      , stop
      , rt
      , cobj
      , tobj
      , topLevel

    if(!deferUpdates) {
      // console.log('NO deferUpdates'.yellow.inverse)
      topLevel = true
      deferUpdates = []
    }
    //FIXME: make it better long names etc, code formatting

    if ( !stamp ) stamp = this.stamp()

    if ( this.__t === 1 ) {
      if (mergeArray) {
        mergeArray( obj, stamp, noupdate ) //hier moet ook ff deferUpdates
      } else {
        for (var j in obj) {
          cobj = obj[j]
          tobj = this[j]
          if ((j = Number(j)) > -1) {
            r = true
            if (tobj) {
              tobj.merge(cobj, false, stamp, true, block, sorted, deferUpdates )
            } else {
              if (j > this.length - 1) this.length = j + 1
              this.set(j, cobj, false, stamp, true, true)
            }
          }
        }
      }
    } else {
      for (i in obj) {
        stop = true
        cobj = obj[i]
        tobj = this[i]
        if (i !== 'val' && !_c(this._blacklist, i)) {
          if (!shallow && tobj && util.isObj(cobj)) { //cobj instanceof Object && (typeof cobj !== 'function') && cobj.__t !== 3)
            if (cobj.clear) {
              _coreSet.call(tobj, cobj, stamp, false, true)
              r = true
            } else {

              // console.error('---- merge /w update thats mos def wrong!', i, deferUpdates)
              //deferUpdates

              rt = tobj.merge(cobj, false, stamp, true, block, sorted, deferUpdates )
              if (r !== true) r = rt

              if (!rt) 
              {
                // console.log('0000')
                obj[i] = void 0
              }
            }
          } else {

            if (tobj && tobj._val === cobj) { //changed to differentiate between 0 and false, now also differentiates between 1 and '1'
                // console.log('---- 2 update thats mos def wrong!', i)

              if (r !== true) r = false
              // console.log('???????')
              obj[i] = void 0
            } else {
              // console.log('---- 3 update thats mos def wrong!', i)
              if(cobj===null && this[i]) {
                this[i].remove( false, false, false, void 0, stamp )
              } else {
                // console.log('!?'.bold, i, this[i])
                //name, val, vobj, stamp, noupdate, from
                this.set( i, cobj, false, stamp, true )
                // console.log('!xxxx?', i)
                if(this[i] && this[i]._listeners) {
                  // console.log('push push'.green,  JSON.stringify(obj) )
                  deferUpdates.push( [this[i], cobj] )
                }
                //add dit naar list
              }
              if (!r) r = rt;

              // console.warn(r, rt)

              if (!rt) 
              {
                //TODO: TEMP FIX DONT KNOW IF THIS WORKS!
                // console.log('???????22222')
                // obj[i] = void 0
                // console.warn('cant be right!')
                //SUPER CAREFULL WITH THIS R THING!!!!!
                r = true
              }
            }
          }
        }
      }
      if (obj.val) {
        rt = _coreSet.call(this, obj.val, stamp, false, true)
        if (!r) {
          r = rt
        }
        if (!rt) {
          obj.val = void 0
        }
      } else if (!stop) {
        if (!r) {
          r = false;
        }
      }
      r = (r !== false) || r
    }

    if (r) {
      if (!block) {
        // alert(noupdate)
        if (noupdate) {

          // console.log('!!??????????? NOUPDATE'.blue, JSON.stringify(obj))

          if(topLevel) {
            // console.log('UPDATE>?'.magenta.inverse, obj, JSON.stringify( obj ), noupdate, stamp)
            this._update(obj, stamp)
          }
          else {
            this.__update(obj, stamp)
            deferUpdates.push([ this, obj ])
          }
        } else {
          
          // console.log('2UPDATE>?'.cyan.inverse, topLevel, deferUpdates, obj, noupdate, stamp)

          this._update( obj, stamp )
        }
      }
    }
   

    if(topLevel && deferUpdates) {
      // console.log( 'defered updace', topLevel, deferUpdates)
      for(var df in deferUpdates) {
        if( deferUpdates[df][0] && deferUpdates[df][0].__update ) {
          // console.log('DEFERED!!!!'.cyan.inverse, df, deferUpdates[df][1], stamp )
          deferUpdates[df][0].__update( deferUpdates[df][1], stamp )
        }
      }
    }
    return r
  },
  /**
   * Copies an object and returns a new one, can also pass a merge object
   * @method
   * @param  {Object}        obj       Object to copy
   * @param  {Boolean}       [shallow] [description]
   * @param  {Array|Object}  [list]    Takes any object with .length
   * @param  {Object}        [parent]  [description]
   * @return {Object}                  [description]
   */
  'clone', function(obj, shallow, list, parent) { //support shallow!; check obj copy only what is nessecary added makeshort , made parent shorter
    var copy = new this._class(),
      _val = this._val,
      i;
    if (parent) {
      copy._parent = parent;
    }
    copy.__t = this.__t;
    if (this.__t === 1) {
      copy.length = this.length;
    }
    if (list) {
      //list
      for (var j = list.length - 1, item; j >= 0; j--) {
        item = list[j];

        if (item instanceof Array && this[item[0]]) {
          if(item[1] === true) {
            copy[item[0]] = util.clone(this[item[0]], false, true)
          } else {
            copy[item[0]] = item[1];
          }
        } else if (this[item]) {
          // console.log(item)
          copy[item] = this[item];
        }
      }
    }
    if (_val && (_val instanceof VObject && _val._contained)) {
      copy.val = _val.clone(copy, false, list, copy);
      copy._val._contained = true;
    } else {
      VObject.set.call(copy, _val, false, false, true);
    }
    for (i in this) {
      if (!_c(this._blacklist, i)) {
        // console.log(i)
        if (!shallow) {
          if (this[i] instanceof VObject) {
            //function( name, val, vobj, stamp, noupdate, from )

            // console.log('----->1', i, this[i].clone(void 0, false, list, copy))
            //stamp void 0
            copy.set(i, this[i].clone(void 0, false, list, copy), true, false, true)
          } else {

            // console.log('----->2', i, util.clone(this[i]))

            copy[i] = util.clone(this[i]);
          }
        } else {
          //function( name, val, vobj, stamp, noupdate, from )
          copy.set(i, this[i], false, false, true);
        }
      }
    }
    if (obj !== void 0) {
      if (util.isObj(obj)) {
        // console.log('MERGE----->', obj, shallow)
        copy.merge(obj, shallow);
      } else {
        VObject.set.call(copy, obj, false, false, true)
      }
    }
    copy.__t = this.__t;
    return copy;
  },
  /**
   * Returns object on the end of a defined path
   * @method path
   * @param  {Array}     path           Array of fields in path
   * @param  {*}         [val]          When defined, val will be set on endpoint of path if not already defined
   * @param  {Boolean}   [overwrite]    If true, val WILL overwrite existing value on endpoint of path when already defined
   * @param  {Function}  [writeHandler] Callback on write
   * @return {*}                        Object on the end of a defined path
   */
  'path', function(path, val, overwrite, writeHandler, vobj, stamp, noupdate, self) {
    if(!(path instanceof Array)) path = path.split('.');
    return util.path(this, path, val, overwrite, writeHandler, vobj, stamp, noupdate, self);
  },
  /**
   * Gets object from specified path. When path is a string checks for 'dotnotation'.
   * @method get
   * @param  {String|Array} path Defines field {string} or path {array|'dot-notation'}
   * @return {*}                 obj[path]|nested object/value
   */
  'get', function(path, self) { //get does not need an array as path
    return util.get(this, path, self);
  },

  //(val, stamp, from, noupdate, add)
  // '$set', function( val, stamp, from, update ) { //get does not need an array as path

  //   return VObject.set.call( this, val, stamp, from, !update )
    
  //     '_set', function(val, stamp, from, remove, noupdate, added, oldval) {
  //   if (!noupdate) {
  //     (val, stamp, from, noupdate, add)
  //     // console.log(this._path, val)
  //     this._update(val, stamp, from, remove, added, oldval);
  //   }
    

  // },
  /**
   * Check if obj is empty exclude field names passed to list
   * @method empty
   * @return {Boolean} True/false
   */
  'empty', {
    get: function() {
      return util.empty(this, this._blacklist);
    }
  },
  '$empty', function( excludes, update ) {
      //get does not need an array as path
      var _this = this
      this.each( function( key ) {
        if( 
            !excludes 
              || typeof excludes === 'string'  
                 ? key !== excludes 
                 : !util.checkArray( excludes, key ) 
          )
        {
          if( this.remove ) 
          {
            this.remove( false, false, false, false, false, true )
          } 
          else 
          {
            // console.warn( '$empty non-vObject object.util remove', this, key )
            _this[key] = null
          }
        }
      })
    
      if( this.clearCache ) this.clearCache()

      if( update )
      {
        this._update('empty')
      }
  },
  /**
   * Returns the V.Object from which the current update originated.
   * @method _updateOrigin
   * @return {V.Object} origin of the update
   */
  '_updateOrigin', {
    get: function() {
      var mark = this;
      while (mark._lfrom) {
        mark = mark._lfrom;
      }
      return mark;
    }
  },
  '_origin', {
    get: function() {
      var mark = this;
      while (mark && mark.__t === 4) {
        mark = mark._val;
      }
      return mark;
    }
  }
)


//add find


},{"../":"/Users/shawn/Work/vigour-native/node_modules/vigour-js/index.js","../util":"/Users/shawn/Work/vigour-native/node_modules/vigour-js/util/index.js","./":"/Users/shawn/Work/vigour-native/node_modules/vigour-js/object/index.js"}],"/Users/shawn/Work/vigour-native/node_modules/vigour-js/ui/element/index.js":[function(require,module,exports){
/*!
 * @license Copyright (c) 2012-2014, Vigour. All rights reserved.
 * @author: Youri Daamen, youri@vigour.io
 */

var Element = require('../../browser/element')

require('../../value/flags/parent')
require('../../value/flags/self')
require('../../value/flags/process')
require('../../value/flags/util')
require('../../browser/events')

module.exports =
  Element
  .inject
  ( require('../../browser/element/properties/collection')
  , require('../../browser/element/properties')
  , require('../../browser/element/properties/scrollbar')
  , require('../../browser/element/properties/process')
  , require('../../value/on')
  )


},{"../../browser/element":"/Users/shawn/Work/vigour-native/node_modules/vigour-js/browser/element/index.js","../../browser/element/properties":"/Users/shawn/Work/vigour-native/node_modules/vigour-js/browser/element/properties/index.js","../../browser/element/properties/collection":"/Users/shawn/Work/vigour-native/node_modules/vigour-js/browser/element/properties/collection/index.js","../../browser/element/properties/process":"/Users/shawn/Work/vigour-native/node_modules/vigour-js/browser/element/properties/process.js","../../browser/element/properties/scrollbar":"/Users/shawn/Work/vigour-native/node_modules/vigour-js/browser/element/properties/scrollbar.js","../../browser/events":"/Users/shawn/Work/vigour-native/node_modules/vigour-js/browser/events/index.js","../../value/flags/parent":"/Users/shawn/Work/vigour-native/node_modules/vigour-js/value/flags/parent.js","../../value/flags/process":"/Users/shawn/Work/vigour-native/node_modules/vigour-js/value/flags/process.js","../../value/flags/self":"/Users/shawn/Work/vigour-native/node_modules/vigour-js/value/flags/self.js","../../value/flags/util":"/Users/shawn/Work/vigour-native/node_modules/vigour-js/value/flags/util.js","../../value/on":"/Users/shawn/Work/vigour-native/node_modules/vigour-js/value/on.js"}],"/Users/shawn/Work/vigour-native/node_modules/vigour-js/util/hash.js":[function(require,module,exports){
//check this for more compression http://www.htmlgoodies.com/html5/client/optimizing-websockets-bandwidth.html#fbid=6QZx8napu20

/*
var crcTable
  , create = function () {
      crcTable = []
      for (var c, n = 0, k; n < 256; c = ++n) {
        for (k = 0; k < 8; k++, c = ((c & 1) ? ((0xEDB88320) ^ (c >>> 1)) : (c >>> 1)));
        crcTable[n] = c
      }
      return crcTable
    }

exports = module.exports = function (str) {
  for (var tab = crcTable || create(), crc = -1, i = 0, l = str.length; i < l; i++) {
    crc = (crc >>> 8) ^ tab[(crc ^ str.charCodeAt(i)) & 0xFF]
  }
  return exports.encode(((crc ^ (-1)) >>> 0))
}


*/

exports = module.exports = function(key, seed) {
  var remainder, bytes, h1, h1b, c1, c1b, c2, c2b, k1, i;
  seed = 1

  remainder = key.length & 3; // key.length % 4
  bytes = key.length - remainder;
  h1 = seed;
  c1 = 0xcc9e2d51;
  c2 = 0x1b873593;
  i = 0;
  
  while (i < bytes) {
      k1 = 
        ((key.charCodeAt(i) & 0xff)) |
        ((key.charCodeAt(++i) & 0xff) << 8) |
        ((key.charCodeAt(++i) & 0xff) << 16) |
        ((key.charCodeAt(++i) & 0xff) << 24);
    ++i;
    
    k1 = ((((k1 & 0xffff) * c1) + ((((k1 >>> 16) * c1) & 0xffff) << 16))) & 0xffffffff;
    k1 = (k1 << 15) | (k1 >>> 17);
    k1 = ((((k1 & 0xffff) * c2) + ((((k1 >>> 16) * c2) & 0xffff) << 16))) & 0xffffffff;

    h1 ^= k1;
        h1 = (h1 << 13) | (h1 >>> 19);
    h1b = ((((h1 & 0xffff) * 5) + ((((h1 >>> 16) * 5) & 0xffff) << 16))) & 0xffffffff;
    h1 = (((h1b & 0xffff) + 0x6b64) + ((((h1b >>> 16) + 0xe654) & 0xffff) << 16));
  }
  
  k1 = 0;
  
  switch (remainder) {
    case 3: k1 ^= (key.charCodeAt(i + 2) & 0xff) << 16;
    case 2: k1 ^= (key.charCodeAt(i + 1) & 0xff) << 8;
    case 1: k1 ^= (key.charCodeAt(i) & 0xff);
    
    k1 = (((k1 & 0xffff) * c1) + ((((k1 >>> 16) * c1) & 0xffff) << 16)) & 0xffffffff;
    k1 = (k1 << 15) | (k1 >>> 17);
    k1 = (((k1 & 0xffff) * c2) + ((((k1 >>> 16) * c2) & 0xffff) << 16)) & 0xffffffff;
    h1 ^= k1;
  }
  
  h1 ^= key.length;

  h1 ^= h1 >>> 16;
  h1 = (((h1 & 0xffff) * 0x85ebca6b) + ((((h1 >>> 16) * 0x85ebca6b) & 0xffff) << 16)) & 0xffffffff;
  h1 ^= h1 >>> 13;
  h1 = ((((h1 & 0xffff) * 0xc2b2ae35) + ((((h1 >>> 16) * 0xc2b2ae35) & 0xffff) << 16))) & 0xffffffff;
  h1 ^= h1 >>> 16;

  return (h1 >>> 0).toString(36)
}

// exports = module.exports = function( str )
// {
//   var FNV1_32A_INIT = 0x811c9dc5;
//   var hval = FNV1_32A_INIT;
//   for ( var i = 0; i < str.length; ++i )
//   {
//     hval ^= str.charCodeAt(i);
//     hval += (hval << 1) + (hval << 4) + (hval << 7) + (hval << 8) + (hval << 24);
//   }
//   return hval >>> 0;
// }

/**
 * Encode to base 62 (url save)
*/
exports.encode = function c (a, b) {
  b = b || ""
  return ~~ a 
       ? c(a / 62, String.fromCharCode(((a %= 62) > 9 
          ? a > 35 ? 29 : 87 
          : 48) + a) + b) 
       : b
}

/**
 * decode base 62
*/
exports.decode = function (a, b, c, d) {
  for (b = c = 0; d = a.charCodeAt(c++); b = b * 62 + d - [ , 48, 29, 87][d >> 5]);
  return b
}


// exports.decode64

},{}],"/Users/shawn/Work/vigour-native/node_modules/vigour-js/util/index.js":[function(require,module,exports){
/*!
 * @license Copyright (c) 2012-2014, Vigour. All rights reserved.
 * @author: Jim de Beer, jim@vigour.io
 */
require('./object') //these things add extra methods to util for readability in a seperate module
require('./prop')

exports.isNode = (typeof window === 'undefined') ? true : false

/**
 * Add is similar to .push it returns the array instead of length
 * Can be extended to support more types e.g. add an object to another
 * @method add
 * @param  {Array}  obj Target
 * @param  {Object} add Object to add
 * @deprecated
 */
exports.add = function (obj, add) {
  if (add) obj.push.apply(obj, add);
  return obj
}

/**
 * Finds items in an array
 * @method checkArray
 * @param  {Object|Array}                 list  Defines the list where you want to search through, only uses .length field
 * @param  {Object}                       val   Defines the value you want to search for
 * @param  {Boolean|String|Number}        [index] When index is true return the index instead of true or false, when index and index !== true index is used as a field in objects in the array
 * @param  {String}                       [field] When field return field instead of index or true
 * @return {*}
 */
exports.checkArray = function (list, val, index, field) {
  var arr = index instanceof Array
  if(!list) return false
  for (var i = 0, l = list.length, t; i < l; i++) {
    t = list[i]
    if (index !== void 0) {
      if (index === true) {
        if (t === val) return i
      } else if (arr ? exports.path(t,index)===val : t[index] === val) return field ? t : i
    } else {
      if (t === val) return true
    }
  }
  return false
}

/**
 * Pass arguments (arguments) and return a new array, when index return a new array sliced from index
 * @method arg
 * @param  {Arguments} args        Arguments
 * @param  {Number}    [index = 0] When index return a new array sliced from index
 * @return {Array}
 */
exports.arg = function (args, index) {
  return Array.prototype.slice.call(args, !index ? 0 : index)
}

/**
 * Check if obj is empty exclude field names passed to list
 * @method empty
 * @param  {Object}       obj  Object
 * @param  {Object|Array} list Takes any object with .length
 * @return {Boolean}           True/false
 */
exports.empty = function (obj, list) {
  for (var i in obj) {
    if (!list || !this.checkArray(list, i)) return false
  }
  return true
}




},{"./object":"/Users/shawn/Work/vigour-native/node_modules/vigour-js/util/object.js","./prop":"/Users/shawn/Work/vigour-native/node_modules/vigour-js/util/prop.js"}],"/Users/shawn/Work/vigour-native/node_modules/vigour-js/util/inject.js":[function(require,module,exports){

var V = require('../')
  , util = require('./')

module.exports = exports = function(extend) {
  var args = arguments
  if( (typeof this === 'function') || (V.Base && (this instanceof V.Base))) {
    if((V.Base 
        && (this===V.Base 
        || (this.prototype instanceof V.Base)
        || (this instanceof V.Base))
      )) { 
      args = util.arg(args)
      args.unshift(this)
      extend = this
    } else {
      return inject.apply(this,args)
    }
  }
  for(var i = 1; i < args.length; i++) {
   makeExtend(extend, args[i])
  }
  return extend
}

function makeExtend(extend, module) {
  if(module.extend) {
     module.extend(extend)
  } else if(module instanceof Array) {
    var arr = module.concat()
      , mod = arr[0]
    arr[0] = extend
    mod.extend.apply(mod,arr)
  } 
} 

function inject() {
  //do special stuff voor blacklist
  // Custom.prototype = new this() //lighter
  var Custom
    , extendResidue = []
    , Aspects = [this]

  for (var i = 0, Aspect, args = arguments, len = args.length; i < len; i++) {
    
    Aspect = args[i]

    if(typeof Aspect === 'function') {
      if(!Custom) {
        Custom = function() {
          for (var j = 0, len = Aspects.length; j < len;  j++) {
            Aspects[j].apply(this, arguments)
          }
        }
        inherits( Custom, this )
      }
      Aspects.push(Aspect)
      for (var method$ in Aspect.prototype) if ({}.hasOwnProperty.call(Aspect.prototype, method$)) {
        if (method$ === 'constructor') continue
        Custom.prototype[method$] = Aspect.prototype[method$]
      }
    } else {
      if(Custom) {
       makeExtend(Custom , Aspect)
      } else {
        extendResidue.push(Aspect)
      }
    }
  }

  if(!Custom) Custom = this
  
  for(var j in extendResidue) {
    makeExtend(Custom,extendResidue[j])
  }

  return Custom
}

function inherits(ctor, superCtor) {
  ctor.super_ = superCtor
  ctor.prototype = Object.create
    ( superCtor.prototype
    , { constructor: 
        { value: ctor
        , enumerable: false
        , writable: true
        , configurable: true
        }
      }
    )
}

/*
 Dit moet worden geadd voor V.Objects
/*
  object.new = function(params, constructor) {
  var vObj = function(val, hook, parent) {
      if (parent) this._parent = parent
      if (hook && this._hook) this._hook(val, hook)
      if (this._onConstruct) this._onConstruct(val, hook)
      if (val !== void 0) this.val = val
      // console.log(constructor)
      if(constructor) constructor.apply(this,arguments)  
    },
    proto = vObj.prototype = new this()
  vObj.new = object.new
  util.define(vObj, '_blacklist', proto._blacklist.concat())
  _params.call(vObj, params, ['mixed', 'merge'])
  util.define(vObj, '_class', vObj)
  return vObj
}

veel dingen werken als extension niet als losse class -- 

*/


},{"../":"/Users/shawn/Work/vigour-native/node_modules/vigour-js/index.js","./":"/Users/shawn/Work/vigour-native/node_modules/vigour-js/util/index.js"}],"/Users/shawn/Work/vigour-native/node_modules/vigour-js/util/object.js":[function(require,module,exports){
/*!
 * @license Copyright (c) 2012-2014, Vigour. All rights reserved.
 * @author: Jim de Beer, jim@vigour.io
 */
var util = module.exports = exports = require('./')
  , vigour = require('../') //only here to be able to use util without vigour.Object maybe refactor this away?
  , DOT = '.'

/**
 * lookup
 * polyfill if __lookupSetter__ does not exist;
 */
exports.lookup = Object.__lookupSetter__ || function (i) {
  var t = this
    , a
  while (t) {
    a = Object.getOwnPropertyDescriptor(t, i)
    if (a && a.set) return true
    t = Object.getPrototypeOf(t)
  }
  return false
}

/**
 * Used to set a val to an field on a object, whether it is a vigour.Object or a regular object
 * @method set
 * @param {Object} obj   Defines target Object
 * @param {String} field Target field
 * @param {*}      val   Value to set
 * @todo                 Move this function to a different module (e.g. 'convenience' module)
 */
exports.set = function (obj, field, val, vobj, stamp, noupdate) {
  return (vigour.Object && (obj instanceof vigour.Object))
    ? obj.set(field, val, vobj, stamp, noupdate)
    : (obj[field] = val)
}


/**
 * Returns object on the end of a defined path
 * @method path
 * @example
 * // returns obj.a.b.c
 * var obj = { a: { b: { c: 1 }}}
 * V.util.object.path(obj,['a','b','c'])
 * @param  {Object}    obj            Object to search
 * @param  {Array}     path           Array of fields in path
 * @param  {*}         [val]          When defined, val will be set on endpoint of path if not already defined
 * @param  {Boolean}   [overwrite]    If true, val WILL overwrite existing value on endpoint of path when already defined
 * @param  {Function}  [writeHandler] Callback on write
 * @param  {Boolean}   [noupdate]     When true, updates will be skipped on write
 * @param  {Number}    [i = 0]        Starting point for searching through path
 * @return {*}                        Object on the end of a defined path
 */

exports.path = function ( obj, path, val, overwrite, writeHandler, vobj, stamp, noupdate, self, uid, i ) {
  if (!i) i = 0

  // if(path.length === 0) return obj

  var field = path[i]
    , result
    , c
    , target = (!self && obj && obj.__t === 4) ? obj.from[field] : obj && obj[field]
    , l = i < path.length - 1

    //deze target

  if (l && !(target instanceof Object)) target = void 0

  if ((val !== void 0) && (target === void 0 || (!l && overwrite))) {
    c = true
    exports.set(obj, field, l ? {} : val, l ? false : vobj, stamp, noupdate)
    target = obj[field]
  }

  if (l) {
    result = target
      ? this.path(target, path, val, overwrite, writeHandler, vobj, stamp, noupdate, self, uid, ++i)
      : target
  } else {
    result = (!self && target && target.__t === 4) ? target.from : target;
    if (c && writeHandler) writeHandler(result)
  }
  return result
}

/**
 * Adds path using 'dot-notation'
 * @method dotField
 * @example
 * // returns blur:{d:{a:{s:{}}}}
 * var blur = {};
 * V.util.object.dotField(blur,'d.a.s');
 * @param  {Object} obj   Object where field will be added
 * @param  {String} field String using 'dot-notation'
 * @return {Object}       Returns field
 */
exports.dotField = function (obj, field) {
  if (~field.indexOf(DOT)) {
    var path = field.split(DOT)
      , first = path.shift()
      , val = {}
    this.path(val, path, obj[field])
    delete obj[field]
    obj[first] = val
    field = first
  }
  return field
}

/**
 * Checks if two lists contain identical content
 * @method compareArrays
 * @param  {Array|Object} a Takes any object with .length
 * @param  {Array|Object} b Takes any object with .length
 * @return {Boolean}        True/false
 * @todo                    Maybe change title => compareLists
 */
exports.compareArrays = function(a, b) {
  // console.log('compare',a,b)
  if (a.length !== b.length) return false
  for (var i = b.length - 1; i >= 0; i--) {
    if (a[i] != b[i]) return false
  }
  return true
}

/**
 * Gets object from specified path. When path is a string checks for 'dotnotation'.
 * @method get
 * @example
 * // returns 'foo'
 * var a = {b:{c:'foo'}}
 * V.util.object.get(a,'b.c')
 * @param  {Object}       obj  Defines object or V.Value
 * @param  {String|Array} path Defines field {string} or path {array|'dot-notation'}
 * @return {*}                 obj[path]|nested object/value
 */
exports.get = function (obj, path, self) {
  if (!obj || !path) return
  if (!self && obj.__t === 4 && !obj._filter) obj = obj.from
  if (!(path instanceof Array)) {
    if (~path.indexOf(DOT)) {
      path = path.split(DOT)
    } else {
      return (!self && obj[path] && obj[path].from) || obj[path]
    }
  }
  //self is too far away in the arguments
  return this.path(obj, path, void 0, false, false, false, false, false, self)
}

/**
 * Returns true if an object is an instance of an object and not a function , V.Object or V.Base
 * @method isObj
 * @param  {Object}  obj Object to inspect
 * @return {Boolean}     True/False
 */
exports.isObj = function (obj) {
  return (obj instanceof Object
    && typeof obj !== 'function'
    && (!vigour.Object || !(obj instanceof vigour.Object))
    && (!vigour.Base || !(obj instanceof vigour.Base)))
}

/**
 * Creates new object with the same value , takes custom objects into account (new obj.constructor())
 * @method clone
 * @param  {Object} obj Object to clone
 * @return {Object}     Returns clone
 */
exports.clone = function (obj, exclude, shallow) {
  if (this.isObj(obj)) {
    var copy = new obj.constructor()
    for (var i in obj) {
      if(!exclude || !exclude[i])
        copy[i] = !shallow
          ? this.clone(obj[i], exclude)
          : obj[i]
    }
    return copy
  }
  return obj
};

/**
 * Merges object b into object a and returns object a
 * @method merge
 * @param  {Object} a Object a
 * @param  {Object} b Object b
 * @return {Object}   Object a
 */
exports.merge = function (a, b, norefs, overwrite) {
  for (var i in b) {
    var aisobj = util.isObj(a[i])
      , bisobj = util.isObj(b[i])

    if (aisobj && bisobj) {
      util.merge(a[i], b[i], norefs, overwrite)
    } else if(!norefs || !bisobj){
      if( overwrite === void 0
       || !(i in a)
       || typeof overwrite === 'function' && overwrite(a[i], b[i])
        ){
        a[i] = b[i]
      }

    }else{
      a[i] = b[i] instanceof Array ? [] : {}
      util.merge(a[i], b[i], norefs, overwrite)
    }
  }
  return a
}

// exports.resolve = function(a, b, bFrom, j) {
//   var same = true;
//   if(b instanceof Object) {
//     for(var i in b) {
//       if(a[i]!==void 0) {
//         if(exports.resolve(a[i],b[i],bFrom ? bFrom[i] : b[i],i)) {
//           if(bFrom) {
//             delete bFrom[i]
//           }
//         } else {
//           same = false
//         }
//       } else {
//         same = false
//       }
//     }
//     if(same) {
//       if(!(bFrom&&j!==void 0)) return true
//       delete bFrom[j]
//     }
//     return same;
//   } else {
//     if(a==b) {
//       if(bFrom&&j!==void 0) {
//         delete bFrom[j]
//       }
//       return true
//     }
//   }
// }

exports.resolve = function(a, b, bFrom, j) {
  // console.log('lolresolve\n',bFrom)
  var same = true;
  if(b instanceof Object) {
    for(var i in b) {
      if(a[i]!==void 0) {
        if(exports.resolve(a[i],b[i],(bFrom!==void 0 && bFrom!==null) ? bFrom[i] : b[i],i)) {
          if(bFrom!==void 0 && bFrom!==null) {
            if(bFrom[i]===null) {
              same = false
            } else {
              delete bFrom[i]
            }
          }
        } else {
          same = false
        }
      } else {
        same = false
      }
    }
    if(same) {
      if(!(bFrom&&j!==void 0)) return true
      delete bFrom[j]
    }
    return same;
  } else {
    if(a==b) {
      if(bFrom&&j!==void 0) {
        delete bFrom[j]
      }
      return true
    }
  }
}

/**
 * Adds value to array if it is not contained in array, executes handler on encountering val in array
 * @method include
 * @param  {Object|Array}   obj       Takes any object with .length
 * @param  {*}              val       Value to add
 * @param  {Function}       [handler] Function to execute on encountering val in array
 * @param  {Boolean}        arr       Include elements of val separately rather than including val itself
 * @return {Boolean}                  True/false
 */
exports.include = function (obj, val, handler, arr) {

  if(arr && val instanceof Array) {
    var ret = false
    for(var i = 0 , len = val.length; i < len; i++) {
      ret = exports.include(obj, val[i], handler)
    }
    return ret
  }

  var i = 0
    , l = obj.length
    , field
    , check

  if (obj.__t === 1) {
    for (;i < l; i++) {
      field = check = obj[i]
      if (check.__t === 4) check = check.from
      if (check === val || check.val === val) {
        if (handler) handler(field)
        return false
      }
    }
    obj.push(val)
    return true
  } else if (obj instanceof Array) {
    for (;i < l; i++) {
      if (obj[i] === val) {
        return false
      }
    }
    obj.push(val)
    return true
  }
}

exports.changeType = function( obj ) {
  var result
  if(obj instanceof Array) {
    result = {}
    for(var i=0,len=obj.length;i<len;i++) {
      result[i]=obj[i]
    }
  } else {
    result = []
    for(var i in obj) {
      result.push(obj[i])
    }
  }
  return result
}

/**
 * Ensures a value is not or contains no V.Objects, only their "raw" versions
 * This needs to be unified with convert, or at least get a better name.
 * @method raw
 * @param  {*}   val   the value to be processed
 * @return {*}         the processed value
 */
exports.raw = function( val, rparams ) {
  if (val instanceof Object) {
    if (val instanceof vigour.Object) {
      return val.raw
    } else {
      var result
      if (val instanceof Array) {
        result = []
        for (var i = 0, l = val.length; i < l; i++) {
          result[i] = this.raw(val[i], rparams)
        }
      } else {
        result = {}
        for (var f in val) {
          result[f] = this.raw(val[f], rparams)
        }
      }
      return result
    }
  } else {
    return val
  }
}

//add level and stops for certain branches
exports.walk = function(obj, fn ) {
  for(var i in obj) {
    if(obj[i] instanceof Object) {
      if(!fn(i, obj[i], obj, true)) {
        if(exports.walk(obj[i], fn)) return true
      } else {
        return true
      }
    } else {
      if(fn(i, obj[i], obj)) {
        return true
      }
    }
  }
}

exports.checkParentFactory = function( parentField ) {
  return function(field, get, links, match) {
    if(get&&get!==true) {
      match = get
      get = false
    }
    var fields = field instanceof vigour.Object ? false : field,
      curr = this,
      found;
    while (curr) {
      found = fields === false ? curr === field : exports.get(curr, fields, !links);
      if (found) {
        if(match) {
          if(match === found || (found instanceof vigour.Object) && found.val === match) {
            return !get && fields ? curr : found;
          }
        } else {
          return !get && fields ? curr : found;
        }
      }
      curr = curr[parentField];
    }
  }
}



},{"../":"/Users/shawn/Work/vigour-native/node_modules/vigour-js/index.js","./":"/Users/shawn/Work/vigour-native/node_modules/vigour-js/util/index.js"}],"/Users/shawn/Work/vigour-native/node_modules/vigour-js/util/process.js":[function(require,module,exports){
//processes
var vObject = require('../object')

// console.log('init process!')

module.exports = {}

},{"../object":"/Users/shawn/Work/vigour-native/node_modules/vigour-js/object/index.js"}],"/Users/shawn/Work/vigour-native/node_modules/vigour-js/util/prop.js":[function(require,module,exports){
/*!
 * @license Copyright (c) 2012-2014, Vigour. All rights reserved.
 * @author: Jim de Beer, jim@vigour.io
 */
var util = module.exports = exports = require('./')
  , V = require('../')
/**
 * Setstores are used to avoid updates troughout prototype chains for changes of fields on objects
 * It uses two fields
 *   .__ to indicate own values for pieces of an object inherited trough the prototype chain
 *   ._ is the refence back to the objects as ste in the prototype
 * @constructor setstore
 */
exports.setstore = function() {
  if ( !this.__ ) this.__ = {}
}

//TODO: reconstruct value using pieces of objects in __

exports.getStore = function( name ) {
  return this.__ 
          ? ( this.__[name] !== void 0 
            ? this.__[name] 
            : this._[name]
            ) 
          : this._ && this._[name]
}

function extensions( extend, fn, base, args, extended ) {
    
  if( !extend.extensions ) 
  {
    if(base) {
      extend.extensions = []
    } else {

      // console.log(extend)
      if(extend instanceof V.Object ) {
        util.define( extend, 'extensions',[])
      } else {
        //gebruik deze extension stylo
        util.define( extend, 'extensions',{val:[], setClass:true} )
      }
    }
  }

  // console.log( 'EXTEND'.red, extend.extensions, base, fn, this, extended )

  if( util.checkArray( extend.extensions, this )===false ) 
  {

    // console.log( 'EXTEND -2'.red, this )

    if( !extended ) extend.extensions = [ this ].concat( extend.extensions ) 

      // console.log( 'EXTEND -3'.red, extend.extensions )
      //somethin weird!

    // console.log( 'EXTEND -3'.red, this, extend, extend.extensions.length )


    var myArgs = util.arg( args )
    if( base && !extended ) {
      myArgs[0] = base
    }
    return fn.apply( this, myArgs )
  }

}

exports.extend = function() {
  
  var extendArray = util.arg( arguments )

  return function(extend) {
    var base
      , proto

    if( typeof extend === 'function' ) 
    {
      if( V.Base && ( extend.prototype instanceof V.Base ) ) {
        base = extend.base
        proto = true
      } else {
        proto = extend.prototype
      }
    } else if( V.Base && ( extend instanceof V.Base ) ) 
    {
      proto = extend
    }

    for
    ( 
      var fn
        , ret
        , args = util.arg( arguments )
        , extendArr
        , xArg
        , i = 0
        , len = extendArray.length
        ; i < len
        ; i ++ 
    ) 
    {    
      if(extendArray[i] instanceof Array) 
      {
        extendArr = extendArray[i][0]
        xArg = util.arg(extendArray[i],1)
        xArg.unshift(extend)
      } else 
      {
        xArg = args
        extendArr = extendArray[i]
      }

      ret = extensions.call 
      ( extendArr.extend ?  extendArr : this 
      , base || proto
      , extendArr.extend ||  extendArr
      , base
      , xArg
      , extendArr.extend ? true : false 
      ) 
      || extend

    }
    return ret
  }

}

/**
 * Add is used as a shortcut method for Object.defineProperty and extends setstore functionality to normal prototypes
 * @method add
 * @param  {Object}          obj  When obj is a constructor it selects obj.prototype, when obj is a normal object this is used instead
 * @param  {String|Array}    name When name is a string it adds the name for the object, when name is a array do the same setting for each name
 * @param  {Object|Function} val  When val is an object , use this object for Object.defineProperty with default for enummerable:false, when object is empty adds {value:{},ennumerable:false}, when val is a function it automatically wraps a property definition object with {value: val , enummerable:false}, when val is not a function and not an object (boolean, string, number) adds special setstore value
 * @param  {Function}        [set]  Adds custom setters to a setstore object, when set is a string the add functions interprets the arguments as name : property definition pairs
 * @param  {Function}        [get]  Adds custom getters to a setstore object
 * @
 */
exports.define = function (obj, name, val, set, get, id) {
  if (typeof set === 'string') {
    var _args = util.arg(arguments)
    for (var i = 1, l = _args.length; i < l; i += 2) {
      exports.define(obj, _args[i], _args[i + 1])
    }
  } else {
    if (name instanceof Array) {
      for (var i = 0, l = name.length; i < l; i++) {
        exports.define(obj, name[i], val)
      }
    } else {
      if (typeof val === 'function' || val instanceof Array) {
        val = {
          enumerable: false,
          value: val,
          configurable: true
        }
      } else if (!val || ( !(val instanceof Object) || val.setClass  )) {

        if( val && val.setClass ) {
          val = val.val
        }

        var proto = obj.prototype || obj


        //

        //TODO: not a good solution -- has to redefine constantly ( too heavy )
        // if( proto !== obj.prototype && proto._ ) {
        //    //TODO: this can go completely wrong when you expect inheritance not to break when making a new class!
        //    if( proto.constructor.prototype._ === proto._ ) {
        //       var old = proto._
        //       proto._ = {}
        //       for(var key in old) {
        //         proto._[key] = old[key]
        //       }
        //    }
        // }
        
        //maybe make into a method
        if( id) {
          // console.log('DEFINE! DO IT'.red.inverse, name, id, proto)
          if (!proto.__) proto.__ = {}
          proto.__[name] = val
        } else {
          if (!proto._) proto._ = {}
          proto._[name] = val
        }



      

        //if proto is not a prototype (how to check?) then use __ perhaps?

        //moet hier niet altijd ze eiguh worden gemaakt?

       //default dit is eigenlijk het enige dat mis gaat

        var setter = function(val) {
              exports.setstore.call(this)
              //TODO: fix closure for val
              if (val || val === 0 || val === false) this.__[name] = val
            }
          , wset = function(val) {
              val = set.call(this, val);
              setter.call(this, val);
            }
          , getter = function() {
              return exports.getStore.call(this, name);
            }
          , wget = function() {
              var prop = getter.call(this);
              return get.call(this, prop);
            }

        val = {
          enumerable: false,
          configurable: true,
          get: get ? wget : getter,
          set: set ? wset : setter
        }

      } else if (!val.enumerable) {
        if (util.empty(val)) val.value = {}
        val.configurable = true
        val.enumerable = false
      }

      Object.defineProperty(obj.prototype || obj, name, val)

      // Object.defineProperty(obj.prototype || obj, name, val)
      //mayeb do both?
    }
  }
}
},{"../":"/Users/shawn/Work/vigour-native/node_modules/vigour-js/index.js","./":"/Users/shawn/Work/vigour-native/node_modules/vigour-js/util/index.js"}],"/Users/shawn/Work/vigour-native/node_modules/vigour-js/value/base.js":[function(require,module,exports){
/*!
 * @license Copyright (c) 2012-2014, Vigour. All rights reserved.
 * @author: Jim de Beer, jim@vigour.io
 */
var base = require('../base')
  , value = require('./')
  , objectSet = require('../object').set
  , util = require('../util')
  // , raf = require('../browser/animation/raf')

exports.clonelist = [
  [ '_base', false ], '_caller', '_prop', '_name', '_skip'
]

function resolveListener( listener, val, prop, instance ) {
  if (listener) {
    if ( listener._bind === instance && listener.__t === 4 ) {
      // console.log('bind resolve'.red.bold, val )
      listener.val = val
    }
    else if (!listener._bind ) { 

      if( listener.__t === 4 && listener._val === prop )
      {
        // listener.val = 
        listener.val = val
        console.log('----------', listener.__t )
      }
      else
      {
        // console.log('ultimate ugly!')
        val.addListener(listener) //dit fixed  
      }

      //TODO: implement this later
      // if( listener instanceof Array ) {
      //   var mark = listener[1]
      //   if( mark ) {
      //     if( mark === prop._base || mark === instance || instance instanceof mark._class ) {
      //       //TODO: propably need to check for inheritance ( mark instance of prop._base)
      //       // console.log('mark resolve'.green.inverse, listener)
      //       // val.addListener([ listener[0] , instance ], true)
      //     }
      //   }
      // }

      
      // val.addListener(_listeners[i])
    }
  }
}

// function resolveListener( ) {

// }

/**
 * V.value.base.type
 * Defines the base type used in V.Value
 * @type
 */
exports.type = {
  type: value,
  /**
   * Defines what this type will do on creation.
   * @method create
   * @param  {*} val              Value
   * @param  {[type]}  [prop]     [description] //WORDT NIET GEBRUIKT
   * @param  {Object}  [settings] Settingobject
   * @param  {Boolean} [noupdate] When true, doesn't update the V.Value
   * @return {Object}             Returns the V.Value
   */
  create: function(val, prop, settings, noupdate) {
    var v = new value()
    v._base = this
    v._caller = v._base
    v._prop = settings
    // console.log('set')
    objectSet.call(v, val, false, false, true)
    // console.log('done setting')
    if (this._class) this._class.prototype._[settings.name] = v
    if (settings.set) {
      if (!settings._vset) {
        settings._vset = function(stamp, from, remove, cval) {
          // var t = this
          // t.__s = true
          // if(!t._s) {
            // raf(function() {
              // console.log('IM HERE?')
              // t.__s = null
              settings.set.call(
                   this._caller
                || this._base
                || this, this, stamp, from, remove, cval
              )
            // })
          // }

        }
      }
      if (!noupdate) {
        // console.log('UPDATE creation')
        v._update(val)
      }
    }
    return v
  },
  /**
   * Defines what this type will do on set.
   * @method set
   * @param  {*}      val      Value
   * @param  {Object} prop     Properties
   * @param  {Object} settings Settingsobject
   * @return {*}               Returns value
   */
  set: function(val, prop, settings) {

    if(!prop) return
    // console.log('SET FUN!')
    prop._caller = this
    //deze bind zou alleen moeten werken voor als je iets op het exact goede momment changed!

    prop._bind = false
    if (this !== prop._base) {
      var _listeners = prop._listeners
        , _b = prop._base
        , i
        , _this = this

      util.setstore.call(this)
      exports.clonelist[0][1] = this //beetje dirty...

      //clone is always used to get rid of flags
      if (val !== void 0 && !val.clear) {
        val = prop.clone(val, false, exports.clonelist)
      } else {
        // if(prop._flag) {
        //   value.flags[prop._flag[0]].remove && value.flags[prop._flag[0]].remove.call(this,prop._flag)
        // }
        //listener on nested child on parent

         //--->  new width for this one
         // --->  hey a listener on me /w a bind on my instance!
         //  ----> add listener to me (listener on class prop)
         //   -----> hey lets reset this little guys width
         //    ------>  lets add Listener
         //     -------->  double listeners on this one
        var v = new value()
        v._base = this
        v._prop = settings
        v._caller = this

        // clean FLAGS from node!
        if(val) delete val.clear
        v.val = val
        val = v
      }

      this.__[settings.name] = val

      if( this._class ) this._class.prototype._[settings.name] = val

      // for each field (only 1 level deep for now)
      prop.each
      ( 
        function(key) {
          // console.log('resolve', prop._prop.name, key)
           if( this._listeners ) {
            for (i =  this._listeners.length - 1; i >= 0; i--) {
              resolveListener( this._listeners[i], val[key], prop, _this )
            }
            //TODO: check if this is nessecary
            if(val[key].val !== this.val)
            {
              // console.log(val[key]) 
              // val[key]._update()
            }
          }
        }
      )

      if( _listeners ) {

        for (i = _listeners.length - 1; i >= 0; i--) {
          resolveListener( _listeners[i], val, prop, _this )
        }

      }

      val = null
      // console.log('UPDACE ----'.yellow)
      this[settings.name]._update(val)
    }

    return val
  },
  /**
   Defines what this type will do on get.
   * @method get
   * @param  {Object} prop     Properties
   * @param  {Object} settings Settingobject
   * @return {Object}          [description]
  */
  get: function(prop, settings) {
    // console.log('GETTING!', prop, settings.name)
    if (prop) prop._caller = this
    if (settings.get) return settings.get.call(this, prop)
    return prop
  }
}
},{"../base":"/Users/shawn/Work/vigour-native/node_modules/vigour-js/base/index.js","../object":"/Users/shawn/Work/vigour-native/node_modules/vigour-js/object/index.js","../util":"/Users/shawn/Work/vigour-native/node_modules/vigour-js/util/index.js","./":"/Users/shawn/Work/vigour-native/node_modules/vigour-js/value/index.js"}],"/Users/shawn/Work/vigour-native/node_modules/vigour-js/value/flags/data.js":[function(require,module,exports){
/*!
 * @license Copyright (c) 2012-2014, Vigour. All rights reserved.
 * @author: Jim de Beer, jim@vigour.io
 */
var flags = module.exports = require('./'),
  util = require('../../util'),
  object = require('../../object'),
  ownModel = function(base) {
    if (!base.__ || !base.__.model) { //maybe a utility? use it at different spots like settings
      base.model = {};
      if (!base._.model) {
        base._dListen();
      }
    }
    return base.model;
  };
/**
 * data
 * data adds a reference to the data property of the current base class;
 * if there is not _base.model use data.base.extend(baseClass);
 * @flag
 */
flags.data = {
  useVal:true, //(reset???)
  set: function(val, stamp, reset) {

    var current = this.checkParent('_prop.name'),
      name = current._prop.name,
      base = current._base,
      model = ownModel(base);
    if (model.flags && model.flags[name]) {
      if (!(model.flags[name] instanceof Array)) {
        model.flags[name] = [model.flags[name]];
      }
      if (!util.checkArray(model.flags[name], this)) {
        model.flags[name].push(this);
      }
    } else {
      if (!base.model.flags) {
        base.model.flags = {};
      }
      base.model.flags[name] = this;
    }

    // console.log('LEZZ SET IT!', val, stamp, reset, current)

    var getData = function() {
      var data = this._d;
      if (data === void 0) {
        var parent = this;
        while (data === void 0 && parent) {

          // if(parent.model && (!parent.model.inherit || parent.model.inherit.val!==false)) {
          //   return data
          // }

          if (parent._d) {
            data = this._dSet(parent._d, true);
          } else {
            parent = parent.node.parentNode;
            if (parent) {
              parent = parent.base;
            }
          }
        }
      }
      return data;
    };
    if (val instanceof Object) {
      var v = val.val || val;
      this._val = function() {
        var data = getData.call(this);
        // console.log('---->',v,data)
        return data && v.call(this, data);
      };
      val = val.listen || true;
    } else {
      this._val = function() {
        var data = getData.call(this),
          ret;
        data = val === true ? data : util.get(data, val);
        if (data !== void 0) {
          ret = data.__t && !data._filter && data.val;
          if (!ret && ret !== 0 && ret !== '') { //weird
            ret = data;
          }
        } else {
          ret = '';
        }
        return ret;
      };
    }
    if(!this._flag) this._flag = {}

    // this.__lval = false
    // current._caller.setSetting({
    //   name: name,
    //   parent: function(parent) {
    //     console.log('!@#!@#!@#')
    //     this.updateData()
    //   }
    // });

    this._flag.data = ['data', this._val, val, name];
  },
  remove: function() {
    var current = this.checkParent('_prop.name'),
      model = ownModel(current._base),
      t = this;
    if (model && model.flags) {
      for (var i in model.flags) {
        if (i === current._prop.name) {
          var item = model.flags[i];
          if (item instanceof object || item.length === 1) {
            model.flags[i] = null;
            delete model.flags[i];
          } else {
            model.flags[i].splice(util.checkArray(item, t), 1);
          }
        }
      }
    }
    this._update() //pas hiermee op!
    // var t = this
    setTimeout(function() {
      //deze pas uitvoeren nadat alle klaar is! dit is dirty!
      t._update()
    },0)
  }
};
},{"../../object":"/Users/shawn/Work/vigour-native/node_modules/vigour-js/object/index.js","../../util":"/Users/shawn/Work/vigour-native/node_modules/vigour-js/util/index.js","./":"/Users/shawn/Work/vigour-native/node_modules/vigour-js/value/flags/index.js"}],"/Users/shawn/Work/vigour-native/node_modules/vigour-js/value/flags/index.js":[function(require,module,exports){
/*!
 * @license Copyright (c) 2012-2014, Vigour. All rights reserved.
 * @author: Jim de Beer, jim@vigour.io
 */
var value = require('../'),
    base = require('../base'),
    flags = require('../../object/flags');
    
    base.clonelist.push(['_flag', true]); //true clone!
    flags.extend(value);
    module.exports = value.flags;
},{"../":"/Users/shawn/Work/vigour-native/node_modules/vigour-js/value/index.js","../../object/flags":"/Users/shawn/Work/vigour-native/node_modules/vigour-js/object/flags.js","../base":"/Users/shawn/Work/vigour-native/node_modules/vigour-js/value/base.js"}],"/Users/shawn/Work/vigour-native/node_modules/vigour-js/value/flags/parent.js":[function(require,module,exports){
/*!
 * @license Copyright (c) 2012-2014, Vigour. All rights reserved.
 * @author: Jim de Beer, jim@vigour.io
 */
var flags = module.exports = require('./')
  , value = require('../')
  , util = require('../../util')
  , vObject = require('../../object')


//todo add element signature in from so it can travel trough updates --- if parent (need less funky things)

/**
 * parent
 * parent makes it possible to add listeners to parent properties
 * using multiple parent properties in one property is still very wrong
 * @flag
 */
value.prototype._blacklist.push('_parentStore')

function baseReset(base,name) {
  if(base && base.node) {
    if(name==='x' || name ==='y') base.cleanCoordinates(name)
    if(base[name]) {
      base[name]._prop._vset.call(base[name])
    }
  }
}


// window.pcheck = 0

// window.pprops = {}

//base,vset,t,type,mparent,fbase, v, val, stamp, from, remove, added, oldval, true, firstSkip
function checker(vset, t, type, mparent, fbase, v, val, stamp, from, remove, added, oldval, first, firstSkip, p) {
  if(p&&(this.parent instanceof mparent) ||  (!p && this.parent===mparent) || firstSkip ) {

    // pcheck++

    var s
      , base = this._from.base.node && this._from.base
      , name = t._prop.name

    // if(!window.pprops[name]) window.pprops[name] = 0

    // window.pprops[name]++


    t._caller = this

    //gaurd voor changes -- if no change -- do nothing
    vset.call(t, stamp, from, remove, val)

    if(base&&base[name]&&base[name+'__p']!==stamp) {
      t._caller = base
      t._caller[name+'__p'] = stamp
      vset.call(t, stamp, from, remove, val)
      t._caller = this
      s=true
    }

    // console.log(this.node)
    for(var i in t._listeners) {
      if(t._listeners[i].pop && t._listeners[i][2]==='parent') {
        if(t._listeners[i][1]._lstamp===stamp) {
          t._listeners[i][1]._lstamp=null
        }
        t._listeners[i][0].call(t._listeners[i][1], type, this, base, v, val, stamp, from, remove, added, oldval, true)
      }
    }

    //reset this._from.base[t._prop.name]===t
    if(s) baseReset(base, name)

  }
}

function updateHandler(type,mparent,fbase,v, val, stamp, from, remove, added, oldval,firstSkip,inherit) {

  var t = this

  this._parentStore[0] = mparent

  this._update(val, from ? this.stamp() : stamp, from, remove, added, oldval, false, false, function() {
    var vset =  this.checkParent('_prop._vset', true)
      , base = this.checkParent('_base', true)
      , complexParent = true
      , p

    if( (mparent===base.parent && from)  ) {
      p = true
    }

    checker.call(base,vset,t,type,mparent,fbase, v, val, stamp, false, remove, added, oldval, true, firstSkip)

    base.eachInstance(function() {
     checker.call(this, vset, t,type, mparent,fbase, v, val, stamp, false, remove, added, oldval, false, p)
    }, t._prop.name)

    vObject.prototype._update.call(this, val, stamp, false, remove, added, oldval, function(l) {
      return l[2]==='parent'
    })

    if(!inherit && v._caller && mparent!==v._caller) {
      updateHandler.call(this,type,v._caller,fbase, v, val, stamp, false, remove, added, oldval,firstSkip,true)
    }

  })
}

function _parent(parent, noupdate, prop, flag, reset) {

  // console.log('_parent call'.cyan.inverse, flag)

  var _lparent = prop._parentStore[0]
    , pname = flag[2]   //flags.parent.val
    , pprop = parent[pname]
    , fbase = this._from.base
    , newP
    , baseSet

  if (!pprop) return

  // console.log('ADD LISTENER TO PARENT')

  pprop.addListener(
    [ updateHandler
    , prop
    , 'parent'
    , parent
    , this //fbase
  ], function(l,listeners,index) {

    if(l[3]!==parent &&  _lparent!==parent && l[4]!==fbase) {
      prop._parentStore[0] = parent
      l[4] = fbase
      newP = true //hoe deze smart afvangen?
    }
  }, false, true)

  // if(reset) {
  //   for(var i in pprop._listeners) {
  //     if(pprop._listeners[i].pop && pprop._listeners[i][1]===fbase[prop._prop.name]) {
  //       if(pprop!==parent._from.base[pname]) {
  //         pprop._listeners.splice(i,1)
  //         break;
  //       }
  //     }
  //   }
  // }

  if (newP || (!_lparent || (_lparent !== parent && _lparent[pname] !== pprop) ) ) {
    prop._parentStore[0] = parent
    if (!noupdate) {
      prop._caller = (baseSet = fbase.node && fbase || prop._base)
      prop._prop._vset.call(prop, prop)
      prop._caller = this
      updateHandler.call(prop,'parent',parent,fbase,pprop,false,vObject.stamp(),false,false,false,false,true,true)
      baseReset(baseSet,prop._prop.name)
    }
  }
}

function _init(val, flag, reset) {
  var parent = this.parent
  // console.log('try parent', flag, parent)
  if (parent) _parent.call(this, parent, true, val, flag, reset)
}

function _val(val) {
  var parent = this.parent || val.checkParent('_parentStore.0', true)
  //flags.parent.val
  if(parent && !val._flag.parent) {
    console.error('NO PARENT FLAG!')
    return
  }
  // console.log('---->',val._flag.parent[2])
  if (parent ) return parent[val._flag.parent[2]].val
}

flags.parent =
{ reset: true
, useVal: true
, set: function(val, stamp, reset) {
    var current = this.checkParent('_prop.name'),
      name = current._prop.name
    //flags.parent.val
    if(!this._flag) this._flag = {}

      //overwriting previous parent
      //
    // console.log('SET PARENT---->')
    this._flag.parent = ['parent', _val, val, this]
    if (!current._parentStore) current._parentStore = [false]

    // console.log('GOTS PARENTSTORE!', reset, current._parentStore, this._flag.parent)

    current._parentStore.push(this)
    //setParent settings
    // console.log('---> CREATE SETTING'.yellow.inverse)
    current._caller.setSetting({
      name: name,
      parent: function(parent) {

        // console.log('---> SET SETTING'.yellow.inverse)

        for (var store = this[name]._parentStore, i = store ? store.length - 1 : 0; i > 0; i--) {
          if(store[i]._flag.parent) {
            _parent.call(this, parent, false, this[name], store[i]._flag.parent)
          } else {
            console.error('2 NO PARENT FLAG!')
          }
        }
      }
    });
    //try to minimize val calulations
    this._val = _val
    this._skip = true
    //onInit (if it already has some parents)
    _init.call(current._base, current, this._flag.parent, reset)
    //reAttach listeners for instances
    current._base.eachInstance(_init, name, current, this._flag.parent)
  }
, remove: function(flag) {

    // console.log('REMOVE PARENT'.cyan.inverse)

    var current = this.checkParent('_prop.name'),
      base = current._base,
      listens = current._listens,
      name = current._prop.name,
      val = flag[2],  //flags.parent.val
      parentStore = current._parentStore,
      removelistener = function() {
        var parent = this.parent
        if (parent && parent[val]) {
          if (listens.length > 0) {
            if (util.checkArray(listens, parent[val])) {
              // console.log('REMOVE LISTENER!', parent[val], listens.length, parent[val]._listeners.length, parent[val]._listeners , current)


              //more specific only remove if val matches --- store function
              parent[val].removeListener( false, current )

              //mark = false


              // console.log('REMOVE LISTENER! -- result -- no update?', listens.length)

            }
          } else {
            return true
          }
        }
      }

    this._val = 0

    if (listens && !removelistener.call(base)) {
      base.eachInstance(removelistener, name)
    }

    // console.log('PARENTSTORE', parentStore, current)
    parentStore.splice(util.checkArray(parentStore, this, true), 1)

    if (parentStore.length === 1) {
      // console.log('---> REMOVE SETTING'.yellow.inverse, parentStore)
      base.removeSetting(name, 'parent') //ff corigeren voor andere parent settings!!! op andere fields
      //dit maakt het helemaal kapot!
      // console.warn('REMOVE PARENTSTORE!')
      current._parentStore = null
    }
  }
}
},{"../":"/Users/shawn/Work/vigour-native/node_modules/vigour-js/value/index.js","../../object":"/Users/shawn/Work/vigour-native/node_modules/vigour-js/object/index.js","../../util":"/Users/shawn/Work/vigour-native/node_modules/vigour-js/util/index.js","./":"/Users/shawn/Work/vigour-native/node_modules/vigour-js/value/flags/index.js"}],"/Users/shawn/Work/vigour-native/node_modules/vigour-js/value/flags/process.js":[function(require,module,exports){
/*!
 * @license Copyright (c) 2012-2014, Vigour. All rights reserved.
 * @author: Jim de Beer, jim@vigour.io
 */

//TODO: flags on the basis of path ( similair to cases )

//TODO: make Value flags more injectable
var flags = module.exports = require( './' )
  , processes = require( '../../util/process' )
  , Value = require( '../' )
  , util = require( '../../util' )
  , ajax = require('../../browser/network/ajax')
  , vObject = require('../../object')

//TODO: maybe add promise

exports.create = function( flag, settings, Constructor, extendflags ) {

  if( !extendflags ) extendflags = flags
  if( !Constructor ) Constructor = Value

  var tempStore = '__temp'+flag+'__'
    , inProgress =  '__inprogress'+flag+'__'
    , origUpdate = Constructor.prototype._update
    , once = settings && settings.once
    , deferMethod = settings && settings.deferMethod
    , origSet
    , origRemove
    , deferflag = 
      { reset: true
      , set: function( val, stamp, reset ) {
          if( !this._flag ) this._flag = {}
          this._flag[flag] = [ flag, false, val, this ]
        }
      , remove: function() {
          var defer = this._flag && this._flag[flag]
            , vobj

          if( defer && defer[1] )
          {

            // if( deferMethod ) 
            // {
              // vobj = deferMethod.call( _this, arr, defer[2], _this[tempStore], origUpdate, Constructor )
            // }
            // if() {
              vobj = typeof defer[2] === 'string'
                   ? processes[defer[2]]
                   : typeof defer[2] !== 'function' && defer[2]
            // }

            if( vobj.removeListener )
            {
              vobj.removeListener( defer[1] )
            }
            else if( vobj && vobj !== true )
            {
              for( var vobj$ in vobj )
              {
                vobj.removeListener( vobj[vobj$] )
              }
            }
          }
        }
      }


  Constructor.prototype._blacklist.push
  ( tempStore
  , inProgress
  , '_history'
  // , '_initialised'
  )

  if( deferMethod ) {
    settings.deferMethod = null
  }

   if( once ) {
    settings.once = null
    Constructor.prototype._blacklist.push( once )
  }

  if( settings ) {
    for( var key in settings )
    {
      if( key === 'set' )
      {
        origSet = deferflag.set
        deferflag.set = function( val, stamp, reset ) {
          settings.set.call( this, origSet, arguments )
        }
      }
      else if( key === 'remove' )
      {
        origRemove = deferflag.remove
        deferflag.remove = function( val, stamp, reset ) {
          settings.remove.call( this, origRemove, arguments )
        }
      }
      else 
      {
        deferflag[key] = settings[key]
      }
    }
  }

  extendflags[flag] = deferflag

  //extend update
  util.define
  ( Constructor
  , '_update'
  , function( val, stamp ) {

      if( this._flag && this._flag[flag] && ( !once || !this[once] ) ) //&& !this._initialised 
      {
        var _this = this
          , defer = _this._flag && _this._flag[flag]
          , tempdefer = _this[tempStore]
          , add
          , arr
          , vobj
          , recur
          , fn


        if( !tempdefer )
        {
          _this[tempStore] = tempdefer = []
          add = true
        } else {
          //TODO: fix caching stamp, most efficient but may break things /w instances etc

          if( stamp && tempdefer[0][1] !== stamp )
          {
            tempdefer[0][1] = stamp
          }
          return
        }

        arr = util.arg( arguments )
        tempdefer.push( arr )

        if( add )
        {
     
          if( deferMethod ) 
          {
            vobj = deferMethod.call( _this, arr, defer[2], tempStore, origUpdate, Constructor )
          }
          else 
          {
            vobj = typeof defer[2] === 'string'
               ? processes[defer[2]]
               : defer[2]
          }

          if( vobj )
          {
          
            //TODO: replace with a standard function, lose the extra closure!
            recur = function() {

              if( once ) 
              {
                _this[once] = true
              }
              //dit ook kunnen meegeven

              //TODO: using a closure here may not be nessecary anymore, use another identifier
              for( var i = 0, len = tempdefer.length; i < len; i++ ) {
                // _this._caller = tempdefer[i].splice( tempdefer[i].length-1, 1 )
                // tempdefer[i][1] = this.stamp()
                origUpdate.apply( _this, tempdefer[i] )
              }

              if( this.removeListener ) this.removeListener( recur )
              _this[tempStore] = null
            }

            if( typeof vobj === 'function' )
            {

              if( !_this[inProgress] )
              {

                fn = function( val ) {
                  
                  if( val!==true && _this[inProgress] ) {
                    _this[inProgress]()
                  }
                  _this[inProgress] = null
                  _this[tempStore] = null
                }

                _this[inProgress] = recur

                if( vobj.call( this, fn , arr, tempdefer ) === true )
                {
                  _this[tempStore] = null
                  _this[inProgress] = null
                }
                // else
                // {
                //   console.log( '?' )
                //   //TODO: check if this is the best way, (updating recur, or mayeb just use the same recur)
                //   _this._deferinprogress = recur
                // }

              }

            }
            else if( vobj === true )
            {
              if( this.val || this.val === 0 )
              {
                origUpdate.apply( _this, arr )
                _this[tempStore] = null
              }  
              else
              {
                console.error( 'no value! from defer type:', flag)
              }
            }
            else if( !vobj.addListener )
            {
              for( var vobj$ in vobj )
              {
                vobj[vobj$].addListener( recur )
              }
            }
            else
            {
              vobj.addListener( recur )
            }

            defer[1] = recur
          }
        }

      }
      else
      {
        // console.log( flag, once, 'should do orig update bitches!', arguments, this )
        origUpdate.apply( this, arguments )
      }

    }
  )

} 

//TODO: injectable
//TODO:_tempdefer hoeft niet altijd maak create -- update type flag
//always update method
exports.create( 'force', 
{ deferMethod: function( args, vobj, tempStore, update ) {
    var _this = this
    //dit zit natuurlijk dieper!
    _this._skip = true //maybe check if it rly gets reset?
    _this._ignoreValue = true
    _this.clearCache()
    _this[ tempStore ] = null
    update.apply( _this, args )
  }  
})
//deze moet nog wat dieper

exports.create( 'history', 
{ deferMethod: function( args, vobj, tempStore, update, Constructor ) {
    //vobj option voor flag
    if(!this._history) this._history = []

    this._history.unshift( args )
    this[tempStore] = null //total control! (old including arguments)

    //allright that works this.clearCache() //cache dingen adden
    update.apply( this, args )
  }
})

exports.create( '$type', 
{ deferMethod: function( args, vobj, tempStore, update ) {
    var _this = this
      , haveToUpdate

    //arrays etc
    _this.clearCache()

    if( vobj === true )
    {
      if( _this.val ) haveToUpdate = true
    }
    else if( vobj === 'string' )
    {
      if( typeof _this.val === 'string' ) haveToUpdate = true
    }
    else if( vobj === 'number' )
    {
      if( typeof _this.val === 'number' ) haveToUpdate = true
    }
    else if( typeof vobj === 'function' )
    {
      if( vobj.apply( _this, args ) ) haveToUpdate = true
    }

    if( haveToUpdate ) {
      _this[tempStore] = null
      update.apply( _this, args )
    }
  }  
})

exports.create( 'defer' )

//TODO: vObj flag ( accessable trough object[flag] )

Value.operators.responseData = function( val, operator ) {
  return operator===false ? val : operator
}

//vobj parser!

exports.create( 'ajax', 
{ remove: function( remove, args ) {
    //TODO: ajax call stop
    remove.apply( this, args )
  }
, set:function( set, args) {
//     console.log('set ajax defer')
    if( ! this.loading ) {
      //name, val, vobj, stamp, noupdate, from
      this.set( 'loading', false, false, false, true )
    }
    set.apply( this, args )
  }
, deferMethod: function( args, vobj, tempStore, update, Constructor ) {
    var _this = this  

    return vobj && function( update, args ) {

      var origu = update

      update = function( type, kill ) {
        _this.clearCache()
        _this._skip = true
        _this._ignoreValue = true
        if( type ) {
          args[0] = type
          if(! ( _this._val instanceof vObject ) ) {
            _this.val = type
          } 
        }
        if( _this.loading ) _this.loading.val = false
        origu( kill )
        _this._ignoreValue = null
      }

      if( typeof vobj === 'object' )
      {
        var params = vobj
        vobj = {}
        for( var key in params ) {
          if( key === 'defer' ) {
            vobj[key] = params[key]
          } else {
            if(!vobj[key]) {
              if( key !== 'complete' && key !== 'error' && typeof params[key] === 'function' ) {
                vobj[ key ] = params[ key ].call( _this, vobj, args[0], args )
                if( !vobj[key] ) {
                  return true
                }
              } else {
                vobj[key] = params[key]
              }

              if( vobj[key] instanceof vObject ) {
                vobj[key] = vobj[key].val //custom get or raw
              } 
            }
          }
        }
      }

      if( typeof vobj === 'function' ) 
      {
        vobj = vobj.call( _this, vobj, args[0], args )
        if(!vobj) return true
      }

      if( typeof vobj === 'string' ) 
      {
        vobj = { url: vobj }
      }

      if( vobj.url instanceof vObject ) {
        vobj.url = vobj.url.val
      }

      if( !vobj || !( vobj.url || vobj.api ) ) 
      {
        return true
      }

      var complete = vobj.complete
        , error = vobj.error

      vobj.complete = function( data ) {
        if( vobj.defer ) 
        {
          vobj.defer.call( _this, update, args, null, data, vobj )
        }
        else
        {
          if(!_this.responseData) {
            _this.set( 'responseData', data )
          }
          else {
            _this.responseData.merge( data )
          }
          ;complete && complete( data )
          update( 'success' )
        }
      }

      vobj.error = function( err ) {
        if( vobj.defer ) 
        {
          vobj.defer.call( _this, update, args, err, vobj )
        }
        else
        {
          if( _this.responseData )
          { 
            _this.responseData.each( function( key ) {
              if( !Constructor.operators[key] && !Constructor.flags[key] )
              {
                this.remove()
              }
            })
          }
          _this.set( 'responseData' , void 0 )
          if( error ) error( data )
          update( 'error' )
        }
      }

      if( _this.loading ) {
        //TODO:correct responses managemet -- pretty easy todo
        _this.loading.val = true
      }

      ajax( vobj ) //TODO: let it return a promise
    }  
  }
})

//temp args 

//TODO: dit later vervangen met local flags (api)
//TODO: unify ajax hiermee voor oncsitent error handeling -- of extension op ajax
exports.create( 'apiDefer', 
{ remove: function( remove, args ) {
    //TODO: ajax call stop
    remove.apply( this, args )
  }
, set:function( set, args) {
    if(! this.loading ) {
      this.set( 'loading', false, false, false, true )
    }
    set.apply( this, args )
  }
, deferMethod: function( args, vobj, tempStore, update, Constructor ) {
    var _this = this  
   
    return vobj && function( update, args ) {

      if( !args[0] || args[0].apiDefer ) return true

      var wrappedUpdate = function( val, kill ) {

        _this.loading.val = false
        if( val && val!==true ) 
        {
          _this.val = args[0] = val
          
          try {
            update( val ) //val -- val
          } catch( err ) {
            console.error( 'DEEPER ERROR IN API DEFER , SOMETHING TOURGHLY WRONG /w this API', val )
            //best example is facebook login true and gone but only weh the .loading is there
            //most be a very deep issues i geuss... hard to recreate 
            _this.type = err
            update( 'error' )
          }

          _this.clearCache()
          _this._val = false
        }
        else 
        {
          update( val )
        }
      }
      
      _this.loading.val = true
      var api = _this.checkParent( 'api', true )

      if( api && api.val !== true ) 
      {

        api.once(function( val ) {
          if( val === 'error' ) 
          {
            _this.clearCache() //hier ff een functie voor maken!
            _this.val = args[0] = 'error'
            _this.type = this.type || 'api'
            _this.loading.val = false
            wrappedUpdate()
          }
          else if( val === true )
          {
            vobj.call( _this, wrappedUpdate, args )
          }
        })
        api.val = true
      } 
      else
      {
        vobj.call( _this, wrappedUpdate, args )
      }
    }
  }
})

exports.create( 'init', 
{ set: function( set, args ) {
    if( !this.initialised )
    {
      set.apply( this, args ) //niet nodig!
    }
  }
, remove: function( remove, args ) {
    remove.apply( this, args )
    this.initialised = null
  }
, once: 'initialised'
})


},{"../":"/Users/shawn/Work/vigour-native/node_modules/vigour-js/value/index.js","../../browser/network/ajax":"/Users/shawn/Work/vigour-native/node_modules/vigour-js/browser/network/ajax.js","../../object":"/Users/shawn/Work/vigour-native/node_modules/vigour-js/object/index.js","../../util":"/Users/shawn/Work/vigour-native/node_modules/vigour-js/util/index.js","../../util/process":"/Users/shawn/Work/vigour-native/node_modules/vigour-js/util/process.js","./":"/Users/shawn/Work/vigour-native/node_modules/vigour-js/value/flags/index.js"}],"/Users/shawn/Work/vigour-native/node_modules/vigour-js/value/flags/self.js":[function(require,module,exports){
/*!
 * @license Copyright (c) 2012-2014, Vigour. All rights reserved.
 * @author: Jim de Beer, jim@vigour.io
 */
var flags = module.exports = require('./');

/**
 * self
 * @flag
 */
flags.self = {
  reset: true,
  useVal:true,
  set: function(val, stamp, reset) {
    var current = this.checkParent('_prop.name')
    if (current._base && current._base[val]) {
      current._base[val].addListener(this)
      this._val = function() {
        return this[val] && this[val].val
      }
      if(!this._flag)  this._flag = {}
      this._flag.self = ['self', this._val, val, this]
    }
  }
};

},{"./":"/Users/shawn/Work/vigour-native/node_modules/vigour-js/value/flags/index.js"}],"/Users/shawn/Work/vigour-native/node_modules/vigour-js/value/flags/util.js":[function(require,module,exports){
/*!
 * @license Copyright (c) 2012-2014, Vigour. All rights reserved.
 * @author: Jim de Beer, jim@vigour.io
 */

var flags = module.exports = require('./')
/**
 * listen
 * adds listeners to a V.Value
 * @property
 **/
flags.listen = {
  reset:true,
  set: function(val, stamp, reset) {
    if(!val)
    {
      console.error('no val in flags listen!')
//       debugger
      return
    }
    if(!this._flag) this._flag = {}
    //eventueel mergen!
      
    // console.log('listen'.cyan.inverse, reset, val)
    //if reset make sure its resetted correctly!
    this._flag.listen = ['listen', false, val, this ] 
    if (val instanceof Array) {
      for (var i = val.length - 1; i >= 0; val[i--].addListener(this));
    } else {
      //ok
      var _this = this
      // val.addListener(function() {
      //   console.log('TROUGH LISTEN!!!!'.magenta.inverse, val._path)
      //   // _this._update.apply(_this, arguments)
      // }) 
      val.addListener(this) //dit moet beter (remove listener if possible)
    }
  },
  remove:function() {
    if(this._flag&&this._flag.listen) {
      var val = this._flag.listen[2]
      if (val instanceof Array) {
        for (var i = val.length - 1; i >= 0; val[i--].removeListener(this));
      } else {
        val.removeListener(this) //dit moet beter (remove listener if possible)
      }
    }
  }
}

},{"./":"/Users/shawn/Work/vigour-native/node_modules/vigour-js/value/flags/index.js"}],"/Users/shawn/Work/vigour-native/node_modules/vigour-js/value/index.js":[function(require,module,exports){
/*!
 * @license Copyright (c) 2012-2014, Vigour. All rights reserved.
 * @author: Jim de Beer, jim@vigour.io
 */
var object = require( '../object' )
  , util = require( '../util' )
  , vigour = require( '../' )

/**
 * vigour.Value
 * v values are optimized for use in combination /w instances of vigourBase, have operators and support method values
 * @Class
 */
module.exports = exports = vigour.Value = object.new(
{ mixed: true
, merge: true
})

//parent problems

var _getOperator = function( val, force, i, t, bind, operators ) {
  var f = t[i]._get(bind, force, val);
  if (f !== void 0 && f !== null) {
    val = operators[i](val || ((typeof f === 'string') ? '' : 0), f);
  }
  return val;
};

exports.prototype._blacklist.push('_lstamp', '_clearCache', '_lval', '__lval','___lval', '_base', '_caller', '_bind', '_prop', '_instances', '_skip', '_overwrite')
//_caller stamp for get for lvals (last values)
util.define(exports,
  'clearCache', function() {
    this.___lval = null
    this.__lval = null
    this._lval = null 
  },
  /**
   * Used to get .val which calculates a constructed value
   * _bind is very important binds listeners to specific instances
   * @method _get
   * @param  {[type]} bind  [description]
   * @param  {[type]} force [description]
   * @return {[type]}       [description]
   */
  '_get', function(bind, force, currentVal) {

    if(this._clearCache) {
      this.clearCache()
    }

    // console.log('_get',this._name, this._val,this);
    if (this._overwrite) {
      return this._overwrite;
    }
    if (!this._lval && this._lval !== 0 || force) {
      var val = this._val,
        nolval,
        operators = this.operators;

      if (val instanceof object) {
        val = val._get(this._bind || bind, force, currentVal);
      } else if (typeof val === 'function') {

        // console.log('RIGHT HERE', currentVal)
        var a = this;
        if (!bind) {
          while (a._parent && !a._caller) {
            a = a._parent;
          }
        }
        val = val.call(bind || a._caller || a._base || this, this, currentVal); //if currentval else something else;
        nolval = true;
        //for functions you need to clear _lval since you never know if there is something in the function updated
      }
      if (operators) {
        if (this.__t === 1 && operators[this._name]) { 
          //operator is an array
          val = 0; //string
          for (var j = 0, l = this.length; j < l; j++) {
            if (this[j]) {
              vj = this[j]._get(bind, false, (currentVal || 0) + val);
              if (!vj) {
                vj = 0; //string
              }
              if (typeof vj === 'string' && val === 0) {
                val = '';
              }
              val += vj; //only add no operator stuff
              if (!this[j]._lval) {
                nolval = true;
              }
            }
          }
        } else {
          //also add before
          var ordered;
          for (var i in this) {
            if (operators[i]) {
              if (!operators[i].order) {
                if (!force && this[i]._lstamp !== this._lstamp && this[i].__t === 1) {
                  force = true;
                }
                val = _getOperator(val, force, i, this, bind, operators);
                if (!nolval && !this[i]._lval) {
                  nolval = true;
                }
              } else {
                if (ordered) {
                  if (!ordered.pop) {
                    ordered = [ordered];
                  }
                  var o = operators[i].order,
                    ol = ordered.length - 1;
                  for (var h = 0; h !== true && h <= ol; h++) {
                    if (h === ol) {
                      if (o < operators[ordered[h]].order) {
                        var a = ordered[h];
                        ordered[ol] = i;
                        ordered.push(a);
                      } else {
                        ordered.push(i);
                      }
                      h = true;
                    } else if (h === ol && o > operators[ordered[h]].order) {
                      ordered.push(i);
                      h = true;
                    }
                  }
                } else {
                  ordered = i;
                }
              }
            }
          }
          //shorter
          if (ordered) {
            // console.log(ordered);
            var x;
            i = ordered.pop ? (x = 1) && ordered[0] : ordered;
            while (i && this[i]) {
              if (!force && this[i]._lstamp !== this._lstamp && this[i].__t === 1) force = true
              val = _getOperator(val, force, i, this, bind, operators);
              if (!nolval && !this[i]._lval) nolval = true
              i = ordered[x++];
            }
          }
        }
      }
      if (!nolval && !force) {
        this._lval = val;
        this.__lval = val;
      } else if (!(this._base && this._base.instances)) {
        this.__lval = val;
      }
      return val;
    } else {
      return this.__lval;
    }
  },
  /**
   * Fires all listeners
   * @method update
   * @param  {[type]} instance    [description]
   * @param  {[type]} noinstances [description]
   * @param  {[type]} stamp       [description]
   * @param  {[type]} from        [description]
   * @param  {[type]} remove      [description]
   * @param  {[type]} added       [description]
   * @return {[type]}             [description]
   */
  'update',
  function(instance, noinstances, instancesUpdates, stamp, from, remove, added) {
    //is this really nessecary?
    this._update.call( this, void 0, stamp || this.stamp(), from, remove, false, false, noinstances, instance, instancesUpdates  ); //this.val
    return this;
  },
  /**
   * Extends vigourObject._update
   * Adds loads of stuff to optimize updates for calculations
   * @method _update
   * @param  {[type]} val         [description]
   * @param  {[type]} stamp       [description]
   * @param  {[type]} from        [description]
   * @param  {[type]} remove      [description]
   * @param  {[type]} added       [description]
   * @param  {[type]} noinstances [description]
   * @param  {[type]} instance    [description]
   * @return {[type]}             [description]
   */
  '_update',
  function( val, stamp, from, remove, added, oldval, noinstances, instance, instancesUpdates ) {

    var t = this,
      base = t._base;

    if (val instanceof exports && !t._bind) 
    {
      // console.log('lets bind'.bold.inverse, val._name)
      if (val._caller) {
        t._bind = val._caller;
      }
    }

    if(t._clearCache) {
      t.clearCache()
    }

    if ( (!t._lstamp) || t._lstamp !== stamp  ) 
    {

      t._lval = false

      //_skip property makes sure that the .val is never cached in lval
      if (base && base.instances || t._skip || t.__lval === void 0 || t.___lval !== t.val) { //pass this calculation to vset else its too heavy;

        var operators = t.operators,
          prop = t._prop,
          parent = t._parent,
          vset = prop && prop._vset;

        if (!(from && remove) && operators && (operators[t._name] || (parent && parent.__t === 1 && operators[parent._name] && (!from || t._name == parent.length - 1)))) {
          //works for arrays since arrays are always replaced on update , updating an individual item using .set will not result in an update at this pont which has to be resolved
          _op = this._parent;
          
          while (operators[_op._name]) {
            _op._lval = false; //if no change to lval can go wrong...
            _op = _op._parent;
          }
          
          if (_op) {
            _op._update(val, stamp, this, remove, added, oldval, noinstances, instance, instancesUpdates);
          }

        }

        if (instancesUpdates) {
          instancesUpdates.call(t, val, stamp, from, remove, added, oldval, noinstances, instance, instancesUpdates);
        } else {

          if (instance) {
            base = instance;
          }

          if (vset) {
            t._caller = base;
            vset.call(t, stamp, from, remove, val);
          }
          if (base && vset && base.instances && !noinstances && prop.updateinstances !== false) {
            base.eachInstance(function() { //look for current caller instance perhaps?
              t._caller = this;
              vset.call(t, stamp, from, remove, val);
            }, prop.name, t);
            t._caller = base;
          }

          //form gone lets see!
          //from self doorgeven in chain ==-- if ! not from from ---> , extra arg

          object.prototype._update.call(t, val, stamp, from || t, remove, added, oldval)

        }

        //pas op met deze!
        t.___lval = t.__lval
        t._lstamp = stamp;

      }

    }
  })

//requiring operators does not automaticly require vigourValue, may be handy?
util.define(exports, 'operators', {
  value: exports.operators = require('./operators')
})





},{"../":"/Users/shawn/Work/vigour-native/node_modules/vigour-js/index.js","../object":"/Users/shawn/Work/vigour-native/node_modules/vigour-js/object/index.js","../util":"/Users/shawn/Work/vigour-native/node_modules/vigour-js/util/index.js","./operators":"/Users/shawn/Work/vigour-native/node_modules/vigour-js/value/operators.js"}],"/Users/shawn/Work/vigour-native/node_modules/vigour-js/value/on.js":[function(require,module,exports){
/*!
 * @license Copyright (c) 2012-2014, Vigour. All rights reserved.
 * @author: Jim de Beer, jim@vigour.io
 */

  /*
    Extension for Base classes to create an inheritable on - value
  */

var Value = require('./')
  , util = require('../util')
  , Base = require('../base')

exports.extend = util.extend
( function(base)
  {
    if( base instanceof Base )
    {

      base.extend
      (
        {
          name:'on',
          set:function(val) {
            
          },
          remove:function(val) {
            //remove
            // console.log('im being removed!')
             if(this.on.$remove) {
              this.on.$remove.update()
            }
          },
          new:function(val) {
            //init
            // console.log('INIT!----', this, val, arguments)
            if(this.on.$new) {
              this.on.$new.update()
            }
          },
          parent:function(val) {
            //init
            if(this.on.$parent) {
              this.on.$parent.update()
            }
          },
          render:function(val) {
            //init
            // console.log('RENDER!----', this, val, arguments)
            if(this.on.$render) {
              this.on.$render.update()
            }
          }
        }
      )

    }
    else
    {
      console.error( 'extend on base' )
    }
  }
)

},{"../base":"/Users/shawn/Work/vigour-native/node_modules/vigour-js/base/index.js","../util":"/Users/shawn/Work/vigour-native/node_modules/vigour-js/util/index.js","./":"/Users/shawn/Work/vigour-native/node_modules/vigour-js/value/index.js"}],"/Users/shawn/Work/vigour-native/node_modules/vigour-js/value/operators.js":[function(require,module,exports){
/**
 * operators
 * operators can be set on V.Value.operators
 * define operators on this module
 * @property
 */
var util = require('../util')
  , V = require('../')

exports.add = function( val, operator ) {
  return val + operator
}
exports.sub = function( val, operator ) {
  return val - operator
}
exports.multiply = function( val, operator ) {
  return val * operator
}
exports.divide = function( val, operator ) {
  return val / operator
}
exports.max = function( val, operator ) {
  return val > operator ? operator : val
}
exports.min = function( val, operator ) {
  return val < operator ? operator : val
}
exports.transform = function( val, operator ) {
  return operator===false ? val : operator
}
exports.abs = function( val, operator ) {
  return operator ? Math.abs(val) : val
}
exports.floor = function( val, operator ) {
  return val | 0
}
exports.ceil = function ( val, operator ) {
  return Math.ceil( val )
}
exports.$convertType = function ( val, operator ) {
  //convertType
  if( operator === 'boolean' )
  { 
    return val ? true : false
  } 
  else if( operator === 'number' )
  {
    //do isNan start using loDash for this kind of stuff ( almost nothing )
    //convert falsy or NaN values to 0
    return Number( val )
  }
}

exports.default = function( val, operator ) {

// console.log( '????', val )
  
  //pas op met die 0
  if( (!val && val !== 0) || val._val === false || val === 'error' || val === 'success' )
  {
    //TODO: Arrays for default operator
    return operator
  }
  return val
}
exports.default.order = 1000
},{"../":"/Users/shawn/Work/vigour-native/node_modules/vigour-js/index.js","../util":"/Users/shawn/Work/vigour-native/node_modules/vigour-js/util/index.js"}],"/Users/shawn/npm/lib/node_modules/gaston/node_modules/browserify/node_modules/process/browser.js":[function(require,module,exports){
// shim for using process in browser

var process = module.exports = {};

process.nextTick = (function () {
    var canSetImmediate = typeof window !== 'undefined'
    && window.setImmediate;
    var canPost = typeof window !== 'undefined'
    && window.postMessage && window.addEventListener
    ;

    if (canSetImmediate) {
        return function (f) { return window.setImmediate(f) };
    }

    if (canPost) {
        var queue = [];
        window.addEventListener('message', function (ev) {
            var source = ev.source;
            if ((source === window || source === null) && ev.data === 'process-tick') {
                ev.stopPropagation();
                if (queue.length > 0) {
                    var fn = queue.shift();
                    fn();
                }
            }
        }, true);

        return function nextTick(fn) {
            queue.push(fn);
            window.postMessage('process-tick', '*');
        };
    }

    return function nextTick(fn) {
        setTimeout(fn, 0);
    };
})();

process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;

process.binding = function (name) {
    throw new Error('process.binding is not supported');
}

// TODO(shtylman)
process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};

},{}]},{},["/Users/shawn/Work/vigour-native/examples/projectx/www/index.js"])
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uL25wbS9saWIvbm9kZV9tb2R1bGVzL2dhc3Rvbi9ub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvYnJvd3Nlci1wYWNrL19wcmVsdWRlLmpzIiwiL1VzZXJzL3NoYXduL1dvcmsvdmlnb3VyLW5hdGl2ZS9leGFtcGxlcy9wcm9qZWN0eC93d3cvaW5kZXguanMiLCIvVXNlcnMvc2hhd24vV29yay92aWdvdXItbmF0aXZlL2V4YW1wbGVzL3Byb2plY3R4L3d3dy9zdHlsZXMubGVzcyIsIi9Vc2Vycy9zaGF3bi9Xb3JrL3ZpZ291ci1uYXRpdmUvbGliL2JyaWRnZS9hbmRyb2lkL2luZGV4LmpzIiwiL1VzZXJzL3NoYXduL1dvcmsvdmlnb3VyLW5hdGl2ZS9saWIvYnJpZGdlL2luZGV4LmpzIiwiL1VzZXJzL3NoYXduL1dvcmsvdmlnb3VyLW5hdGl2ZS9ub2RlX21vZHVsZXMvcHJvbWlzZS9pbmRleC5qcyIsIi9Vc2Vycy9zaGF3bi9Xb3JrL3ZpZ291ci1uYXRpdmUvbm9kZV9tb2R1bGVzL3Byb21pc2UvbGliL2NvcmUuanMiLCIvVXNlcnMvc2hhd24vV29yay92aWdvdXItbmF0aXZlL25vZGVfbW9kdWxlcy9wcm9taXNlL2xpYi9kb25lLmpzIiwiL1VzZXJzL3NoYXduL1dvcmsvdmlnb3VyLW5hdGl2ZS9ub2RlX21vZHVsZXMvcHJvbWlzZS9saWIvZXM2LWV4dGVuc2lvbnMuanMiLCIvVXNlcnMvc2hhd24vV29yay92aWdvdXItbmF0aXZlL25vZGVfbW9kdWxlcy9wcm9taXNlL2xpYi9ub2RlLWV4dGVuc2lvbnMuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvcHJvbWlzZS9ub2RlX21vZHVsZXMvYXNhcC9hc2FwLmpzIiwiL1VzZXJzL3NoYXduL1dvcmsvdmlnb3VyLW5hdGl2ZS9ub2RlX21vZHVsZXMvdmlnb3VyLWpzL2Jhc2UvaW5kZXguanMiLCIvVXNlcnMvc2hhd24vV29yay92aWdvdXItbmF0aXZlL25vZGVfbW9kdWxlcy92aWdvdXItanMvYmFzZS9zZXR0aW5ncy5qcyIsIi9Vc2Vycy9zaGF3bi9Xb3JrL3ZpZ291ci1uYXRpdmUvbm9kZV9tb2R1bGVzL3ZpZ291ci1qcy9icm93c2VyL2FuaW1hdGlvbi9yYWYuanMiLCIvVXNlcnMvc2hhd24vV29yay92aWdvdXItbmF0aXZlL25vZGVfbW9kdWxlcy92aWdvdXItanMvYnJvd3Nlci9jYXNlcy9iYXNlLmpzIiwiL1VzZXJzL3NoYXduL1dvcmsvdmlnb3VyLW5hdGl2ZS9ub2RlX21vZHVsZXMvdmlnb3VyLWpzL2Jyb3dzZXIvY2FzZXMvaW5kZXguanMiLCIvVXNlcnMvc2hhd24vV29yay92aWdvdXItbmF0aXZlL25vZGVfbW9kdWxlcy92aWdvdXItanMvYnJvd3Nlci9jYXNlcy9vYmplY3QuanMiLCIvVXNlcnMvc2hhd24vV29yay92aWdvdXItbmF0aXZlL25vZGVfbW9kdWxlcy92aWdvdXItanMvYnJvd3Nlci9jc3MuanMiLCIvVXNlcnMvc2hhd24vV29yay92aWdvdXItbmF0aXZlL25vZGVfbW9kdWxlcy92aWdvdXItanMvYnJvd3Nlci9lbGVtZW50L2luZGV4LmpzIiwiL1VzZXJzL3NoYXduL1dvcmsvdmlnb3VyLW5hdGl2ZS9ub2RlX21vZHVsZXMvdmlnb3VyLWpzL2Jyb3dzZXIvZWxlbWVudC9wcm9wZXJ0aWVzL2NvbGxlY3Rpb24vaW5kZXguanMiLCIvVXNlcnMvc2hhd24vV29yay92aWdvdXItbmF0aXZlL25vZGVfbW9kdWxlcy92aWdvdXItanMvYnJvd3Nlci9lbGVtZW50L3Byb3BlcnRpZXMvY29sbGVjdGlvbi91dGlsLmpzIiwiL1VzZXJzL3NoYXduL1dvcmsvdmlnb3VyLW5hdGl2ZS9ub2RlX21vZHVsZXMvdmlnb3VyLWpzL2Jyb3dzZXIvZWxlbWVudC9wcm9wZXJ0aWVzL2RhdGEuanMiLCIvVXNlcnMvc2hhd24vV29yay92aWdvdXItbmF0aXZlL25vZGVfbW9kdWxlcy92aWdvdXItanMvYnJvd3Nlci9lbGVtZW50L3Byb3BlcnRpZXMvaW5kZXguanMiLCIvVXNlcnMvc2hhd24vV29yay92aWdvdXItbmF0aXZlL25vZGVfbW9kdWxlcy92aWdvdXItanMvYnJvd3Nlci9lbGVtZW50L3Byb3BlcnRpZXMvcHJvY2Vzcy5qcyIsIi9Vc2Vycy9zaGF3bi9Xb3JrL3ZpZ291ci1uYXRpdmUvbm9kZV9tb2R1bGVzL3ZpZ291ci1qcy9icm93c2VyL2VsZW1lbnQvcHJvcGVydGllcy9zY3JvbGxiYXIuanMiLCIvVXNlcnMvc2hhd24vV29yay92aWdvdXItbmF0aXZlL25vZGVfbW9kdWxlcy92aWdvdXItanMvYnJvd3Nlci9lbGVtZW50L3NldC5qcyIsIi9Vc2Vycy9zaGF3bi9Xb3JrL3ZpZ291ci1uYXRpdmUvbm9kZV9tb2R1bGVzL3ZpZ291ci1qcy9icm93c2VyL2V2ZW50cy9iYXNpYy5qcyIsIi9Vc2Vycy9zaGF3bi9Xb3JrL3ZpZ291ci1uYXRpdmUvbm9kZV9tb2R1bGVzL3ZpZ291ci1qcy9icm93c2VyL2V2ZW50cy9pbmRleC5qcyIsIi9Vc2Vycy9zaGF3bi9Xb3JrL3ZpZ291ci1uYXRpdmUvbm9kZV9tb2R1bGVzL3ZpZ291ci1qcy9icm93c2VyL25ldHdvcmsvYWpheC5qcyIsIi9Vc2Vycy9zaGF3bi9Xb3JrL3ZpZ291ci1uYXRpdmUvbm9kZV9tb2R1bGVzL3ZpZ291ci1qcy9icm93c2VyL3VhLmpzIiwiL1VzZXJzL3NoYXduL1dvcmsvdmlnb3VyLW5hdGl2ZS9ub2RlX21vZHVsZXMvdmlnb3VyLWpzL2RhdGEvYmFzZS5qcyIsIi9Vc2Vycy9zaGF3bi9Xb3JrL3ZpZ291ci1uYXRpdmUvbm9kZV9tb2R1bGVzL3ZpZ291ci1qcy9kYXRhL2NvbmRpdGlvbnMuanMiLCIvVXNlcnMvc2hhd24vV29yay92aWdvdXItbmF0aXZlL25vZGVfbW9kdWxlcy92aWdvdXItanMvZGF0YS9pbmRleC5qcyIsIi9Vc2Vycy9zaGF3bi9Xb3JrL3ZpZ291ci1uYXRpdmUvbm9kZV9tb2R1bGVzL3ZpZ291ci1qcy9kYXRhL3NlbGVjdGlvbi5qcyIsIi9Vc2Vycy9zaGF3bi9Xb3JrL3ZpZ291ci1uYXRpdmUvbm9kZV9tb2R1bGVzL3ZpZ291ci1qcy9pbmRleC5qcyIsIi9Vc2Vycy9zaGF3bi9Xb3JrL3ZpZ291ci1uYXRpdmUvbm9kZV9tb2R1bGVzL3ZpZ291ci1qcy9vYmplY3QvYXJyYXkuanMiLCIvVXNlcnMvc2hhd24vV29yay92aWdvdXItbmF0aXZlL25vZGVfbW9kdWxlcy92aWdvdXItanMvb2JqZWN0L2ZsYWdzLmpzIiwiL1VzZXJzL3NoYXduL1dvcmsvdmlnb3VyLW5hdGl2ZS9ub2RlX21vZHVsZXMvdmlnb3VyLWpzL29iamVjdC9pbmRleC5qcyIsIi9Vc2Vycy9zaGF3bi9Xb3JrL3ZpZ291ci1uYXRpdmUvbm9kZV9tb2R1bGVzL3ZpZ291ci1qcy9vYmplY3QvbGlzdGVuLmpzIiwiL1VzZXJzL3NoYXduL1dvcmsvdmlnb3VyLW5hdGl2ZS9ub2RlX21vZHVsZXMvdmlnb3VyLWpzL29iamVjdC91dGlsLmpzIiwiL1VzZXJzL3NoYXduL1dvcmsvdmlnb3VyLW5hdGl2ZS9ub2RlX21vZHVsZXMvdmlnb3VyLWpzL3VpL2VsZW1lbnQvaW5kZXguanMiLCIvVXNlcnMvc2hhd24vV29yay92aWdvdXItbmF0aXZlL25vZGVfbW9kdWxlcy92aWdvdXItanMvdXRpbC9oYXNoLmpzIiwiL1VzZXJzL3NoYXduL1dvcmsvdmlnb3VyLW5hdGl2ZS9ub2RlX21vZHVsZXMvdmlnb3VyLWpzL3V0aWwvaW5kZXguanMiLCIvVXNlcnMvc2hhd24vV29yay92aWdvdXItbmF0aXZlL25vZGVfbW9kdWxlcy92aWdvdXItanMvdXRpbC9pbmplY3QuanMiLCIvVXNlcnMvc2hhd24vV29yay92aWdvdXItbmF0aXZlL25vZGVfbW9kdWxlcy92aWdvdXItanMvdXRpbC9vYmplY3QuanMiLCIvVXNlcnMvc2hhd24vV29yay92aWdvdXItbmF0aXZlL25vZGVfbW9kdWxlcy92aWdvdXItanMvdXRpbC9wcm9jZXNzLmpzIiwiL1VzZXJzL3NoYXduL1dvcmsvdmlnb3VyLW5hdGl2ZS9ub2RlX21vZHVsZXMvdmlnb3VyLWpzL3V0aWwvcHJvcC5qcyIsIi9Vc2Vycy9zaGF3bi9Xb3JrL3ZpZ291ci1uYXRpdmUvbm9kZV9tb2R1bGVzL3ZpZ291ci1qcy92YWx1ZS9iYXNlLmpzIiwiL1VzZXJzL3NoYXduL1dvcmsvdmlnb3VyLW5hdGl2ZS9ub2RlX21vZHVsZXMvdmlnb3VyLWpzL3ZhbHVlL2ZsYWdzL2RhdGEuanMiLCIvVXNlcnMvc2hhd24vV29yay92aWdvdXItbmF0aXZlL25vZGVfbW9kdWxlcy92aWdvdXItanMvdmFsdWUvZmxhZ3MvaW5kZXguanMiLCIvVXNlcnMvc2hhd24vV29yay92aWdvdXItbmF0aXZlL25vZGVfbW9kdWxlcy92aWdvdXItanMvdmFsdWUvZmxhZ3MvcGFyZW50LmpzIiwiL1VzZXJzL3NoYXduL1dvcmsvdmlnb3VyLW5hdGl2ZS9ub2RlX21vZHVsZXMvdmlnb3VyLWpzL3ZhbHVlL2ZsYWdzL3Byb2Nlc3MuanMiLCIvVXNlcnMvc2hhd24vV29yay92aWdvdXItbmF0aXZlL25vZGVfbW9kdWxlcy92aWdvdXItanMvdmFsdWUvZmxhZ3Mvc2VsZi5qcyIsIi9Vc2Vycy9zaGF3bi9Xb3JrL3ZpZ291ci1uYXRpdmUvbm9kZV9tb2R1bGVzL3ZpZ291ci1qcy92YWx1ZS9mbGFncy91dGlsLmpzIiwiL1VzZXJzL3NoYXduL1dvcmsvdmlnb3VyLW5hdGl2ZS9ub2RlX21vZHVsZXMvdmlnb3VyLWpzL3ZhbHVlL2luZGV4LmpzIiwiL1VzZXJzL3NoYXduL1dvcmsvdmlnb3VyLW5hdGl2ZS9ub2RlX21vZHVsZXMvdmlnb3VyLWpzL3ZhbHVlL29uLmpzIiwiL1VzZXJzL3NoYXduL1dvcmsvdmlnb3VyLW5hdGl2ZS9ub2RlX21vZHVsZXMvdmlnb3VyLWpzL3ZhbHVlL29wZXJhdG9ycy5qcyIsIi9Vc2Vycy9zaGF3bi9ucG0vbGliL25vZGVfbW9kdWxlcy9nYXN0b24vbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL3Byb2Nlc3MvYnJvd3Nlci5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQ0FBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5SkE7O0FDQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDbkZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6R0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNiQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1R0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQy9EQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUNqSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMVVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2UUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdGFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9KQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1SkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25hQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaEpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2VEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZRQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbFNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyeEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlUQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDampCQTtBQUNBOztBQ0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNUQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hYQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0YkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbG9CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5R0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNySEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25hQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDak5BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbFJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2aUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZSQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiJnZW5lcmF0ZWQuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uIGUodCxuLHIpe2Z1bmN0aW9uIHMobyx1KXtpZighbltvXSl7aWYoIXRbb10pe3ZhciBhPXR5cGVvZiByZXF1aXJlPT1cImZ1bmN0aW9uXCImJnJlcXVpcmU7aWYoIXUmJmEpcmV0dXJuIGEobywhMCk7aWYoaSlyZXR1cm4gaShvLCEwKTt2YXIgZj1uZXcgRXJyb3IoXCJDYW5ub3QgZmluZCBtb2R1bGUgJ1wiK28rXCInXCIpO3Rocm93IGYuY29kZT1cIk1PRFVMRV9OT1RfRk9VTkRcIixmfXZhciBsPW5bb109e2V4cG9ydHM6e319O3Rbb11bMF0uY2FsbChsLmV4cG9ydHMsZnVuY3Rpb24oZSl7dmFyIG49dFtvXVsxXVtlXTtyZXR1cm4gcyhuP246ZSl9LGwsbC5leHBvcnRzLGUsdCxuLHIpfXJldHVybiBuW29dLmV4cG9ydHN9dmFyIGk9dHlwZW9mIHJlcXVpcmU9PVwiZnVuY3Rpb25cIiYmcmVxdWlyZTtmb3IodmFyIG89MDtvPHIubGVuZ3RoO28rKylzKHJbb10pO3JldHVybiBzfSkiLCJyZXF1aXJlKCcuL3N0eWxlcy5sZXNzJylcbnZhciBicmlkZ2UgPSByZXF1aXJlKCcuLi8uLi8uLi9saWIvYnJpZGdlJylcbiAgLCBFbGVtZW50ID0gcmVxdWlyZSgndmlnb3VyLWpzL3VpL2VsZW1lbnQnKVxuXG52YXIgYXBwID0gbmV3IEVsZW1lbnQoe1xuICBub2RlOiBkb2N1bWVudC5ib2R5XG4gICwgaGVhZGVyOlxuICB7XG4gICAgbm9kZTogJ2gxJ1xuICAgICwgdGV4dDogXCJUZXN0aW5nIHRoZSBuYXRpdmUgYnJpZGdlXCJcbiAgfVxuICAsIHdlcmY6XG4gIHsgbm9kZTogJ2J1dHRvbidcbiAgICAsIHRleHQ6IFwidGFwIG1lXCJcbiAgICAsIGV2ZW50czpcbiAgICB7IGNsaWNrOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGRvU29tZSgpXG4gICAgICB9XG4gICAgfVxuICB9XG4gICwgdDE6XG4gIHtcbiAgICBub2RlOiAnYnV0dG9uJ1xuICAgICwgdGV4dDogXCJzZW5kICd0ZXN0IG1lc3NhZ2UnXCJcbiAgICAsIGV2ZW50czpcbiAgICB7XG4gICAgICBjbGljazogZnVuY3Rpb24gKCkge1xuICAgICAgICB0ZXN0T25lV2F5KCd0ZXN0IG1lc3NhZ2UnKVxuICAgICAgfVxuICAgIH1cbiAgfVxuICAsIHQyOlxuICB7XG4gICAgbm9kZTogJ2J1dHRvbidcbiAgICAsIHRleHQ6IFwiZHVtbXkvZHVtbXkoKVwiXG4gICAgLCBldmVudHM6XG4gICAge1xuICAgICAgY2xpY2s6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGVzdFNpbXBsZSgpXG4gICAgICB9XG4gICAgfVxuICB9XG4gICwgdDM6XG4gIHtcbiAgICBub2RlOiAnYnV0dG9uJ1xuICAgICwgdGV4dDogXCJzdGF0dXNiYXIvaGlkZSgpXCJcbiAgICAsIGV2ZW50czpcbiAgICB7XG4gICAgICAgY2xpY2s6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGVzdFNpbXBsZSgnc3RhdHVzYmFyJywnaGlkZScpXG4gICAgICB9XG4gICAgfVxuICB9XG4gICwgdDQ6XG4gIHtcbiAgICBub2RlOiAnYnV0dG9uJ1xuICAgICwgdGV4dDogXCJzdGF0dXNiYXIvc2hvdygpXCJcbiAgICAsIGV2ZW50czpcbiAgICB7XG4gICAgICAgY2xpY2s6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGVzdFNpbXBsZSgnc3RhdHVzYmFyJywnc2hvdycpXG4gICAgICB9XG4gICAgfVxuICB9XG4gICwgdDU6XG4gIHtcbiAgICBub2RlOiAnYnV0dG9uJ1xuICAgICwgdGV4dDogXCJ0ZXN0L2xvZygndGVzdCBsb2cgbWVzc2FnZScpXCJcbiAgICAsIGV2ZW50czpcbiAgICB7XG4gICAgICAgY2xpY2s6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGVzdFNpbXBsZSgndGVzdCcsICdsb2cnLCAndGVzdCBsb2cgbWVzc2FnZScpXG4gICAgICB9XG4gICAgfVxuICB9XG4gICwgdDY6XG4gIHtcbiAgICBub2RlOiAnYnV0dG9uJ1xuICAgICwgdGV4dDogXCJ0ZXN0L2VjaG8oJ3Rlc3QgZWNobyBtZXNzYWdlJylcIlxuICAgICwgZXZlbnRzOlxuICAgIHtcbiAgICAgICBjbGljazogZnVuY3Rpb24gKCkge1xuICAgICAgICB0ZXN0U2ltcGxlKCd0ZXN0JywgJ2VjaG8nLCAndGVzdCBlY2hvIG1lc3NhZ2UnKVxuICAgICAgfVxuICAgIH1cbiAgfVxuICAsIHQ3OlxuICB7XG4gICAgbm9kZTogJ2J1dHRvbidcbiAgICAsIHRleHQ6IFwidGVzdC92aWJyYXRlKClcIlxuICAgICwgZXZlbnRzOlxuICAgIHtcbiAgICAgICBjbGljazogZnVuY3Rpb24gKCkge1xuICAgICAgICB0ZXN0U2ltcGxlKCd0ZXN0JywgJ3ZpYnJhdGUnKVxuICAgICAgfVxuICAgIH1cbiAgfVxuICAsIHQ4OlxuICB7XG4gICAgbm9kZTogJ2J1dHRvbidcbiAgICAsIHRleHQ6IFwidGVzdC9nZXRUaW1lKClcIlxuICAgICwgZXZlbnRzOlxuICAgIHtcbiAgICAgICBjbGljazogZnVuY3Rpb24gKCkge1xuICAgICAgICB0ZXN0U2ltcGxlKCd0ZXN0JywgJ2dldFRpbWUnKVxuICAgICAgfVxuICAgIH1cbiAgfVxuICAsIGNvbnRhaW5lcjpcbiAge1xuICAgIGF0dHI6IHsgaWQ6IFwiY29udGFpbmVyXCIgfVxuICB9XG59KVxuXG5mdW5jdGlvbiBkb1NvbWUoKSB7XG4gIHZhciBkaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKVxuICBkaXYuaW5uZXJIVE1MID0gXCJ0YXAgdGFwXCJcbiAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChkaXYpXG4gIHRyeSB7XG4gICAgd2luZG93LndlYmtpdC5tZXNzYWdlSGFuZGxlcnMudmlnb3VyQnJpZGdlSGFuZGxlci5wb3N0TWVzc2FnZShbMSwyLDNdKVxuICAgIHdpbmRvdy53ZWJraXQubWVzc2FnZUhhbmRsZXJzLnZpZ291ckJyaWRnZUhhbmRsZXIucG9zdE1lc3NhZ2Uoe1wiYVwiOlsxLDJdLCBcImJcIjpcImNcIn0pXG4gICAgLy9pZ25vcmVzIGZ1bmNzIHBhc3NpbmdcbiAgICB3aW5kb3cud2Via2l0Lm1lc3NhZ2VIYW5kbGVycy52aWdvdXJCcmlkZ2VIYW5kbGVyLnBvc3RNZXNzYWdlKHtcImFcIjpbMSwyXSwgXCJiXCI6ZnVuY3Rpb24oKXtyZXR1cm4gMX19KVxuICB9IGNhdGNoKGVycikge1xuICAgIGNvbnNvbGUubG9nKCdUaGUgbmF0aXZlIGNvbnRleHQgZG9lcyBub3QgZXhpc3QgeWV0Jyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gdGVzdFNlbmQgKG1zZykge1xuICBicmlkZ2Uuc2VuZChtc2cpXG59XG5mdW5jdGlvbiB0ZXN0T25lV2F5IChtZXNzYWdlKSB7XG4gICAgd3JhcFRyeSh0ZXN0U2VuZCkobWVzc2FnZSlcbn1cblxuZnVuY3Rpb24gdGVzdFNpbXBsZSAoKSB7XG4gICAgdmFyIHBsdWdpbiA9IGFyZ3VtZW50c1swXSB8fCAnZHVtbXknXG4gICAgdmFyIGZuTmFtZSA9IGFyZ3VtZW50c1sxXSB8fCAnZHVtbXknXG4gICAgdmFyIGFyZ3MgPSBhcmd1bWVudHNbMl0gfHwgW11cbiAgICB3cmFwVHJ5KGNhbGxOYXRpdmUpKHBsdWdpbiwgZm5OYW1lLCBhcmdzLCBmdW5jdGlvbihlcnJvciwgdmFsdWUpIHtcbiAgICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgICAgICBhZGRUb0RvbShcImVycm9yOiBcIiArIGVycm9yKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYWRkVG9Eb20oXCJzdWNjZXNzITogXCIgKyB2YWx1ZSlcbiAgICAgICAgfVxuICAgIH0pXG5cbn1cblxuZnVuY3Rpb24gd3JhcFRyeSAoZm4pIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHRyeXtcbiAgICAgIGZuLmFwcGx5KGZuLCBhcmd1bWVudHMpXG4gICAgfSBjYXRjaChlKSB7XG4gICAgICBicmlkZ2UuYWRkVG9Eb20oXCJleGNlcHRpb246IFwiICsgZSlcbiAgICB9XG4gIH1cbn1cbiIsbnVsbCwidmFyIGJyaWRnZSA9IHJlcXVpcmUoJy4uLycpXG5cbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0cyA9IHt9XG4vKipcbiAgd2lsIHNlbmQgYSBtZXNzYWdlIHRvIHRoZSBuYXRpdmUgc2lkZSBhbmQgcmV0dXJucyBpbW1lZGlhdGVseVxuXG4gIEBwYXJhbSB7T2JqZWN0fSBtZXNzYWdlXG4qKi9cbmV4cG9ydHMuc2VuZCA9IGZ1bmN0aW9uIChtZXNzYWdlKSB7XG4gIE5hdGl2ZUludGVyZmFjZS5zZW5kKEpTT04uc3RyaW5naWZ5KG1lc3NhZ2UpKVxufVxuXG4vKipcbiAqIGNhbGxlZCBieSB0aGUgYW5kcm9pZCBjb3VudGVycGFydFxuICogZXhwZWN0cyBhIHNlcmlhbGlzZWQgYXJyYXkgd2l0aCBbaWQscmVzdWx0LGVycm9yXVxuKiovXG5leHBvcnRzLnJlY2VpdmVSZXN1bHQgPSBmdW5jdGlvbiAoaWQsIHJlc3VsdCkge1xuICByZWNlaXZlTmF0aXZlUmVzdWx0KGlkLCByZXN1bHQpXG59XG53aW5kb3cucmVjZWl2ZUFuZHJvaWRSZXN1bHQgPSBleHBvcnRzLnJlY2VpdmVSZXN1bHRcblxuXG5leHBvcnRzLnJlY2VpdmVFcnJvciA9IGZ1bmN0aW9uIChpZCwgZXJyb3IpIHtcbiAgcmVjZWl2ZU5hdGl2ZUVycm9yKGlkLCBlcnJvcilcbn1cbndpbmRvdy5yZWNlaXZlQW5kcm9pZEVycm9yID0gZXhwb3J0cy5yZWNlaXZlRXJyb3IiLCJ2YXIgUHJvbWlzZSA9IHJlcXVpcmUoJ3Byb21pc2UnKVxuICAsIHVhID0gcmVxdWlyZSgndmlnb3VyLWpzL2Jyb3dzZXIvdWEnKVxuICAsIGJyaWRnZXMgPSB7XG4gICAgYW5kcm9pZDogcmVxdWlyZSgnLi9hbmRyb2lkJylcbiAgICAsIGlvczogcmVxdWlyZSgnLi9pb3MnKSAgXG4gIH1cbiAgLCBtZXNzYWdlSWQgPSAxXG4gICwgY2FsbGJhY2tNYXAgPSB7fVxuICAsIGVycm9yXG5cbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0cyA9IHt9XG5cbmNvbnNvbGUubG9nKCdwbGF0Zm9ybScsIHVhLnBsYXRmb3JtKVxuXG5pZiAoYnJpZGdlc1t1YS5wbGF0Zm9ybV0pIHtcbiAgZXhwb3J0cy5zZW5kID0gYnJpZGdlc1t1YS5wbGF0Zm9ybV0uc2VuZFxuICBleHBvcnRzLnJlY2VpdmVSZXN1bHQgPSBicmlkZ2VzW3VhLnBsYXRmb3JtXS5yZWNlaXZlUmVzdWx0XG4gIGV4cG9ydHMucmVjZWl2ZUVycm9yID0gYnJpZGdlc1t1YS5wbGF0Zm9ybV0ucmVjZWl2ZUVycm9yXG59IGVsc2Uge1xuICBlcnJvciA9IG5ldyBFcnJvcihcIlVuc3VwcG9ydGVkIHBsYXRmb3JtXCIpXG4gIGVycm9yLnJlcXVlc3RlZFBsYXRmb3JtID0gdWEucGxhdGZvcm1cbiAgZXJyb3IuYXZhaWxhYmxlUGxhdG9mcm1zID0gT2JqZWN0LmtleXMoYnJpZGdlcykuam9pbignLCcpXG4gIGNvbnNvbGUuZXJyb3IoZXJyb3IpXG59XG5cbi8qKlxuICBjYWxsIGEgZnVuY3Rpb24gaW4gYSBuYXRpdmUgcGx1Z2luXG4gIEBwYXJhbSB7U3RyaW5nfSBwbHVnaW5JZFxuICBAcGFyYW0ge1N0cmluZ30gZm5OYW1lXG4gIEBwYXJhbSB7T2JqZWN0fSBwYXJhbXNcbiAgQHBhcmFtIHtGdW5jdGlvbihlcnIsIHZhbHVlKX0gY2JcbiAqKi9cbmV4cG9ydHMuY2FsbCA9IGZ1bmN0aW9uIChwbHVnaW5JZCwgZm5OYW1lLCBwYXJhbXMsIGNiKSB7XG4gIHZhciBpZCA9IG1lc3NhZ2VJZCsrXG4gIGNhbGxiYWNrTWFwW2lkXSA9IGNiXG4gIGV4cG9ydHMuc2VuZChbaWQsIHBsdWdpbklkLCBmbk5hbWUsIHBhcmFtc10pXG59XG53aW5kb3cuY2FsbE5hdGl2ZSA9IGV4cG9ydHMuY2FsbFxuXG5leHBvcnRzLnBvcENhbGxiYWNrID0gZnVuY3Rpb24gKGlkKSB7XG4gIGlmICghY2FsbGJhY2tNYXBbaWRdKSB7XG4gICAgZXhwb3J0cy5hZGRUb0RvbShcImlsbGVnYWwgaWQ6IFwiK2lkKSBcbiAgICByZXR1cm5cbiAgfVxuICB2YXIgY2IgPSBjYWxsYmFja01hcFtpZF1cbiAgZGVsZXRlIGNhbGxiYWNrTWFwW2lkXVxuICByZXR1cm4gY2Jcbn1cblxuZXhwb3J0cy5yZWNlaXZlTmF0aXZlUmVzdWx0ID0gZnVuY3Rpb24gKGlkLCByZXN1bHQpIHtcbiAgdmFyIGNiID0gZXhwb3J0cy5wb3BDYWxsYmFjayhpZClcbiAgaWYgKGNiKSB7XG4gICAgY2IobnVsbCwgcmVzdWx0KVxuICB9IGVsc2Uge1xuICAgIGV4cG9ydHMuYWRkVG9Eb20oXCJyZXN1bHQgd2l0aG91dCBjYjogXCIgKyBlcnJvcilcbiAgfVxufVxud2luZG93LnJlY2VpdmVOYXRpdmVSZXN1bHQgPSBleHBvcnRzLnJlY2VpdmVOYXRpdmVSZXN1bHRcblxuZXhwb3J0cy5yZWNlaXZlTmF0aXZlRXJyb3IgPSBmdW5jdGlvbiAoaWQsIGVycm9yKSB7XG4gIHZhciBjYiA9IGV4cG9ydHMucG9wQ2FsbGJhY2soaWQpXG4gIGlmIChjYikge1xuICAgIGNiKGVycm9yKVxuICB9IGVsc2Uge1xuICAgIGV4cG9ydHMuYWRkVG9Eb20oXCJlcnJvciB3aXRob3V0IGNiOiBcIiArIGVycm9yKVxuICB9XG59XG53aW5kb3cucmVjZWl2ZU5hdGl2ZUVycm9yID0gZXhwb3J0cy5yZWNlaXZlTmF0aXZlRXJyb3JcblxuZXhwb3J0cy5hZGRUb0RvbSA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgdmFyIHAgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdwJylcbiAgICBwLnNldEF0dHJpYnV0ZSgnY2xhc3MnLCAnZGVidWctb3V0cHV0JylcbiAgICBwLmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKGRhdGEpKVxuICAgIHZhciBjb250YWluZXIgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnY29udGFpbmVyJyk7XG4gICAgaWYgKGNvbnRhaW5lci5maXJzdENoaWxkKSB7XG4gICAgICAgIGNvbnRhaW5lci5pbnNlcnRCZWZvcmUocCwgY29udGFpbmVyLmZpcnN0Q2hpbGQpXG4gICAgfSBlbHNlIHtcbiAgICAgICAgY29udGFpbmVyLmFwcGVuZENoaWxkKHApXG4gICAgfVxufVxud2luZG93LmFkZFRvRG9tID0gZXhwb3J0cy5hZGRUb0RvbVxuXG5cbiIsIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2xpYi9jb3JlLmpzJylcbnJlcXVpcmUoJy4vbGliL2RvbmUuanMnKVxucmVxdWlyZSgnLi9saWIvZXM2LWV4dGVuc2lvbnMuanMnKVxucmVxdWlyZSgnLi9saWIvbm9kZS1leHRlbnNpb25zLmpzJykiLCIndXNlIHN0cmljdCc7XG5cbnZhciBhc2FwID0gcmVxdWlyZSgnYXNhcCcpXG5cbm1vZHVsZS5leHBvcnRzID0gUHJvbWlzZTtcbmZ1bmN0aW9uIFByb21pc2UoZm4pIHtcbiAgaWYgKHR5cGVvZiB0aGlzICE9PSAnb2JqZWN0JykgdGhyb3cgbmV3IFR5cGVFcnJvcignUHJvbWlzZXMgbXVzdCBiZSBjb25zdHJ1Y3RlZCB2aWEgbmV3JylcbiAgaWYgKHR5cGVvZiBmbiAhPT0gJ2Z1bmN0aW9uJykgdGhyb3cgbmV3IFR5cGVFcnJvcignbm90IGEgZnVuY3Rpb24nKVxuICB2YXIgc3RhdGUgPSBudWxsXG4gIHZhciB2YWx1ZSA9IG51bGxcbiAgdmFyIGRlZmVycmVkcyA9IFtdXG4gIHZhciBzZWxmID0gdGhpc1xuXG4gIHRoaXMudGhlbiA9IGZ1bmN0aW9uKG9uRnVsZmlsbGVkLCBvblJlamVjdGVkKSB7XG4gICAgcmV0dXJuIG5ldyBzZWxmLmNvbnN0cnVjdG9yKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgaGFuZGxlKG5ldyBIYW5kbGVyKG9uRnVsZmlsbGVkLCBvblJlamVjdGVkLCByZXNvbHZlLCByZWplY3QpKVxuICAgIH0pXG4gIH1cblxuICBmdW5jdGlvbiBoYW5kbGUoZGVmZXJyZWQpIHtcbiAgICBpZiAoc3RhdGUgPT09IG51bGwpIHtcbiAgICAgIGRlZmVycmVkcy5wdXNoKGRlZmVycmVkKVxuICAgICAgcmV0dXJuXG4gICAgfVxuICAgIGFzYXAoZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgY2IgPSBzdGF0ZSA/IGRlZmVycmVkLm9uRnVsZmlsbGVkIDogZGVmZXJyZWQub25SZWplY3RlZFxuICAgICAgaWYgKGNiID09PSBudWxsKSB7XG4gICAgICAgIChzdGF0ZSA/IGRlZmVycmVkLnJlc29sdmUgOiBkZWZlcnJlZC5yZWplY3QpKHZhbHVlKVxuICAgICAgICByZXR1cm5cbiAgICAgIH1cbiAgICAgIHZhciByZXRcbiAgICAgIHRyeSB7XG4gICAgICAgIHJldCA9IGNiKHZhbHVlKVxuICAgICAgfVxuICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgZGVmZXJyZWQucmVqZWN0KGUpXG4gICAgICAgIHJldHVyblxuICAgICAgfVxuICAgICAgZGVmZXJyZWQucmVzb2x2ZShyZXQpXG4gICAgfSlcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlc29sdmUobmV3VmFsdWUpIHtcbiAgICB0cnkgeyAvL1Byb21pc2UgUmVzb2x1dGlvbiBQcm9jZWR1cmU6IGh0dHBzOi8vZ2l0aHViLmNvbS9wcm9taXNlcy1hcGx1cy9wcm9taXNlcy1zcGVjI3RoZS1wcm9taXNlLXJlc29sdXRpb24tcHJvY2VkdXJlXG4gICAgICBpZiAobmV3VmFsdWUgPT09IHNlbGYpIHRocm93IG5ldyBUeXBlRXJyb3IoJ0EgcHJvbWlzZSBjYW5ub3QgYmUgcmVzb2x2ZWQgd2l0aCBpdHNlbGYuJylcbiAgICAgIGlmIChuZXdWYWx1ZSAmJiAodHlwZW9mIG5ld1ZhbHVlID09PSAnb2JqZWN0JyB8fCB0eXBlb2YgbmV3VmFsdWUgPT09ICdmdW5jdGlvbicpKSB7XG4gICAgICAgIHZhciB0aGVuID0gbmV3VmFsdWUudGhlblxuICAgICAgICBpZiAodHlwZW9mIHRoZW4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICBkb1Jlc29sdmUodGhlbi5iaW5kKG5ld1ZhbHVlKSwgcmVzb2x2ZSwgcmVqZWN0KVxuICAgICAgICAgIHJldHVyblxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBzdGF0ZSA9IHRydWVcbiAgICAgIHZhbHVlID0gbmV3VmFsdWVcbiAgICAgIGZpbmFsZSgpXG4gICAgfSBjYXRjaCAoZSkgeyByZWplY3QoZSkgfVxuICB9XG5cbiAgZnVuY3Rpb24gcmVqZWN0KG5ld1ZhbHVlKSB7XG4gICAgc3RhdGUgPSBmYWxzZVxuICAgIHZhbHVlID0gbmV3VmFsdWVcbiAgICBmaW5hbGUoKVxuICB9XG5cbiAgZnVuY3Rpb24gZmluYWxlKCkge1xuICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBkZWZlcnJlZHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspXG4gICAgICBoYW5kbGUoZGVmZXJyZWRzW2ldKVxuICAgIGRlZmVycmVkcyA9IG51bGxcbiAgfVxuXG4gIGRvUmVzb2x2ZShmbiwgcmVzb2x2ZSwgcmVqZWN0KVxufVxuXG5cbmZ1bmN0aW9uIEhhbmRsZXIob25GdWxmaWxsZWQsIG9uUmVqZWN0ZWQsIHJlc29sdmUsIHJlamVjdCl7XG4gIHRoaXMub25GdWxmaWxsZWQgPSB0eXBlb2Ygb25GdWxmaWxsZWQgPT09ICdmdW5jdGlvbicgPyBvbkZ1bGZpbGxlZCA6IG51bGxcbiAgdGhpcy5vblJlamVjdGVkID0gdHlwZW9mIG9uUmVqZWN0ZWQgPT09ICdmdW5jdGlvbicgPyBvblJlamVjdGVkIDogbnVsbFxuICB0aGlzLnJlc29sdmUgPSByZXNvbHZlXG4gIHRoaXMucmVqZWN0ID0gcmVqZWN0XG59XG5cbi8qKlxuICogVGFrZSBhIHBvdGVudGlhbGx5IG1pc2JlaGF2aW5nIHJlc29sdmVyIGZ1bmN0aW9uIGFuZCBtYWtlIHN1cmVcbiAqIG9uRnVsZmlsbGVkIGFuZCBvblJlamVjdGVkIGFyZSBvbmx5IGNhbGxlZCBvbmNlLlxuICpcbiAqIE1ha2VzIG5vIGd1YXJhbnRlZXMgYWJvdXQgYXN5bmNocm9ueS5cbiAqL1xuZnVuY3Rpb24gZG9SZXNvbHZlKGZuLCBvbkZ1bGZpbGxlZCwgb25SZWplY3RlZCkge1xuICB2YXIgZG9uZSA9IGZhbHNlO1xuICB0cnkge1xuICAgIGZuKGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgaWYgKGRvbmUpIHJldHVyblxuICAgICAgZG9uZSA9IHRydWVcbiAgICAgIG9uRnVsZmlsbGVkKHZhbHVlKVxuICAgIH0sIGZ1bmN0aW9uIChyZWFzb24pIHtcbiAgICAgIGlmIChkb25lKSByZXR1cm5cbiAgICAgIGRvbmUgPSB0cnVlXG4gICAgICBvblJlamVjdGVkKHJlYXNvbilcbiAgICB9KVxuICB9IGNhdGNoIChleCkge1xuICAgIGlmIChkb25lKSByZXR1cm5cbiAgICBkb25lID0gdHJ1ZVxuICAgIG9uUmVqZWN0ZWQoZXgpXG4gIH1cbn1cbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIFByb21pc2UgPSByZXF1aXJlKCcuL2NvcmUuanMnKVxudmFyIGFzYXAgPSByZXF1aXJlKCdhc2FwJylcblxubW9kdWxlLmV4cG9ydHMgPSBQcm9taXNlXG5Qcm9taXNlLnByb3RvdHlwZS5kb25lID0gZnVuY3Rpb24gKG9uRnVsZmlsbGVkLCBvblJlamVjdGVkKSB7XG4gIHZhciBzZWxmID0gYXJndW1lbnRzLmxlbmd0aCA/IHRoaXMudGhlbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpIDogdGhpc1xuICBzZWxmLnRoZW4obnVsbCwgZnVuY3Rpb24gKGVycikge1xuICAgIGFzYXAoZnVuY3Rpb24gKCkge1xuICAgICAgdGhyb3cgZXJyXG4gICAgfSlcbiAgfSlcbn0iLCIndXNlIHN0cmljdCc7XG5cbi8vVGhpcyBmaWxlIGNvbnRhaW5zIHRoZSBFUzYgZXh0ZW5zaW9ucyB0byB0aGUgY29yZSBQcm9taXNlcy9BKyBBUElcblxudmFyIFByb21pc2UgPSByZXF1aXJlKCcuL2NvcmUuanMnKVxudmFyIGFzYXAgPSByZXF1aXJlKCdhc2FwJylcblxubW9kdWxlLmV4cG9ydHMgPSBQcm9taXNlXG5cbi8qIFN0YXRpYyBGdW5jdGlvbnMgKi9cblxuZnVuY3Rpb24gVmFsdWVQcm9taXNlKHZhbHVlKSB7XG4gIHRoaXMudGhlbiA9IGZ1bmN0aW9uIChvbkZ1bGZpbGxlZCkge1xuICAgIGlmICh0eXBlb2Ygb25GdWxmaWxsZWQgIT09ICdmdW5jdGlvbicpIHJldHVybiB0aGlzXG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgIGFzYXAoZnVuY3Rpb24gKCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHJlc29sdmUob25GdWxmaWxsZWQodmFsdWUpKVxuICAgICAgICB9IGNhdGNoIChleCkge1xuICAgICAgICAgIHJlamVjdChleCk7XG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgfSlcbiAgfVxufVxuVmFsdWVQcm9taXNlLnByb3RvdHlwZSA9IFByb21pc2UucHJvdG90eXBlXG5cbnZhciBUUlVFID0gbmV3IFZhbHVlUHJvbWlzZSh0cnVlKVxudmFyIEZBTFNFID0gbmV3IFZhbHVlUHJvbWlzZShmYWxzZSlcbnZhciBOVUxMID0gbmV3IFZhbHVlUHJvbWlzZShudWxsKVxudmFyIFVOREVGSU5FRCA9IG5ldyBWYWx1ZVByb21pc2UodW5kZWZpbmVkKVxudmFyIFpFUk8gPSBuZXcgVmFsdWVQcm9taXNlKDApXG52YXIgRU1QVFlTVFJJTkcgPSBuZXcgVmFsdWVQcm9taXNlKCcnKVxuXG5Qcm9taXNlLnJlc29sdmUgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgaWYgKHZhbHVlIGluc3RhbmNlb2YgUHJvbWlzZSkgcmV0dXJuIHZhbHVlXG5cbiAgaWYgKHZhbHVlID09PSBudWxsKSByZXR1cm4gTlVMTFxuICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkgcmV0dXJuIFVOREVGSU5FRFxuICBpZiAodmFsdWUgPT09IHRydWUpIHJldHVybiBUUlVFXG4gIGlmICh2YWx1ZSA9PT0gZmFsc2UpIHJldHVybiBGQUxTRVxuICBpZiAodmFsdWUgPT09IDApIHJldHVybiBaRVJPXG4gIGlmICh2YWx1ZSA9PT0gJycpIHJldHVybiBFTVBUWVNUUklOR1xuXG4gIGlmICh0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnIHx8IHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHRyeSB7XG4gICAgICB2YXIgdGhlbiA9IHZhbHVlLnRoZW5cbiAgICAgIGlmICh0eXBlb2YgdGhlbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UodGhlbi5iaW5kKHZhbHVlKSlcbiAgICAgIH1cbiAgICB9IGNhdGNoIChleCkge1xuICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgcmVqZWN0KGV4KVxuICAgICAgfSlcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbmV3IFZhbHVlUHJvbWlzZSh2YWx1ZSlcbn1cblxuUHJvbWlzZS5hbGwgPSBmdW5jdGlvbiAoYXJyKSB7XG4gIHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJyKVxuXG4gIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgaWYgKGFyZ3MubGVuZ3RoID09PSAwKSByZXR1cm4gcmVzb2x2ZShbXSlcbiAgICB2YXIgcmVtYWluaW5nID0gYXJncy5sZW5ndGhcbiAgICBmdW5jdGlvbiByZXMoaSwgdmFsKSB7XG4gICAgICB0cnkge1xuICAgICAgICBpZiAodmFsICYmICh0eXBlb2YgdmFsID09PSAnb2JqZWN0JyB8fCB0eXBlb2YgdmFsID09PSAnZnVuY3Rpb24nKSkge1xuICAgICAgICAgIHZhciB0aGVuID0gdmFsLnRoZW5cbiAgICAgICAgICBpZiAodHlwZW9mIHRoZW4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHRoZW4uY2FsbCh2YWwsIGZ1bmN0aW9uICh2YWwpIHsgcmVzKGksIHZhbCkgfSwgcmVqZWN0KVxuICAgICAgICAgICAgcmV0dXJuXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGFyZ3NbaV0gPSB2YWxcbiAgICAgICAgaWYgKC0tcmVtYWluaW5nID09PSAwKSB7XG4gICAgICAgICAgcmVzb2x2ZShhcmdzKTtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZXgpIHtcbiAgICAgICAgcmVqZWN0KGV4KVxuICAgICAgfVxuICAgIH1cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyZ3MubGVuZ3RoOyBpKyspIHtcbiAgICAgIHJlcyhpLCBhcmdzW2ldKVxuICAgIH1cbiAgfSlcbn1cblxuUHJvbWlzZS5yZWplY3QgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHsgXG4gICAgcmVqZWN0KHZhbHVlKTtcbiAgfSk7XG59XG5cblByb21pc2UucmFjZSA9IGZ1bmN0aW9uICh2YWx1ZXMpIHtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHsgXG4gICAgdmFsdWVzLmZvckVhY2goZnVuY3Rpb24odmFsdWUpe1xuICAgICAgUHJvbWlzZS5yZXNvbHZlKHZhbHVlKS50aGVuKHJlc29sdmUsIHJlamVjdCk7XG4gICAgfSlcbiAgfSk7XG59XG5cbi8qIFByb3RvdHlwZSBNZXRob2RzICovXG5cblByb21pc2UucHJvdG90eXBlWydjYXRjaCddID0gZnVuY3Rpb24gKG9uUmVqZWN0ZWQpIHtcbiAgcmV0dXJuIHRoaXMudGhlbihudWxsLCBvblJlamVjdGVkKTtcbn1cbiIsIid1c2Ugc3RyaWN0JztcblxuLy9UaGlzIGZpbGUgY29udGFpbnMgdGhlbi9wcm9taXNlIHNwZWNpZmljIGV4dGVuc2lvbnMgdGhhdCBhcmUgb25seSB1c2VmdWwgZm9yIG5vZGUuanMgaW50ZXJvcFxuXG52YXIgUHJvbWlzZSA9IHJlcXVpcmUoJy4vY29yZS5qcycpXG52YXIgYXNhcCA9IHJlcXVpcmUoJ2FzYXAnKVxuXG5tb2R1bGUuZXhwb3J0cyA9IFByb21pc2VcblxuLyogU3RhdGljIEZ1bmN0aW9ucyAqL1xuXG5Qcm9taXNlLmRlbm9kZWlmeSA9IGZ1bmN0aW9uIChmbiwgYXJndW1lbnRDb3VudCkge1xuICBhcmd1bWVudENvdW50ID0gYXJndW1lbnRDb3VudCB8fCBJbmZpbml0eVxuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIHZhciBzZWxmID0gdGhpc1xuICAgIHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKVxuICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICB3aGlsZSAoYXJncy5sZW5ndGggJiYgYXJncy5sZW5ndGggPiBhcmd1bWVudENvdW50KSB7XG4gICAgICAgIGFyZ3MucG9wKClcbiAgICAgIH1cbiAgICAgIGFyZ3MucHVzaChmdW5jdGlvbiAoZXJyLCByZXMpIHtcbiAgICAgICAgaWYgKGVycikgcmVqZWN0KGVycilcbiAgICAgICAgZWxzZSByZXNvbHZlKHJlcylcbiAgICAgIH0pXG4gICAgICB2YXIgcmVzID0gZm4uYXBwbHkoc2VsZiwgYXJncylcbiAgICAgIGlmIChyZXMgJiYgKHR5cGVvZiByZXMgPT09ICdvYmplY3QnIHx8IHR5cGVvZiByZXMgPT09ICdmdW5jdGlvbicpICYmIHR5cGVvZiByZXMudGhlbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICByZXNvbHZlKHJlcylcbiAgICAgIH1cbiAgICB9KVxuICB9XG59XG5Qcm9taXNlLm5vZGVpZnkgPSBmdW5jdGlvbiAoZm4pIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cylcbiAgICB2YXIgY2FsbGJhY2sgPSB0eXBlb2YgYXJnc1thcmdzLmxlbmd0aCAtIDFdID09PSAnZnVuY3Rpb24nID8gYXJncy5wb3AoKSA6IG51bGxcbiAgICB2YXIgY3R4ID0gdGhpc1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKS5ub2RlaWZ5KGNhbGxiYWNrLCBjdHgpXG4gICAgfSBjYXRjaCAoZXgpIHtcbiAgICAgIGlmIChjYWxsYmFjayA9PT0gbnVsbCB8fCB0eXBlb2YgY2FsbGJhY2sgPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHsgcmVqZWN0KGV4KSB9KVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYXNhcChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgY2FsbGJhY2suY2FsbChjdHgsIGV4KVxuICAgICAgICB9KVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5Qcm9taXNlLnByb3RvdHlwZS5ub2RlaWZ5ID0gZnVuY3Rpb24gKGNhbGxiYWNrLCBjdHgpIHtcbiAgaWYgKHR5cGVvZiBjYWxsYmFjayAhPSAnZnVuY3Rpb24nKSByZXR1cm4gdGhpc1xuXG4gIHRoaXMudGhlbihmdW5jdGlvbiAodmFsdWUpIHtcbiAgICBhc2FwKGZ1bmN0aW9uICgpIHtcbiAgICAgIGNhbGxiYWNrLmNhbGwoY3R4LCBudWxsLCB2YWx1ZSlcbiAgICB9KVxuICB9LCBmdW5jdGlvbiAoZXJyKSB7XG4gICAgYXNhcChmdW5jdGlvbiAoKSB7XG4gICAgICBjYWxsYmFjay5jYWxsKGN0eCwgZXJyKVxuICAgIH0pXG4gIH0pXG59XG4iLCJcbi8vIFVzZSB0aGUgZmFzdGVzdCBwb3NzaWJsZSBtZWFucyB0byBleGVjdXRlIGEgdGFzayBpbiBhIGZ1dHVyZSB0dXJuXG4vLyBvZiB0aGUgZXZlbnQgbG9vcC5cblxuLy8gbGlua2VkIGxpc3Qgb2YgdGFza3MgKHNpbmdsZSwgd2l0aCBoZWFkIG5vZGUpXG52YXIgaGVhZCA9IHt0YXNrOiB2b2lkIDAsIG5leHQ6IG51bGx9O1xudmFyIHRhaWwgPSBoZWFkO1xudmFyIGZsdXNoaW5nID0gZmFsc2U7XG52YXIgcmVxdWVzdEZsdXNoID0gdm9pZCAwO1xudmFyIGlzTm9kZUpTID0gZmFsc2U7XG5cbmZ1bmN0aW9uIGZsdXNoKCkge1xuICAgIC8qIGpzaGludCBsb29wZnVuYzogdHJ1ZSAqL1xuXG4gICAgd2hpbGUgKGhlYWQubmV4dCkge1xuICAgICAgICBoZWFkID0gaGVhZC5uZXh0O1xuICAgICAgICB2YXIgdGFzayA9IGhlYWQudGFzaztcbiAgICAgICAgaGVhZC50YXNrID0gdm9pZCAwO1xuICAgICAgICB2YXIgZG9tYWluID0gaGVhZC5kb21haW47XG5cbiAgICAgICAgaWYgKGRvbWFpbikge1xuICAgICAgICAgICAgaGVhZC5kb21haW4gPSB2b2lkIDA7XG4gICAgICAgICAgICBkb21haW4uZW50ZXIoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB0YXNrKCk7XG5cbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgaWYgKGlzTm9kZUpTKSB7XG4gICAgICAgICAgICAgICAgLy8gSW4gbm9kZSwgdW5jYXVnaHQgZXhjZXB0aW9ucyBhcmUgY29uc2lkZXJlZCBmYXRhbCBlcnJvcnMuXG4gICAgICAgICAgICAgICAgLy8gUmUtdGhyb3cgdGhlbSBzeW5jaHJvbm91c2x5IHRvIGludGVycnVwdCBmbHVzaGluZyFcblxuICAgICAgICAgICAgICAgIC8vIEVuc3VyZSBjb250aW51YXRpb24gaWYgdGhlIHVuY2F1Z2h0IGV4Y2VwdGlvbiBpcyBzdXBwcmVzc2VkXG4gICAgICAgICAgICAgICAgLy8gbGlzdGVuaW5nIFwidW5jYXVnaHRFeGNlcHRpb25cIiBldmVudHMgKGFzIGRvbWFpbnMgZG9lcykuXG4gICAgICAgICAgICAgICAgLy8gQ29udGludWUgaW4gbmV4dCBldmVudCB0byBhdm9pZCB0aWNrIHJlY3Vyc2lvbi5cbiAgICAgICAgICAgICAgICBpZiAoZG9tYWluKSB7XG4gICAgICAgICAgICAgICAgICAgIGRvbWFpbi5leGl0KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoZmx1c2gsIDApO1xuICAgICAgICAgICAgICAgIGlmIChkb21haW4pIHtcbiAgICAgICAgICAgICAgICAgICAgZG9tYWluLmVudGVyKCk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdGhyb3cgZTtcblxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBJbiBicm93c2VycywgdW5jYXVnaHQgZXhjZXB0aW9ucyBhcmUgbm90IGZhdGFsLlxuICAgICAgICAgICAgICAgIC8vIFJlLXRocm93IHRoZW0gYXN5bmNocm9ub3VzbHkgdG8gYXZvaWQgc2xvdy1kb3ducy5cbiAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgIHRocm93IGU7XG4gICAgICAgICAgICAgICAgfSwgMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZG9tYWluKSB7XG4gICAgICAgICAgICBkb21haW4uZXhpdCgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZmx1c2hpbmcgPSBmYWxzZTtcbn1cblxuaWYgKHR5cGVvZiBwcm9jZXNzICE9PSBcInVuZGVmaW5lZFwiICYmIHByb2Nlc3MubmV4dFRpY2spIHtcbiAgICAvLyBOb2RlLmpzIGJlZm9yZSAwLjkuIE5vdGUgdGhhdCBzb21lIGZha2UtTm9kZSBlbnZpcm9ubWVudHMsIGxpa2UgdGhlXG4gICAgLy8gTW9jaGEgdGVzdCBydW5uZXIsIGludHJvZHVjZSBhIGBwcm9jZXNzYCBnbG9iYWwgd2l0aG91dCBhIGBuZXh0VGlja2AuXG4gICAgaXNOb2RlSlMgPSB0cnVlO1xuXG4gICAgcmVxdWVzdEZsdXNoID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBwcm9jZXNzLm5leHRUaWNrKGZsdXNoKTtcbiAgICB9O1xuXG59IGVsc2UgaWYgKHR5cGVvZiBzZXRJbW1lZGlhdGUgPT09IFwiZnVuY3Rpb25cIikge1xuICAgIC8vIEluIElFMTAsIE5vZGUuanMgMC45Kywgb3IgaHR0cHM6Ly9naXRodWIuY29tL05vYmxlSlMvc2V0SW1tZWRpYXRlXG4gICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgcmVxdWVzdEZsdXNoID0gc2V0SW1tZWRpYXRlLmJpbmQod2luZG93LCBmbHVzaCk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmVxdWVzdEZsdXNoID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgc2V0SW1tZWRpYXRlKGZsdXNoKTtcbiAgICAgICAgfTtcbiAgICB9XG5cbn0gZWxzZSBpZiAodHlwZW9mIE1lc3NhZ2VDaGFubmVsICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgLy8gbW9kZXJuIGJyb3dzZXJzXG4gICAgLy8gaHR0cDovL3d3dy5ub25ibG9ja2luZy5pby8yMDExLzA2L3dpbmRvd25leHR0aWNrLmh0bWxcbiAgICB2YXIgY2hhbm5lbCA9IG5ldyBNZXNzYWdlQ2hhbm5lbCgpO1xuICAgIGNoYW5uZWwucG9ydDEub25tZXNzYWdlID0gZmx1c2g7XG4gICAgcmVxdWVzdEZsdXNoID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBjaGFubmVsLnBvcnQyLnBvc3RNZXNzYWdlKDApO1xuICAgIH07XG5cbn0gZWxzZSB7XG4gICAgLy8gb2xkIGJyb3dzZXJzXG4gICAgcmVxdWVzdEZsdXNoID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBzZXRUaW1lb3V0KGZsdXNoLCAwKTtcbiAgICB9O1xufVxuXG5mdW5jdGlvbiBhc2FwKHRhc2spIHtcbiAgICB0YWlsID0gdGFpbC5uZXh0ID0ge1xuICAgICAgICB0YXNrOiB0YXNrLFxuICAgICAgICBkb21haW46IGlzTm9kZUpTICYmIHByb2Nlc3MuZG9tYWluLFxuICAgICAgICBuZXh0OiBudWxsXG4gICAgfTtcblxuICAgIGlmICghZmx1c2hpbmcpIHtcbiAgICAgICAgZmx1c2hpbmcgPSB0cnVlO1xuICAgICAgICByZXF1ZXN0Rmx1c2goKTtcbiAgICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGFzYXA7XG5cbiIsIi8qIVxuICogQGxpY2Vuc2UgQ29weXJpZ2h0IChjKSAyMDEyLTIwMTQsIFZpZ291ci4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIEBhdXRob3I6IEppbSBkZSBCZWVyLCBqaW1Admlnb3VyLmlvXG4gKi9cbnZhciBWID0gcmVxdWlyZSgnLi4vJylcbiAgLCB1dGlsID0gcmVxdWlyZSgnLi4vdXRpbCcpXG4gICwgaW5qZWN0ID0gcmVxdWlyZSgnLi4vdXRpbC9pbmplY3QnKVxuLy8gLCByYWYgPSByZXF1aXJlKCcuLi9icm93c2VyL2FuaW1hdGlvbi9yYWYnKVxuXG5cbi8qXG4gIHV0aWwuZGVmaW5lKCBleHRlbmQsICdleHRlbnNpb25zJyx7dmFsOltdLCBzZXRDbGFzczp0cnVlfSApXG4qL1xuXG4vKipcbiAqIEJhc2UgaXMgdXNlZCBhcyBhIGNsYXNzIGNvbnN0cnVjdG9yLlxuICogQGNvbnN0cnVjdG9yIFYuQmFzZVxuICogQHBhcmFtICB7Kn0gW3ZhbF0gU3RhcnR2YWx1ZSBmb3IgbmV3IFYuQmFzZVxuICovXG52YXIgYmFzZSA9IFYuQmFzZSA9IG1vZHVsZS5leHBvcnRzID0gZXhwb3J0cyA9IGZ1bmN0aW9uKHZhbCkge1xuICB0aGlzLl9mcm9tID0gdGhpcy5jb25zdHJ1Y3RvclxuICBpZiAodmFsKSB0aGlzLnNldCh2YWwpXG59XG5cbmV4cG9ydHMuc2V0dGluZ3MgPSByZXF1aXJlKCcuL3NldHRpbmdzJylcblxuLyoqXG4gKiBTZXRzIHByb3BlcnRpZXMgZGVmaW5lZCBpbiBhbiBvYmplY3QuXG4gKiBEZWZpbmUgYSBfc2V0IG1ldGhvZCBvbiBhIGJhc2UgaW5zdGFuY2UgdG8gZ2V0IGN1c3RvbSBtZXRob2QgcGVyIHNldC5cbiAqIEBmdW5jdGlvbiBfc2V0XG4gKiBAcGFyYW0gIHsqfSB2YWwgICAgICAgICBBbnkgdmFsdWVcbiAqIEBwYXJhbSAgeyp9IFtwYXJhbXNdICAgIEFkZGVkIHBhcmFtZXRlcnNcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gbm9zZXQgIFdoZW4gdHJ1ZSByZXR1cm5zIGEgcGFyc2VkIHZhbCBvYmplY3QgYnV0IHNldCBub3RoaW5nXG4gKiBAcmV0dXJuIHtPYmplY3R9ICAgICAgICByZXR1cm4gc2VsZiBmb3IgY2hhaW5pbmdcbiAqL1xudmFyIF9zZXQgPSBleHBvcnRzLnNldCA9IGZ1bmN0aW9uKHZhbCwgcGFyYW1zLCBub3NldCkge1xuICBmb3IgKHZhciBpIGluIHZhbCkge1xuICAgIGlmICh+aS5pbmRleE9mKCcsJykpIHtcbiAgICAgIGZvciAodmFyIGFyciA9IGkuc3BsaXQoJywnKSwgbXVsdGlvYmogPSB7fSwgbSA9IDAsIG1sID0gYXJyLmxlbmd0aDsgbSA8IG1sOyBtKyspIHtcbiAgICAgICAgbXVsdGlvYmpbYXJyW21dXSA9IHV0aWwuY2xvbmUodmFsW2ldKVxuICAgICAgfVxuICAgICAgaWYgKCFub3NldCkge1xuICAgICAgICBfc2V0LmNhbGwodGhpcywgbXVsdGlvYmosIHBhcmFtcywgbm9zZXQpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkZWxldGUgdmFsW2ldXG4gICAgICAgIGZvciAodmFyIG4gaW4gbXVsdGlvYmopIHtcbiAgICAgICAgICB2YWxbbl0gPSBtdWx0aW9ialtuXVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGkgPSB1dGlsLmRvdEZpZWxkKHZhbCwgaSlcbiAgICAgIGlmICh0aGlzLl9zZXQgJiYgIW5vc2V0KSB7XG4gICAgICAgIHRoaXMuX3NldC5jYWxsKHRoaXMsIHZhbCwgaSwgcGFyYW1zKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy9UT0RPOiBjaGVjayBmb3IgcHJvcGVydHkgbW92ZSBmcm9tIGVsZW1lbnQgc2V0IHRvIGhlcmVcbiAgICAgICAgLy8gaWYoIFYuT2JqZWN0ICYmIHRoaXMuaXNQcm9wZXJ0eSggaSwgdmFsICkgJiYgdGhpc1tpXSBpbnN0YW5jZW9mIFYuT2JqZWN0IClcbiAgICAgICAgLy8ge1xuICAgICAgICAvLyAgIGNvbnNvbGUubG9nKCc/PycsIGksIHZhbCwgdGhpcy5pc1Byb3BlcnR5KCBpLCB2YWwgKSApXG4gICAgICAgIC8vICAgdGhpc1tpXS52YWwgPSB2YWxbaV1cbiAgICAgICAgLy8gfVxuICAgICAgICAvLyBlbHNlXG4gICAgICAgIC8vIHtcbiAgICAgICAgICB0aGlzW2ldID0gdmFsW2ldXG4gICAgICAgIC8vIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIG5vc2V0ID8gdmFsIDogdGhpc1xufTtcblxudXRpbC5kZWZpbmUoYmFzZSxcbiAgLyoqXG4gICAqIFdoZW4gYSBCYXNlIGlzIGV4dGVuZGVkIHdpdGhvdXQgZGVmaW5pbmcgdGhlIHR5cGUgdGhpcyBpcyB0aGUgZGVmYXVsdCB0eXBlLlxuICAgKiBAcHJvcGVydHkgZGVmYXVsdFR5cGVcbiAgICovXG4gICdpc1Byb3BlcnR5JywgZnVuY3Rpb24oIGksIHZhbCkge1xuICAgIHZhciB0ID0gdGhpc1xuICAgICAgLCByZXN1bHQgPSBcbiAgICAgICAgICAhKCB2YWxbaV0gaW5zdGFuY2VvZiBPYmplY3QgXG4gICAgICAgICAgIC8vVE9ETzogY2hlY2sgaWYgdGhpcyBpcyByZWFsbHkgbmVzc2VyYWN5ICggdm9pZCAwIClcbiAgICAgICAgICAgJiYgdC5fW2ldID09PSB2b2lkIDAgLy8tLS0gZGFuZ2VyIHJlc29sdmUgd2hlbiBkZWZpbmUgXyBpcyBmaXhlZFxuICAgICAgICAgICAmJiAhdXRpbC5sb29rdXAuY2FsbCh0LCBpKSBcbiAgICAgICAgICAgJiYgdHlwZW9mIHRbaV0hPT0nZnVuY3Rpb24nIFxuICAgICAgICAgIClcblxuICAgIC8vIGNvbnNvbGUubG9nKCB2YWxbaV0gaW5zdGFuY2VvZiBPYmplY3QsIHQuX1tpXSA9PT0gdm9pZCAwLCAndmFsOicsdC5fW2ldLCAhdXRpbC5sb29rdXAuY2FsbCh0LCBpKSwgdHlwZW9mIHRbaV0hPT0nZnVuY3Rpb24nICApXG5cbiAgICAvLyBjb25zb2xlLmxvZyggJ0lTIFBST1BFUlRZJywgaSwgcmVzdWx0IClcblxuICAgIHJldHVybiByZXN1bHRcbiAgfSxcbiAgJ2RlZmF1bHRUeXBlJywgZmFsc2UsXG4gICdleHRlbnNpb25zJywgZmFsc2UsXG4gICdkZWZpbmUnLCBmdW5jdGlvbih2YWwpIHtcbiAgICBmb3IodmFyIGkgaW4gdmFsKSB7XG4gICAgICB1dGlsLmRlZmluZSggdGhpcywgaSwgdmFsW2ldIClcbiAgICAgIHV0aWwuZGVmaW5lKCB0aGlzLkNsYXNzLCBpLCB2YWxbaV0gKVxuICAgIH1cbiAgfSxcbiAgLyoqXG4gICAqIEV4dGVuZCBpcyB1c2VkIHRvIGFkZCBwcm9wZXJ0aWVzIHRvIGJhc2UuXG4gICAqIFNldHRpbmdzIGFyZSBzaW1pbGFyIHRvIHN0YW5kYXJkIGRlZmluZVByb3BlcnR5LlxuICAgKiBAbWV0aG9kIGV4dGVuZFxuICAgKiBAcGFyYW0gICB7T2JqZWN0fSAgIHNldHRpbmdzICAgICAgICBEZWZpbmUgdGhlIGZvbGxvd2luZyBmaWVsZHM6IG5hbWUsIHR5cGUsIHNldCwgbmV3LCByZW1vdmUuXG4gICAqIEBwYXJhbSAgIHtTdHJpbmd9ICAgc2V0dGluZ3MubmFtZSAgIERlZmluZSB0aGUgbmFtZSBvZiB0aGUgcHJvcGVydHlcbiAgICogQHBhcmFtICAge09iamVjdH0gICBbc2V0dGluZ3MudHlwZV0gRGVmaW5lIHRoZSB0eXBlIG9mIG9iamVjdCBlLmcuIFYuVmFsdWUsIHNldCB0eXBlIHRvIGZhbHNlIGlmIHlvdSB3YW50IHRvIHVzZSBzdGFuZGFyZCBkZWZpbmVQcm9wZXJ0eVxuICAgKiBAcGFyYW0gICB7RnVuY3Rpb259IHNldHRpbmdzLnNldCAgICBEZWZpbmUgYSBmdW5jdGlvbiBvbiBzZXRcbiAgICogQHBhcmFtICAge0Z1bmN0aW9ufSBzZXR0aW5ncy5uZXcgICAgRGVmaW5lIGEgZnVuY3Rpb24gb24gY29uc3RydWN0XG4gICAqIEBwYXJhbSAgIHtGdW5jdGlvbn0gc2V0dGluZ3MucmVtb3ZlIERlZmluZSBhIGZ1bmN0aW9uIG9uIHJlbW92ZVxuICAgKiBAcmV0dXJuICB7W3R5cGVdfSAgICAgICAgICAgICAgICAgICBbZGVzY3JpcHRpb25dXG4gICAqL1xuICAnZXh0ZW5kJywgZnVuY3Rpb24oc2V0dGluZ3MpIHtcblxuICAgIC8vVE9ETzogYWRkIHRvIGluc3RhbmNlIGFzIHdlbGwgLCBoYXZlIGEgZGljdGlvbmFyeSBvZiBleHRlbnN0aW9ucyAtLSBnZXQgdG8gb3JnaW5hbCBlYXN5bHlcbiAgICB2YXIgYXJncyA9IHV0aWwuYXJnKGFyZ3VtZW50cylcbiAgICAgICwgbCA9IGFyZ3MubGVuZ3RoXG4gICAgICAsIGlcblxuICAgIGlmIChsID4gMSkge1xuICAgICAgZm9yIChpID0gMDsgaSA8IGw7IHRoaXMuZXh0ZW5kKCBhcmdzW2krK10gKSk7XG4gICAgfSBlbHNlIGlmICghc2V0dGluZ3MubmFtZSkge1xuICAgICAgZm9yIChpIGluIHNldHRpbmdzKSB7XG5cbiAgICAgICAgaWYoIHR5cGVvZiBzZXR0aW5nc1tpXSA9PT0gJ2Z1bmN0aW9uJyApIFxuICAgICAgICB7XG4gICAgICAgICAgdGhpcy5leHRlbmQoIHsgbmFtZTogaSwgc2V0OiBzZXR0aW5nc1tpXSB9IClcbiAgICAgICAgfVxuICAgICAgICBlbHNlXG4gICAgICAgIHtcbiAgICAgICAgICBzZXR0aW5nc1tpXS5uYW1lID0gaVxuICAgICAgICAgIHRoaXMuZXh0ZW5kKCBzZXR0aW5nc1tpXSApXG4gICAgICAgIH1cblxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoIXNldHRpbmdzLmRlZiAmJiBzZXR0aW5ncy5kZWYgIT09IDApIHNldHRpbmdzLmRlZiA9IGZhbHNlO1xuICBcbiAgICAgIGlmICh0aGlzLkNsYXNzLnByb3RvdHlwZS5fc2V0dGluZ3MpIHtcbiAgICAgICAgZXhwb3J0cy5zZXR0aW5ncy5wYXJzZS5jYWxsKHRoaXMsIHNldHRpbmdzKVxuICAgICAgICBpZiAoc2V0dGluZ3MuX3NldHRpbmdzKSBleHBvcnRzLnNldHRpbmdzLmNyZWF0ZS5jYWxsKHRoaXMsIHNldHRpbmdzKVxuICAgICAgfVxuICAgICAgLy8xLiBub3JtYWwgZXh0ZW5zaW9uc1xuICAgICAgaWYgKHNldHRpbmdzLnR5cGUgPT09IGZhbHNlIHx8ICggIXNldHRpbmdzLnR5cGUgJiYgIXRoaXMuZGVmYXVsdFR5cGUgKSApIHtcblxuICAgICAgICAvL1RPRE86IHRlc3QgaWYgZG91YmxlIGRlZmluZSBpcyBhY3R1YWxseSBvayFcbiAgICAgICAgLy8gdXRpbC5kZWZpbmUodGhpcywgc2V0dGluZ3MubmFtZSwgc2V0dGluZ3MpXG5cbiAgICAgICAgdXRpbC5kZWZpbmUodGhpcy5DbGFzcywgc2V0dGluZ3MubmFtZSwgc2V0dGluZ3MpXG5cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vMi4gVi5WYWx1ZXNcbiAgICAgICAgaWYgKCFzZXR0aW5ncy50eXBlKSBzZXR0aW5ncy50eXBlID0gdGhpcy5kZWZhdWx0VHlwZVxuICAgICAgICAgIC8vYSB0eXBlIGhhcyBmaWVsZHMgdHlwZSwgc2V0ICxnZXQsIGNyZWF0ZVxuICAgICAgICB2YXIgZ2V0ID0gIGZ1bmN0aW9uKHByb3ApIHtcbiAgICAgICAgICAgIC8vY3VzdG9tIGdldFxuICAgICAgICAgICAgcmV0dXJuIHNldHRpbmdzLnR5cGUuZ2V0IFxuICAgICAgICAgICAgICA/IHNldHRpbmdzLnR5cGUuZ2V0LmNhbGwodGhpcywgcHJvcCwgc2V0dGluZ3MpXG4gICAgICAgICAgICAgIDogcHJvcFxuICAgICAgICAgIH1cbiAgICAgICAgICAsIHNldCA9ICBmdW5jdGlvbih2YWwpIHtcblxuICAgICAgICAgICAgdmFyIHByb3AgPSB0aGlzW3NldHRpbmdzLm5hbWVdXG4gICAgICAgICAgICBpZihwcm9wPT09bnVsbCkgcmV0dXJuXG4gICAgICAgICAgICBpZiAocHJvcD09PXNldHRpbmdzLmRlZikgeyAvLyhwcm9wIGluc3RhbmNlb2YgVi5PYmplY3QpXG4gICAgICAgICAgICAgIC8vcmV0dXJuIGlzIGhpZXIgbWlzY2hpZW4gbmlldCBub2RpZztcbiAgICAgICAgICAgICAgcmV0dXJuIHNldHRpbmdzLnR5cGUuY3JlYXRlLmNhbGwodGhpcywgdmFsLCBwcm9wLCBzZXR0aW5ncylcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKCc/Pz8/Pz8/Pz8/Pz8nLCB0aGlzLCB2YWwsIHByb3AsIHNldHRpbmdzKVxuICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgdmFsID0gc2V0dGluZ3MudHlwZS5zZXQuY2FsbCh0aGlzLCB2YWwsIHByb3AsIHNldHRpbmdzKVxuICAgICAgICAgICAgICBpZiAodmFsIT09IG51bGwpIHByb3AudmFsID0gdmFsXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgIC8vVE9ETzogdGVzdCBpZiBkb3VibGUgZGVmaW5lIGlzIGFjdHVhbGx5IG9rIVxuICAgICAgICB1dGlsLmRlZmluZShcbiAgICAgICAgICB0aGlzLFxuICAgICAgICAgIHNldHRpbmdzLm5hbWUsXG4gICAgICAgICAgc2V0dGluZ3MuZGVmLFxuICAgICAgICAgIHNldCxcbiAgICAgICAgICBnZXQsXG4gICAgICAgICAgdHJ1ZVxuICAgICAgICApXG4gICAgICAgIC8vZGl0IGJyZWFrZWQgd2F0IHNoaXRcblxuICAgICAgICAvL29yIG9uIHZhbHVlID8gdmFsdWUucHJvcFxuXG4gICAgICAgIC8vbWFrZSBleHRlbmRlZCBwcm90b3R5cGUgb2JqZWN0IHBlcmhhcHNcbiAgICAgICAgLy8gdGhpcy5DbGFzcy5wcm90b3R5cGVbJ19fJytzZXR0aW5ncy5uYW1lKydfXyddID0gc2V0dGluZ3NcblxuICAgICAgICB1dGlsLmRlZmluZShcbiAgICAgICAgICB0aGlzLkNsYXNzLFxuICAgICAgICAgIHNldHRpbmdzLm5hbWUsXG4gICAgICAgICAgc2V0dGluZ3MuZGVmLFxuICAgICAgICAgIHNldCxcbiAgICAgICAgICBnZXRcbiAgICAgICAgKVxuICAgICAgfVxuICAgIH1cbiAgfSxcbiAgLyoqXG4gICAqIFJlbW92ZXMgdGhpcyBCYXNlLiBBbHNvIHJlbW92ZXMgYWxsIGxpc3RlbmVycyBhZGRlZCB0byBleHRlbnNpb25zLlxuICAgKiBJbnN0YW5jZXMgdHJ1ZSB3aWxsIHJlbW92ZSBhbGwgaW5zdGFuY2VzIGFzIHdlbGwuXG4gICAqIEBtZXRob2QgcmVtb3ZlXG4gICAqIEBwYXJhbSAge1t0eXBlXX0gaW5zdGFuY2VzICBbZGVzY3JpcHRpb25dXG4gICAqIEBwYXJhbSAge1t0eXBlXX0gZnJvbXJlbW92ZSBbZGVzY3JpcHRpb25dXG4gICAqIEBwYXJhbSAge1t0eXBlXX0gcGFyYW1zICAgICBbZGVzY3JpcHRpb25dXG4gICAqL1xuICAncmVtb3ZlJywgZnVuY3Rpb24oaW5zdGFuY2VzLCBmcm9tcmVtb3ZlLCBwYXJhbXMpIHtcblxuICAgIC8vIHRoaXMuX3JlbW92aW5nID0gdHJ1ZVxuXG4gICAgaWYoIXRoaXMuX2Zyb20pIHJldHVyblxuXG4gICAgdGhpcy5zZXR0aW5nKCdyZW1vdmUnLCBbcGFyYW1zXSk7XG5cbiAgICBpZiAoIWZyb21yZW1vdmUpIHtcbiAgICAgIHZhciBpbnMgPSB0aGlzLl9mcm9tLmJhc2UuaW5zdGFuY2VzXG4gICAgICBpZihpbnMpIHtcbiAgICAgICAgZm9yICh2YXIgbiA9IDAsIGwgPSBpbnMubGVuZ3RoOyBpbnNbbl0gIT09IHRoaXMgfHwgIWlucy5zcGxpY2UobiwgMSk7IG4rKyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZm9yICh2YXIgaSBpbiB0aGlzLl9fKSB7XG4gICAgICBpZiAodGhpcy5fX1tpXSBpbnN0YW5jZW9mIFYuT2JqZWN0KSB7XG4gICAgICAgIC8vbmVzdGVkLCBibGFja2xpc3QsIG5vdCAoZmllbGRzIGluIG9iamVjdCksIGZyb20sIHN0YW1wLCBub3VwZGF0ZVxuLy8gICAgICAgICBjb25zb2xlLmxvZygnLS0tLS0tLS0tJywgaSwgdGhpcy5fX1tpXSwgdGhpcy5fX1tpXS5fcGF0aCApXG4gICAgICAgIHRoaXMuX19baV0ucmVtb3ZlKGZhbHNlLCBmYWxzZSwgZmFsc2UsIGZhbHNlLCBmYWxzZSwgdHJ1ZSk7XG4gICAgICAgIHRoaXMuX19baV0gPSBudWxsXG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl9fW2ldID0gbnVsbFxuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLl9fID0gbnVsbFxuXG4gICAgaWYgKGluc3RhbmNlcyAmJiB0aGlzLmluc3RhbmNlcykge1xuICAgICAgZm9yIChqID0gdGhpcy5pbnN0YW5jZXMubGVuZ3RoIC0gMTsgaiA+PSAwOyB0aGlzLmluc3RhbmNlc1tqLS1dLnJlbW92ZSh0cnVlLCB0cnVlKSk7XG4gICAgfVxuXG4gICAgZm9yICh2YXIgaiBpbiB0aGlzKSB7XG4gICAgICAvLyBpZih0aGlzW2pdIGluc3RhbmNlb2YgVi5CYXNlKSB7XG4gICAgICAvLyAgIHRoaXNbal0ucmVtb3ZlKClcbiAgICAgIC8vIH0gXG4gICAgICB0aGlzW2pdID0gbnVsbDtcbiAgICB9XG5cbiAgICB0aGlzLl9zZXR0aW5ncyA9IG51bGxcbiAgICB0aGlzLl8gPSBudWxsXG4gICAgZGVsZXRlIHRoaXMuX3NldHRpbmdzXG4gICAgZGVsZXRlIHRoaXMuX1xuICAgIGRlbGV0ZSB0aGlzLl9fXG4gICAgLy8gZGVsZXRlIHRoaXMuX2NsYXNzOyBtYXkgbm90IGJlIG5lc3NlY2FyeVxuICB9LFxuICAvKnNldCBvbiBwcm90b3R5cGUqL1xuICAnc2V0JywgX3NldCxcbiAgJ2luamVjdCcsIGluamVjdCxcbiAgLyoqXG4gICAqIFBhc3NlcyBmaWVsZCBwYXJhbWV0ZXIgb25seSBmb3IgaW5zdGFuY2VzIG1hdGNoaW5nIGEgZmllbGRcbiAgICogQG1ldGhvZFxuICAgKiBAcGFyYW0gIHtGdW5jdGlvbn0gZm4gICAgW2Rlc2NyaXB0aW9uXVxuICAgKiBAcGFyYW0gIHtTdHJpbmd9ICAgZmllbGQgW2Rlc2NyaXB0aW9uXVxuICAgKiBAcGFyYW0gIHsqfSAgICAgICAgdmFsICAgW2Rlc2NyaXB0aW9uXVxuICAgKiBAcGFyYW0gIHsqfSAgICAgICAgcCAgICAgW2Rlc2NyaXB0aW9uXVxuICAgKiBAcmV0dXJuIHtCb29sZWFufSAgICAgICAgW2Rlc2NyaXB0aW9uXVxuICAgKi9cbiAgJ2VhY2hJbnN0YW5jZScsIGZ1bmN0aW9uKGZuLCBmaWVsZCwgdmFsLCBwKSB7XG4gICAgdmFyIGluc3RhbmNlcyA9IHRoaXMuaW5zdGFuY2VzO1xuICAgIGlmIChpbnN0YW5jZXMpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gaW5zdGFuY2VzLmxlbmd0aCwgaW5zdGFuY2U7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgaW5zdGFuY2UgPSBpbnN0YW5jZXNbaV07XG5cblxuLy9wcm9ibGVtISBoYXMgdG8gY29ycmVjdCBmb3IgbWlzc2luZyBpbnN0YW5jZXMhISFcbi8vICAgY29uc29sZS5sb2coaW5zdGFuY2UsIGluc3RhbmNlcylcblxuICAgICAgICAgIFxuXG4gICAgICAgIGlmIChpbnN0YW5jZSAmJiAoIWZpZWxkIHx8ICFpbnN0YW5jZS5fXyB8fCAhaW5zdGFuY2UuX19bZmllbGRdKSkge1xuICAgICAgICAgIGlmIChmbi5jYWxsKGluc3RhbmNlLCB2YWwsIHApKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGluc3RhbmNlLmVhY2hJbnN0YW5jZShmbiwgZmllbGQsIHZhbCkpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmKCFpbnN0YW5jZSkge1xuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ1xcblxcblxcblxcbmluc3RhbmNlIGluIGJhc2UgZ29uZT8nLCBpICwgaW5zdGFuY2VzKVxuICAgICAgICAgIC8vIGRlYnVnZ2VyXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0sXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgY2xhc3MgZnJvbSB0aGUgY3VycmVudCBCYXNlIGluc3RhbmNlXG4gICAqIEBjb25zdHJ1Y3RvciBDbGFzc1xuICAgKiBAcmV0dXJuIHtPYmplY3R9XG4gICAqL1xuICAnQ2xhc3MnLCB7XG4gICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgIGlmICghdGhpcy5fY2xhc3MpIHtcbiAgICAgICAgdGhpcy5pbnN0YW5jZXMgPSBbXTtcbiAgICAgICAgdGhpcy5fY2xhc3MgPSBmdW5jdGlvbih2YWwsIHByb3RvLCBzZXR0aW5nKSB7XG4gICAgICAgICAgaWYgKCFwcm90bykge1xuICAgICAgICAgICAgdmFyIGZyb20gPSB0aGlzLl9mcm9tLmJhc2U7XG4gICAgICAgICAgICBmcm9tLmluc3RhbmNlcy5wdXNoKHRoaXMpO1xuICAgICAgICAgICAgaWYgKHRoaXMuc2V0dGluZykge1xuICAgICAgICAgICAgICB0aGlzLnNldHRpbmcoJ25ldycsIFtmcm9tLCBzZXR0aW5nXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodmFsKSB7XG4gICAgICAgICAgICAgIHRoaXMuc2V0KHZhbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICB0aGlzLl9jbGFzcy5iYXNlID0gdGhpcztcbiAgICAgICAgdGhpcy5fY2xhc3MucHJvdG90eXBlID0gbmV3IHRoaXMuX2Zyb20oZmFsc2UsIHRydWUpO1xuICAgICAgICB0aGlzLl9jbGFzcy5wcm90b3R5cGUuX18gPSBudWxsO1xuICAgICAgICB1dGlsLnNldHN0b3JlLmNhbGwodGhpcyk7XG4gICAgICAgIHZhciBpLCBfcHJvdG8gPSB0aGlzLl9jbGFzcy5wcm90b3R5cGUuXyA9IHt9O1xuICAgICAgICBmb3IgKGkgaW4gdGhpcy5fXykge1xuICAgICAgICAgIF9wcm90b1tpXSA9IHRoaXMuX19baV07XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChpIGluIHRoaXMuXykge1xuICAgICAgICAgIGlmIChfcHJvdG9baV0gPT09IHZvaWQgMCkge1xuICAgICAgICAgICAgX3Byb3RvW2ldID0gdGhpcy5fW2ldO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9jbGFzcy5wcm90b3R5cGUuX2Zyb20gPSB0aGlzLl9jbGFzcztcbiAgICAgICAgdGhpcy5fY2xhc3MuaW5qZWN0ID0gaW5qZWN0XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy5fY2xhc3M7XG4gICAgfVxuICB9KTsiLCIvKiFcbiAqIEBsaWNlbnNlIENvcHlyaWdodCAoYykgMjAxMi0yMDE0LCBWaWdvdXIuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBAYXV0aG9yOiBKaW0gZGUgQmVlciwgamltQHZpZ291ci5pb1xuICovXG52YXIgYmFzZSA9IHJlcXVpcmUoJy4vJyksXG4gIHV0aWwgPSByZXF1aXJlKCcuLi91dGlsJyk7XG5cbi8qKlxuICogU2V0dGluZ3MgYXJlIHVzZWQgZm9yIHNwZWNpYWwgY2FzZXMgZS5nLiBvblJlbW92ZSBvciBvbk5ldyBpbnN0YW5jZVxuICogQHByb3BlcnR5XG4gKi9cbnV0aWwuZGVmaW5lKGJhc2UsICdfc2V0dGluZ3MnKTtcblxuYmFzZS5wcm90b3R5cGUuXy5fc2V0dGluZ3MgPSB7fTtcblxuLyoqXG4gKiBTZXQgc2V0dGluZ3Mgb24gQmFzZVxuICogQGZ1bmN0aW9uIF9zZXRcbiAqIEBwYXJhbSAge09iamVjdH0gIHNldCAgICAgIE9iamVjdCB0byBzZXRcbiAqIEBwYXJhbSAge0Jvb2xlYW59IFtyZW1vdmVdXG4gKiBAcGFyYW0gIHtCb29sZWFufSBbZm9yY2VdICBUcnVlL2ZhbHNlXG4gKi9cbnZhciBfc2V0ID0gZnVuY3Rpb24oc2V0LCByZW1vdmUsIGZvcmNlKSB7XG4gIHZhciBfcyA9IHNldC5fc2V0dGluZ3MgLy9lLmcuIG5vZGUgLCByZW1vdmUgYW5kIHBhcmVudFxuICAgICwgdCA9IHRoaXNcbiAgICAsIF9fdCA9IHQuXy5fc2V0dGluZ3NcbiAgICAsIHNldHRpbmdcbiAgICAsIGlcbiAgICAsIF90XG5cbiAgdXRpbC5zZXRzdG9yZS5jYWxsKHQpXG5cbiAgaWYgKCF0Ll9fLl9zZXR0aW5ncykge1xuICAgIC8vIGNvbnNvbGUubG9nKCdjcmVhdGUgbXkgb3duIHNldHRpbmdzJylcbiAgICB0Ll9fLl9zZXR0aW5ncyA9IHt9XG4gICAgZm9yICh2YXIgaiBpbiBfX3QpIHtcbiAgICAgIHQuX3NldHRpbmdzW2pdID0gX190W2pdXG4gICAgfVxuICB9XG5cbiAgX3QgPSB0Ll9fLl9zZXR0aW5nc1xuXG4gIC8vIGNvbnNvbGUubG9nKCdTRVRUSU5HUz8nLmludmVyc2UsIHNldCwgX190KVxuXG4gIGZvciAoaSBpbiBfcykge1xuICAgIHNldHRpbmcgPSBfc1tpXVxuICAgIC8vZWZmaWNpZW50IG1lbW9yeSBtYW5hZ2VtZW50IG9ubHkgbWFrZSBvd24gaWYgYWJzb2x1dGVseSBuZXNzZWNhcnlcbiAgICBpZiAoKHJlbW92ZSAmJiBfdFtzZXR0aW5nXVtzZXQubmFtZV0pIHx8ICghcmVtb3ZlICYmICFfdFtzZXR0aW5nXVtzZXQubmFtZV0pIHx8IGZvcmNlKSB7XG4gICAgICBcbiAgICAgIGlmIChfdFtzZXR0aW5nXSA9PT0gX190W3NldHRpbmddKSB7XG4gICAgICAgIF90W3NldHRpbmddID0ge31cbiAgICAgICAgZm9yICh2YXIgbiBpbiBfX3Rbc2V0dGluZ10pIHtcbiAgICAgICAgICBfdFtzZXR0aW5nXVtuXSA9IF9fdFtzZXR0aW5nXVtuXVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChyZW1vdmUpIHtcbiAgICAgICAgdGhpcy5lYWNoSW5zdGFuY2UoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgaWYgKHRoaXNbc2V0Lm5hbWVdICE9PSB0W3NldC5uYW1lXSkge1xuICAgICAgICAgICAgaWYgKHRoaXMuX3NldHRpbmcgIT09IF90ICYmIHRoaXMuX3NldHRpbmdzW3NldHRpbmddID09PSBfdFtzZXR0aW5nXSkge1xuICAgICAgICAgICAgICAvLyBjb25zb2xlLmxvZygnZm91bmQgdGhhdCB0aGUgc2V0dGluZ3MgYXJlIHRoZSBzYW1lIGFuZCBub3QgdGhlIHNhbWUgcHJvcGVydHkgbWFrZSBteSBvd24nKTtcbiAgICAgICAgICAgICAgLy8gY29uc29sZS5sb2coJy0tLS0tLSBTRVRUSU5HJylcbiAgICAgICAgICAgICAgX3NldC5jYWxsKHRoaXMsIF90W3NldHRpbmddW3NldC5uYW1lXSwgZmFsc2UsIHRydWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAodGhpcy5fc2V0dGluZyAhPT0gX3QgJiYgdGhpcy5fc2V0dGluZ3Nbc2V0dGluZ10gIT09IF90W3NldHRpbmddKSB7XG4gICAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKCctLS0tLS0gUkVNT1ZFIFNFVFRJTkcnKVxuXG4gICAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKHRoaXMubmFtZSxzZXQubmFtZSwnZm91bmQgdGhhdCB0aGUgcHJvcGVydHkgaXMgdGhlIHNhbWUgYnV0IHNldHRpbmdzIGFyZSBub3QhJyk7XG4gICAgICAgICAgICAgIHRoaXMucmVtb3ZlU2V0dGluZyhzZXQubmFtZSwgc2V0dGluZyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgX3Rbc2V0dGluZ11bc2V0Lm5hbWVdID0gbnVsbDtcbiAgICAgICAgZGVsZXRlIF90W3NldHRpbmddW3NldC5uYW1lXTsgLy9kZWxldGUgaXMga3V0ITtcbiAgICAgICAgaWYgKHV0aWwuZW1wdHkoX3Rbc2V0dGluZ10pKSB7XG4gICAgICAgICAgLy8gY29uc29sZS5sb2coJ2xldHMgcHV0IHRoaXMgdG8gdHJ1ZSEnKVxuICAgICAgICAgIF90W3NldHRpbmddID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gY29uc29sZS5sb2coJy0tLS0tLSBETyBTRVRUSU5HJywgc2V0LCBfdCwgc2V0dGluZywgc2V0Lm5hbWUpXG4gICAgICAgIGlmKF90W3NldHRpbmddPT09dHJ1ZSkge1xuICAgICAgICAgIF90W3NldHRpbmddPXt9XG4gICAgICAgIH1cbiAgICAgICAgX3Rbc2V0dGluZ11bc2V0Lm5hbWVdID0gc2V0O1xuICAgICAgICAvLyBjb25zb2xlLmxvZygnUkVTVUxUPycsIHNldHRpbmcsIF90W3NldHRpbmddKVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vIGNvbnNvbGUubG9nKCdTRVRUSU5HUz8gLS0gcmVzdWx0Jy5pbnZlcnNlLCBfdCwgdGhpcy5fc2V0dGluZ3M9PT1fdCwgdGhpcy5CTFVYRU4pXG5cbn07XG5cbi8qKlxuICogQ3JlYXRlcyBhIHNldHRpbmdcbiAqIEBtZXRob2QgY3JlYXRlXG4gKiBAcGFyYW0gIHtbdHlwZV19IHNldCBbZGVzY3JpcHRpb25dXG4gKiBAcmV0dXJuIHtbdHlwZV19ICAgICBbZGVzY3JpcHRpb25dXG4gKi9cbmV4cG9ydHMuY3JlYXRlID0gZnVuY3Rpb24oc2V0KSB7XG4gIHNldC5fc2V0ID0gc2V0LnNldDtcbiAgc2V0LnNldCA9IGZ1bmN0aW9uKHZhbCwgcHJvcCkge1xuICAgIF9zZXQuY2FsbCh0aGlzLCBzZXQpXG4gICAgc2V0Ll9zZXQuYXBwbHkodGhpcywgYXJndW1lbnRzKVxuICB9XG59XG5cbi8qKlxuICogRXh0cmFjdHMgc2V0dGluZ3MgZnJvbSBzZXR0aW5nc29iamVjdCBhbmQgc3RvcmVzIHRoZW0gaW4gYW4gYXJyYXkuXG4gKiBAbWV0aG9kIHBhcnNlXG4gKiBAcGFyYW0gIHtPYmplY3R9IHNldHRpbmdzIFNldHRpbmdvYmplY3RcbiAqIEBwYXJhbSAge09iamVjdH0gb2JqZWN0ICAgU2V0dGluZ3NvYmplY3RcbiAqL1xuZXhwb3J0cy5wYXJzZSA9IGZ1bmN0aW9uKHNldHRpbmdzLCBvYmplY3QpIHtcbiAgaWYgKCFvYmplY3QpIHtcbiAgICBvYmplY3QgPSB0aGlzLl9zZXR0aW5nc1xuICB9XG4gIGZvciAodmFyIGkgaW4gb2JqZWN0KSB7XG4gICAgaWYgKHNldHRpbmdzW2ldKSB7XG4gICAgICBpZiAoIXNldHRpbmdzLl9zZXR0aW5ncykge1xuICAgICAgICBzZXR0aW5ncy5fc2V0dGluZ3MgPSBbXTtcbiAgICAgIH1cbiAgICAgIHNldHRpbmdzLl9zZXR0aW5ncy5wdXNoKGkpO1xuICAgIH1cbiAgfVxufTtcblxuLyoqXG4gKiBBZGRzIHNldHRpbmcocykgdG8gQmFzZSBwcm90b3R5cGVcbiAqIEBtZXRob2QgYWRkXG4gKiBAcGFyYW0gIHtTdHJpbmdbXX0gICAgbmFtZSAgQXJyYXkgb2Ygc2V0dGluZ25hbWVzXG4gKiBAcGFyYW0gIHtQcm90b3R5cGV9ICAgcHJvdG8gUHJvdG90eXBlIGVnLiBteUJhc2UgY2xhc3NcbiAqL1xuZXhwb3J0cy5hZGQgPSBmdW5jdGlvbihuYW1lLCBwcm90bykgeyAvL3N0YXJ0IHVzaW5nIHRoaXMgc29tZXRpbWVzITtcbiAgaWYgKG5hbWUgaW5zdGFuY2VvZiBBcnJheSkge1xuICAgIGZvciAodmFyIGkgaW4gbmFtZSkge1xuICAgICAgaWYgKHByb3RvKSB7XG4gICAgICAgIHRoaXMuYWRkKG5hbWVbaV0sIHByb3RvKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuYWRkU2V0dGluZyhuYW1lW2ldLCBmYWxzZSk7XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGlmICghcHJvdG8pIHtcbiAgICAgIHV0aWwuc2V0c3RvcmUuY2FsbCh0aGlzKTtcbiAgICAgIGlmICghdGhpcy5fXy5fc2V0dGluZ3MpIHtcbiAgICAgICAgdGhpcy5fXy5fc2V0dGluZ3MgPSB7fTtcbiAgICAgIH1cbiAgICAgIGZvciAodmFyIGogaW4gdGhpcy5fLl9zZXR0aW5ncykge1xuICAgICAgICB0aGlzLl9zZXR0aW5nc1tqXSA9IHRoaXMuXy5fc2V0dGluZ3Nbal07XG4gICAgICB9XG4gICAgICB0aGlzLl9zZXR0aW5nc1tuYW1lXSA9IHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHByb3RvLnByb3RvdHlwZS5fc2V0dGluZ3NbbmFtZV0gPSB0cnVlO1xuICAgIH1cbiAgfVxufTtcblxuLyoqXG4gKiBBZGQgc2V0dGluZ3MgdG8gaW5zdGFuY2VzIG9mIEJhc2VcbiAqIHNldHRpbmdzIG9ubHkgd29yayBmb3IgaW5zdGFuY2VzIG9mIHRoZSBhZGRlZCBCYXNlc2V0dGluZ3NcbiAqIEBtZXRob2RcbiAqL1xudXRpbC5kZWZpbmUoYmFzZSxcbiAgJ2FkZFNldHRpbmcnLCBmdW5jdGlvbihuYW1lKSB7XG4gICAgZXhwb3J0cy5hZGQuY2FsbCh0aGlzLCBuYW1lKTtcbiAgICBpZiAodGhpcy5fY2xhc3MpIHtcbiAgICAgIHRoaXMuX2NsYXNzLnByb3RvdHlwZS5fLl9zZXR0aW5ncyA9IHRoaXMuX3NldHRpbmdzO1xuICAgIH1cbiAgfSxcbiAgLyoqXG4gICAqIFNpbXBsZSBpbXBsZW1lbnRhdGlvbiBvZiBzZXR0aW5nLmNyZWF0ZVxuICAgKiBAbWV0aG9kIHNldFNldHRpbmdcbiAgICogQHBhcmFtICB7T2JqZWN0fSBzZXQgU2V0dGluZ29iamVjdFxuICAgKi9cbiAgJ3NldFNldHRpbmcnLCBmdW5jdGlvbihzZXQpIHtcbiAgICAvL2VlcnN0IGNoZWNrZW4gb2YgaWUgYWwgYmVzdGFhdCBhbmRlcnMga2FuIGhldCB2b29ya29tZW4gZGF0IGhldCB0ZXZlZWwgaXNcbiAgICBleHBvcnRzLnBhcnNlLmNhbGwodGhpcywgc2V0KTtcblxuICAgIC8vIGNvbnNvbGUubG9nKCdTRVQgU0VUVElORycueWVsbG93LmludmVyc2UsIHNldCwgdGhpcy5fc2V0dGluZ3MgKVxuXG4gICAgLy9nZXQgZ2VicnVpa2VuIC0tLSBvYmplY3QgaXMgZWVuIGNoZWNrIG9wIG1lZXJkZXJlIGZpZWxkcyByZXR1cm5zIHRydWUgb2YgZmFsc2UgLy8gYmlqIGdldCBvb2sgbW9nZWxpamsgb20gZmllbGQgbWVlIHRlIGdldmVuXG4gICAgX3NldC5jYWxsKHRoaXMsIHNldCk7XG5cbiAgICAvLyBjb25zb2xlLmxvZygnU0VUIFNFVFRJTkcgLS0gcmVzdWx0Jy55ZWxsb3cuaW52ZXJzZSwgdGhpcy5fc2V0dGluZ3MgKVxuXG4gIH0sXG4gIC8qKlxuICAgKiBbZGVzY3JpcHRpb25dXG4gICAqIEBtZXRob2QgcmVtb3ZlU2V0dGluZ1xuICAgKiBAcGFyYW0gIHtTdHJpbmd9ICAgICAgIG5hbWUgICAgIE5hbWUgb2YgdGhlIHNldHRpbmcgdG8gcmVtb3ZlXG4gICAqIEBwYXJhbSAge0FycmF5fE9iamVjdH0gc2V0dGluZ3MgU2V0dGluZ29iamVjdFxuICAgKi9cbiAgJ3JlbW92ZVNldHRpbmcnLCBmdW5jdGlvbihuYW1lLCBzZXR0aW5ncykge1xuXG4gICAgLy8gaWYoIXNldHRpbmdzKSB7XG4gICAgLy8gICAvL3RoaXMgbWF5IGFsbCBiZSBub3QgbmVzc2VjYXJ5IVxuICAgIC8vICAgZm9yKHZhciBpIGluIHRoaXMuX3NldHRpbmdzKSB7XG4gICAgLy8gICAgIGZvcih2YXIgaiBpbiB0aGlzLl9zZXR0aW5nc1tpXSkge1xuICAgIC8vICAgICAgIGlmKHRoaXMuX3NldHRpbmdzW2ldW2pdLm5hbWU9PT1uYW1lKSB7XG4gICAgLy8gICAgICAgICBzZXR0aW5ncz10aGlzLl9zZXR0aW5nc1tpXVtqXVxuICAgIC8vICAgICAgICAgYnJlYWs7XG4gICAgLy8gICAgICAgfVxuICAgIC8vICAgICB9XG4gICAgLy8gICB9XG4gICAgLy8gfVxuXG4gICAgaWYgKCEoc2V0dGluZ3MgaW5zdGFuY2VvZiBBcnJheSkpIHtcbiAgICAgIC8vdGhpcyBtYXkgYWxsIGJlIG5vdCBuZXNzZWNhcnkhXG4gICAgICAvLyBpZihzZXR0aW5ncyBpbnN0YW5jZW9mIE9iamVjdCkge1xuICAgICAgLy8gICBzZXR0aW5ncyA9IHNldHRpbmdzLl9zZXR0aW5nc1xuICAgICAgLy8gfSBlbHNlIHtcbiAgICAgICAgc2V0dGluZ3MgPSBbc2V0dGluZ3NdO1xuICAgICAgLy8gfVxuICAgIH1cblxuICAgIGZvciAodmFyIGkgPSBzZXR0aW5ncy5sZW5ndGggLSAxLCBmb3VuZCwgX3NldHRpbmdzID0gdGhpcy5fc2V0dGluZ3M7IGkgPj0gMDsgaS0tKSB7XG4gICAgICBpZiAoX3NldHRpbmdzICYmIF9zZXR0aW5nc1tzZXR0aW5nc1tpXV0gJiYgX3NldHRpbmdzW3NldHRpbmdzW2ldXVtuYW1lXSkge1xuICAgICAgICBmb3VuZCA9IHRydWU7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoZm91bmQpIHtcbiAgICAgIF9zZXQuY2FsbCh0aGlzLCB7XG4gICAgICAgIG5hbWU6IG5hbWUsXG4gICAgICAgIF9zZXR0aW5nczogc2V0dGluZ3NcbiAgICAgIH0sIHRydWUpO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogQ2hlY2tzIGlmIG9iamVjdCBoYXMgc2V0dGluZ3MgYW5kIGV4ZWN1dGVzIHRoZW0uIEFyZ3VtZW50cyBhcmUgcGFzc2VkIHRvIHNldHRpbmdzLlxuICAgKiBAbWV0aG9kIHNldHRpbmdcbiAgICogQHBhcmFtICB7U3RyaW5nfSAgICBuYW1lIE5hbWUgb2YgdGhlIHNldHRpbmdcbiAgICogQHBhcmFtICB7QXJndW1lbnRzfSBhcmcgIEFyZ3VtZW50cyB0byBwYXNzIHRvIHNldHRpbmdzXG4gICAqL1xuICAnc2V0dGluZycsIGZ1bmN0aW9uKG5hbWUsIGFyZykgeyAvL21pc3NjaGllbiBhcmdcbiAgICB2YXIgX3MgPSB0aGlzLl9zZXR0aW5ncztcbiAgICBpZiAoX3MgJiYgX3NbbmFtZV0gJiYgX3NbbmFtZV0gIT09IHRydWUpIHtcbiAgICAgIGZvciAodmFyIGkgaW4gX3NbbmFtZV0pIHtcbiAgICAgICAgX3NbbmFtZV1baV1bbmFtZV0uYXBwbHkodGhpcywgYXJnKTtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xuXG4vKipcbiAqIEJhc2UgaGFzIHR3byBkZWZhdWx0IHNldHRpbmdzXG4gKiBuZXcgaXMgaW52b2tlZCBvbiBjb25zdHJ1Y3Rpb24gLCByZW1vdmUgb24gcmVtb3ZhbDtcbiAqIEBzZXR0aW5nc1xuICovXG5leHBvcnRzLmFkZChbJ25ldycsICdyZW1vdmUnXSwgYmFzZSlcbiIsIi8qIVxuICogQGxpY2Vuc2UgQ29weXJpZ2h0IChjKSAyMDEyLTIwMTQsIFZpZ291ci4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIEBhdXRob3I6IFlvdXJpIERhYW1lbiwgeW91cmlAdmlnb3VyLmlvXG4gKi9cbnZhciB1YSA9IHJlcXVpcmUoJy4uL3VhJyksXG4gIFJBRiA9ICdlcXVlc3RBbmltYXRpb25GcmFtZScsXG4gIENBUCA9ICdSJyArIFJBRixcbiAgdXRpbCA9IHJlcXVpcmUoJy4uLy4uL3V0aWwnKVxuICBsYXN0RnJhbWUgPSAwO1xuXG51dGlsLmRlZmluZSh1YSwgJ2hhc1RyYW5zaXRpb24nLCB7XG4gIGdldDpmdW5jdGlvbigpIHtcbiAgICBpZighdWEuX2hhc1RyYW5zaXRpb24pIHtcbiAgICAgICB2YXIgYiA9IGRvY3VtZW50LmJvZHkgfHwgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50XG4gICAgICAgICwgcyA9IGIuc3R5bGVcbiAgICAgICAgLCBwID0gJ3JhbnNpdGlvbic7XG4gICAgICB1YS5faGFzVHJhbnNpdGlvbiA9IHR5cGVvZiBzWyd0JytwXSA9PT0gJ3N0cmluZycgXG4gICAgICAgIHx8IHR5cGVvZiBzW3VhLnByZWZpeCArICdUJytwXSA9PT0gJ3N0cmluZydcbiAgICB9XG4gICAgcmV0dXJuIHVhLl9oYXNUcmFuc2l0aW9uXG4gIH1cbn0pXG4gIFxuUkFGID0gJ3InICsgUkFGO1xuaWYgKCF3aW5kb3dbUkFGXSkgeyBcblxuICB1YS5ub1JhZiA9IHRydWVcblxuICAvL3dpbmRvd1t1YS5wcmVmaXggKyBDQVBdIHx8IFxuXG4gIHdpbmRvd1tSQUZdID0gZnVuY3Rpb24oY2FsbGJhY2spIHtcbiAgICByZXR1cm4gc2V0VGltZW91dChjYWxsYmFjaywgMjApO1xuICB9O1xuICB3aW5kb3cuY2FuY2VsQW5pbWF0aW9uRnJhbWUgPSBmdW5jdGlvbihpZCkge1xuICAgIGNsZWFyVGltZW91dChpZCk7XG4gIH07XG59XG5cblxuXG5tb2R1bGUuZXhwb3J0cyA9IHdpbmRvd1tSQUZdXG4vL2NoZWNrIGlvcyA2IHBhdWwgaXJpc2ggc2F5cyBzdHVmZiBnb2VzIHdyb25nIHRoZXJlLi4uIiwiLyohXG4gKiBAbGljZW5zZSBDb3B5cmlnaHQgKGMpIDIwMTItMjAxNCwgVmlnb3VyLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogQGF1dGhvcjogSmltIGRlIEJlZXIsIGppbUB2aWdvdXIuaW9cbiAqL1xuXG52YXIgY2FzZXMgPSByZXF1aXJlKCcuLycpLFxuICBlbGVtZW50ID0gcmVxdWlyZSgnLi4vZWxlbWVudCcpLFxuICBzZXRGbGFncyA9IHJlcXVpcmUoJy4uL2VsZW1lbnQvc2V0JyksXG4gIGJhc2UgPSByZXF1aXJlKCcuLi8uLi9iYXNlJyksXG4gIHV0aWwgPSByZXF1aXJlKCcuLi8uLi91dGlsJyk7XG5cbi8vLS0tLS0tLS0tLS0tLS0tLS0tQ0FTRVMgRk9SIFNFVC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbnZhciBfY3NzID0gZnVuY3Rpb24odCwgbmFtZSwgaW52ZXJ0LCByZW1vdmUpIHtcbiAgICBpZiAoIWludmVydCkge1xuICAgICAgdC5jc3MgPSByZW1vdmUgPyB7XG4gICAgICAgIHJlbW92ZUNsYXNzOiBuYW1lXG4gICAgICB9IDoge1xuICAgICAgICBhZGRDbGFzczogbmFtZVxuICAgICAgfTtcbiAgICB9XG4gIH0sXG4gIG1ldGhvZHMgPSBjYXNlcy5tZXRob2RzO1xuXG5zZXRGbGFncy5yZW1vdmUgPSBmdW5jdGlvbihpLCB2YWwsIGNvcHksIHRvcCkge1xuICAvL3RoaXMgY291bGQgYmVjb21lIGEgc2VwZXJhdGUgbW9kdWxlIHNpbmNlIHJlbW92ZSBtYXkgYmUgdXNlZnVsbCBmb3IgZGlmZmVyZW50IHB1cnBvc2VzXG4gIGlmICh2YWwgJiYgdmFsLl9fcmVtb3ZlX18pIHtcbiAgICBpZiAodGhpc1tpXSBpbnN0YW5jZW9mIGJhc2UpIHtcbiAgICAgIHRvcFtpXSA9IGZhbHNlO1xuICAgIH0gZWxzZSBpZiAodXRpbC5sb29rdXAuY2FsbCh0aGlzLCBpKSkge1xuICAgICAgZGVsZXRlIHZhbC5fX3JlbW92ZV9fO1xuICAgIH0gZWxzZSB7XG4gICAgICBkZWxldGUgdmFsW2ldO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG59O1xuXG5zZXRGbGFncy5jYXNlcyA9IG1ldGhvZHMucmVhZGVyKGZ1bmN0aW9uKG5hbWUsIHZhbCwgZHluYW1pYywgaW52ZXJ0KSB7XG4gIHZhciB0ID0gdGhpcyxcbiAgICBmID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgICBvYmogPSBiYXNlLnNldChvYmosIGZhbHNlLCB0cnVlKTtcbiAgICAgIGZvciAodmFyIGkgaW4gb2JqKSB7XG4gICAgICAgIGlmICh1dGlsLmlzT2JqKG9ialtpXSkpIHtcbiAgICAgICAgICBvYmpbaV0gPSBmKG9ialtpXSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBvYmo7XG4gICAgfSxcbiAgICBtZXRob2QsXG4gICAgcGFyc2VkLFxuICAgIHNldCxcbiAgICBzVmFsLFxuICAgIG9yaWdpbmFsO1xuICB2YWwgPSBmKHZhbCk7XG5cbiAgaWYgKGR5bmFtaWMpIHtcbiAgICBpZiAoIXQuX2Nhc2VzKSB7XG4gICAgICB0Ll9jYXNlcyA9IHt9O1xuICAgIH1cbiAgICBpZiAodmFsID09PSBudWxsKSB7XG4gICAgICBpZiAodC5fY2FzZXNbbmFtZV0ubWV0aG9kKSB7XG4gICAgICAgIC8vIGNvbnNvbGUuZXJyb3IobmFtZSwgJ2Nhc2UgPT09IG51bGwgLCByZW1vdmUgaXQnKTtcbiAgICAgICAgY2FzZXNbbmFtZV0ucmVtb3ZlTGlzdGVuZXIodC5fY2FzZXNbbmFtZV0ubWV0aG9kKTtcbiAgICAgIH1cbiAgICAgIGlmIChjYXNlc1tuYW1lXS52YWwpIHtcbiAgICAgICAgdC5jc3MgPSB7XG4gICAgICAgICAgcmVtb3ZlQ2xhc3M6IG5hbWVcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIGRlbGV0ZSB0Ll9jYXNlc1tuYW1lXTsgLy9yZW1vdmVzIGNhc2Ugb3JnaW5hbFxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBjb25zb2xlLmVycm9yKCdTRVQgQ0FTRScsbmFtZSx0Ll9jYXNlc1tuYW1lXSYmdC5fY2FzZXNbbmFtZV0ubWV0aG9kKTtcbiAgICAgIHBhcnNlZCA9IG1ldGhvZHMub3JpZ2luYWwodCwgdHJ1ZSwgdmFsLCB0Ll9jYXNlcywgdHJ1ZSwgbmFtZSk7XG4gICAgICB0Ll9jYXNlc1tuYW1lXSA9IHtcbiAgICAgICAgdmFsOiB2YWwsXG4gICAgICAgIG9yaWc6IHBhcnNlZFswXSxcbiAgICAgICAgbmVzdGVkOiBwYXJzZWRbMV1cbiAgICAgIH07XG5cbiAgICAgIGlmICghdC5fY2FzZXNbbmFtZV0ubWV0aG9kKSB7XG4gICAgICAgIC8vIGNvbnNvbGUuZXJyb3IoJ3RoaXMgaXMgd2hhdCBpIGhhdmUgc2V0IGZvciBvcmlnaW5hbCcsIHQuX2Nhc2VzKTtcbiAgICAgICAgbWV0aG9kID0gdC5fY2FzZXNbbmFtZV0ubWV0aG9kID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgLy8gY29uc29sZS5sb2coJ0xFVFMgVFJZIFRPIFJVTiBNRVRIT0QnLG5hbWUpO1xuICAgICAgICAgIGlmICh2YWwpIHtcbiAgICAgICAgICAgIHNldCA9IG1ldGhvZHMubWVyZ2UodHJ1ZSwgbmFtZSwgdmFsLCB0Ll9jYXNlcyk7IC8vYXJnIG5vIHZhbDtcbiAgICAgICAgICAgIHNWYWwgPSBzZXQgWzBdO1xuICAgICAgICAgICAgb3JpZ2luYWwgPSBzZXQgWzFdO1xuICAgICAgICAgICAgZGVsZXRlIHNWYWwudmFsO1xuICAgICAgICAgICAgZGVsZXRlIG9yaWdpbmFsLnZhbDtcbiAgICAgICAgICAgIGlmIChjYXNlc1tuYW1lXS52YWwpIHtcbiAgICAgICAgICAgICAgX2Nzcyh0LCBuYW1lLCBpbnZlcnQpO1xuICAgICAgICAgICAgICB0LnNldChzVmFsLCB0cnVlKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIF9jc3ModCwgbmFtZSwgaW52ZXJ0LCB0cnVlKTtcbiAgICAgICAgICAgICAgdC5zZXQob3JpZ2luYWwsIHRydWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgLy8gY29uc29sZS5lcnJvcignQUREIExJU1RFTkVSIFRPJyxuYW1lLCAgdC5fY2FzZXNbbmFtZV0pO1xuICAgICAgICBjYXNlc1tuYW1lXS5hZGRMaXN0ZW5lcihtZXRob2QpO1xuICAgICAgICAvL3JlbW92ZSBzZXR0aW5nIG9uIHJlbW92ZSAoc2F2ZXMgbWVtb3J5KVxuICAgICAgICB0LnNldFNldHRpbmcoe1xuICAgICAgICAgIG5hbWU6ICdfYycgKyBuYW1lLFxuICAgICAgICAgIHJlbW92ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAvLyBjb25zb2xlLmxvZygncmVtb3ZlIGZyb20gc2V0dGluZyBjYXNlJywgbmFtZSk7XG4gICAgICAgICAgICBjYXNlc1tuYW1lXS5yZW1vdmVMaXN0ZW5lcihtZXRob2QpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIC8vIH0gZWxzZSB7XG4gICAgICAgIC8vIGNvbnNvbGUubG9nKG5hbWUsICdhbHJlYWR5IGdvdCBsaXN0ZW5lcnMgZm9yIGNhc2UnLG5hbWUpO1xuICAgICAgfVxuICAgICAgaWYgKGNhc2VzW25hbWVdLnZhbCkge1xuICAgICAgICBfY3NzKHQsIG5hbWUsIGludmVydCk7XG4gICAgICAgIHQuc2V0KHZhbCwgdHJ1ZSk7XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIF9jc3ModCwgbmFtZSwgaW52ZXJ0KTtcbiAgICB0LnNldCh2YWwpOyAvL21heWJlIGNvcHkgYXJncz9cbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn0pOyIsIi8qIVxuICogQGxpY2Vuc2UgQ29weXJpZ2h0IChjKSAyMDEyLTIwMTQsIFZpZ291ci4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIEBhdXRob3I6IEppbSBkZSBCZWVyLCBqaW1Admlnb3VyLmlvXG4gKi9cblxudmFyIG9iamVjdCA9IHJlcXVpcmUoJy4uLy4uL29iamVjdCcpLFxuICB1dGlsID0gcmVxdWlyZSgnLi4vLi4vdXRpbCcpLFxuICBlbGVtZW50ID0gcmVxdWlyZSgnLi4vZWxlbWVudCcpLCAvL2VsZW1lbnQgL3cgZXh0ZW5kXG4gIHZhbHVlID0gcmVxdWlyZSgnLi4vLi4vdmFsdWUnKSxcbiAgZmxhZ3MgPSByZXF1aXJlKCcuLi8uLi92YWx1ZS9mbGFncycpO1xuXG4vKipcbiAqIGNhc2VzXG4gKiBjYXNlcyBhcmUgdXNlZCB0byBzZXQgb25lIG9yIG1vcmUgdmFsdWVzIHdoZW4gYSBzcGVjaWZpYyBjYXNlIGlzIHRydWVcbiAqIHRoZXJlIGFyZSAyIHR5cGVzIG9mIGNhc2VzICwgc3RhdGljIGFuZCBkeW5hbWljICxcbiAqIHN0YXRpYyBjYXNlcyBhcmUgc2V0IGF0IGluaXRpYWxpemF0aW9uIG9mIHRoZSBhcHBsaWNhdGlvbiAsIHVzZWZ1bGwgZm9yIHRoaW5ncyBzdWNoIGFzIGRldmljZSB0eXBlIChwaG9uZSwgZGVza3RvcCwgdHYpXG4gKiBkeW5hbWljIGNhc2VzIGNhbiBiZSBjaGFuZ2VkIGR5bmFtaWNseSBhbmQgT2JqZWN0cyBvciBCYXNlcyB0aGF0IHVzZSB0aGUgY2FzZSB3aWxsIGJlIGNoYW5nZWQgZHluYW1pY2x5IGFzIHdlbGxcbiAqL1xuXG51dGlsLmRlZmluZShleHBvcnRzLCAnbWV0aG9kcycsIHt9KTtcbi8vbXVsdGlwbGUsIHJlY3Vyc2l2ZSBhbmQgb3JpZ2luYWwgaGF2ZSB0byBiZWNvbWUgZXh0ZW5zaW9ucyBvbiBWLk9iamVjdC5jb252ZXJ0IHNvIGl0J3MgcG9zc2libGUgdG8gdXNlIHRoZSBzYW1lIGZvciBkYXRhIGFuZCBldmVudHNcblxudmFyIF9pc09iaiA9IHV0aWwuaXNPYmosXG4gIC8qXG4gICAgX3JlY3VyXG4gICAgc3BlY2lhbCBtZXJnZSB0aGF0IGFkZHMgX19yZW1vdmVfXyBpZiBhIGZpZWxkIGhhcyB0byBiZSByZW1vdmVkXG4gICovXG4gIF9yZWN1ciA9IGZ1bmN0aW9uKG9yaWdpbmFsLCBtZXJnZSwgZmllbGRFeGlzdHMpIHtcblxuICAgIC8vIGNvbnNvbGUubG9nKG9yaWdpbmFsLCBtZXJnZSwgZmllbGRFeGlzdHMpXG5cbiAgICB2YXIga2V5cywgaSwga2V5LCBvcmlnaW5hbENoaWxkLCBtZXJnZUNoaWxkO1xuICAgIGlmIChmaWVsZEV4aXN0cykge1xuICAgICAga2V5cyA9IHt9O1xuICAgICAgZm9yIChrZXkgaW4gb3JpZ2luYWwpIHtcbiAgICAgICAga2V5c1trZXldID0gdHJ1ZTsgLy9rZXlzIGNhbiBiZSB1bmRlZmluZWQgLS0gY29kZSBjYW4gYmVjb21lIHNob3J0ZXJcbiAgICAgIH1cbiAgICB9XG4gICAgZm9yIChpIGluIG1lcmdlKSB7XG4gICAgICBpZiAoIWZpZWxkRXhpc3RzIHx8IGtleXNbaV0pIHtcbiAgICAgICAgb3JpZ2luYWxDaGlsZCA9IG9yaWdpbmFsW2ldO1xuICAgICAgICBtZXJnZUNoaWxkID0gbWVyZ2VbaV07XG4gICAgICAgIGlmIChvcmlnaW5hbENoaWxkIGluc3RhbmNlb2YgT2JqZWN0KSB7XG4gICAgICAgICAgaWYgKG9yaWdpbmFsQ2hpbGQuX19yZW1vdmVfXyAmJiAobWVyZ2VDaGlsZCAmJiAhbWVyZ2VDaGlsZC5fX3JlbW92ZV9fKSkge1xuICAgICAgICAgICAgZGVsZXRlIG9yaWdpbmFsQ2hpbGQuX19yZW1vdmVfXztcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKCEobWVyZ2VDaGlsZCBpbnN0YW5jZW9mIE9iamVjdCkpIHtcbiAgICAgICAgICAgIG1lcmdlW2ldID0ge1xuICAgICAgICAgICAgICB2YWw6IG1lcmdlQ2hpbGRcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfVxuICAgICAgICAgIF9yZWN1cihvcmlnaW5hbENoaWxkLCBtZXJnZUNoaWxkLCBmaWVsZEV4aXN0cyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgb3JpZ2luYWxbaV0gPSBtZXJnZUNoaWxkO1xuICAgICAgICAgIG9yaWdpbmFsQ2hpbGQgPSAnYnVybic7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0sXG4gIC8qXG4gICAgICAgICAgX211bHRpcGxlXG4gICAgICAgICAgbWVyZ2UgbXVsdGlwbGUgb3JnaW5hbHMgaW50byBhIG5ldyBvcmdpbmFsIG9iamVjdCBhbHNvIHJlc29sdmUgbmVzdGVkIGNhc2VzXG4gICAgICAqL1xuICBfbXVsdGlwbGUgPSBmdW5jdGlvbih0LCBuZXN0ZWQsIGNhc2VzLCBjdXJyZW50T2JqLCBjdXJyZW50VmFsLCBiYXNlLCBuYW1lLCBwYXRoLCBvcmlnKSB7XG5cbiAgICBpZiAoIXBhdGgpIHtcbiAgICAgIG9yaWcgPSB0O1xuICAgICAgcGF0aCA9IFtdO1xuICAgIH1cbiAgICB2YXIgaiwgX2Nhc2UsIGN2Q2hpbGQ7XG5cbiAgICBpZigoY3VycmVudFZhbCBpbnN0YW5jZW9mIG9iamVjdCkgJiYgIWJhc2UpIHtcblxuICAgICAgLy8gY3VycmVudE9iai52YWwgPSB0Ll92YWxcbiAgICAgIC8vIGNvbnNvbGUuZXJyb3IoJ1ZPQkonLCBjdXJyZW50T2JqKVxuXG5cbiAgICB9IGVsc2UgaWYgKGN1cnJlbnRWYWwgaW5zdGFuY2VvZiBPYmplY3QpIHtcbiAgICAgIGZvciAoaiBpbiBjdXJyZW50VmFsKSB7XG4gICAgICAgIGN2Q2hpbGQgPSBjdXJyZW50VmFsW2pdO1xuICAgICAgICBpZiAoZXhwb3J0c1tqXSkge1xuICAgICAgICAgIF9jYXNlID0gZXhwb3J0c1tqXTtcbiAgICAgICAgICBpZiAoX2Nhc2UgaW5zdGFuY2VvZiBvYmplY3QpIHtcbiAgICAgICAgICAgIGlmICghYmFzZSB8fCAhZWxlbWVudC5zZXQubG9va3VwLmNhbGwob3JpZywgcGF0aFtwYXRoLmxlbmd0aCAtIDFdKSkgeyAvL2VsZW1lbnQgaXMgcmVxdWlyZWQgaW4gY2FzZXMuYmFzZSwgbWFrZSB0aGlzIHBhcnQgZXh0ZW5kYWJsZVxuICAgICAgICAgICAgICBuZXN0ZWRbal0gPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoIV9pc09iaihjdkNoaWxkKSkge1xuICAgICAgICAgICAgY3VycmVudE9iai52YWwgPSB0ICYmICh0Ll92YWwgIT09IHZvaWQgMCA/IHQuX3ZhbCA6IHZvaWQgMCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHBhdGgucHVzaChqKTtcbiAgICAgICAgICAgIC8vc2hvdWxkIGJlIHBvc3NpYmxlIHRvIHVzZSBuZXN0ZWQgZm9yIGN1cnJlbnQgbmVzdGVkIGNhc2U7XG4gICAgICAgICAgICBfbXVsdGlwbGUodCwgbmVzdGVkLCBjYXNlcywgY3VycmVudE9iaiwgY3ZDaGlsZCwgYmFzZSwgbmFtZSwgcGF0aCwgb3JpZyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGN1cnJlbnRPYmpbal0gPSBudWxsO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmIChfaXNPYmooY3ZDaGlsZCkpIHtcbiAgICAgICAgICAgIGlmICghY3VycmVudE9ialtqXSkge1xuICAgICAgICAgICAgICBjdXJyZW50T2JqW2pdID0gKHQgJiYgdFtqXSAmJiB0W2pdLmNvbnZlcnQgJiYgdFtqXS5jb252ZXJ0KGN2Q2hpbGQpKSB8fCAoY3ZDaGlsZCBpbnN0YW5jZW9mIEFycmF5ID8gW10gOiB7fSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwYXRoLnB1c2goaik7XG4gICAgICAgICAgICBfbXVsdGlwbGUodCAmJiB0W2pdLCBuZXN0ZWQsIGNhc2VzLCBjdXJyZW50T2JqW2pdLCBjdkNoaWxkLCBiYXNlLCBuYW1lLCBwYXRoLCBvcmlnKTtcbiAgICAgICAgICAgIGlmIChiYXNlICYmICghdCB8fCAhdFtqXSkpIHtcbiAgICAgICAgICAgICAgY3VycmVudE9ialtqXS5fX3JlbW92ZV9fID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKHQgJiYgY3VycmVudE9iaiAmJiAhY3VycmVudE9ialtqXSkge1xuICAgICAgICAgICAgICBpZiAoZmxhZ3Nbal0pIHtcbiAgICAgICAgICAgICAgICBkZWxldGUgY3VycmVudE9ialtqXTtcbiAgICAgICAgICAgICAgICBjdXJyZW50T2JqLnZhbCA9IHQuX3ZhbCAhPT0gdm9pZCAwID8gdC5fdmFsIDogdm9pZCAwO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRPYmpbal0gPSBqID09PSAndmFsJyBcbiAgICAgICAgICAgICAgICAgID8gKHQuX3ZhbCAhPT0gdm9pZCAwID8gdC5fdmFsIDogdm9pZCAwKSBcbiAgICAgICAgICAgICAgICAgIDogKHRbal0hPT12b2lkIDAgJiYgdFtqXS5jb252ZXJ0ICYmIHRbal0uY29udmVydCgpKVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4vKlxuICAgICAgb3JpZ2luYWxcbiAgICAgIGNyZWF0ZSBhIG9yZ2luYWwgc3RvcmUgZm9yIGEgbmV3IGNhc2VcbiAgICAqL1xuZXhwb3J0cy5tZXRob2RzLm9yaWdpbmFsID0gZnVuY3Rpb24odCwgaXNPYmosIHZhbCwgY2FzZXMsIGJhc2UsIG5hbWUpIHtcblxuXG5cbiAgdmFyIG9iaiA9IGlzT2JqID8gdC5jb252ZXJ0KHZhbCkgOiB0Ll92YWwsXG4gICAgaSwgY2ZsYWcsIG5lc3RlZCA9IHt9O1xuXG4gIF9tdWx0aXBsZSh0LCBuZXN0ZWQsIGNhc2VzLCBvYmosIHZhbCwgYmFzZSwgbmFtZSk7XG5cbiAgLy8gZm9yKHZhciBpIGluIG5lc3RlZCkge1xuICAvLyAgIGNvbnNvbGUuZXJyb3IoJ05FU1RFRDo6OicsaSk7XG4gIC8vIH1cbiAgLy8gY29uc29sZS5sb2coYmFzZSA/ICdCQVNFOic6ICdQUk9QRVJUWTonICwgbmFtZSwnT1JJR0lOQUwgR0VORVJBVElPTicsJ1xcbnZhbDonLHZhbCwnXFxub2JqOicsb2JqLCdcXG5uZXN0ZWQ6JyxuZXN0ZWQsJ1xcbmNhc2VzOicsY2FzZXMpO1xuXG4gIGZvciAoaSBpbiBjYXNlcykge1xuICAgIGlmICghbmVzdGVkW2ldKSB7XG4gICAgICBjZmxhZyA9IGNhc2VzW2ldLm9yaWc7XG4gICAgICBpZiAoIWlzT2JqKSB7XG4gICAgICAgIGlmIChfaXNPYmooY2ZsYWcpKSB7XG4gICAgICAgICAgaWYgKGNmbGFnLnZhbCkge1xuICAgICAgICAgICAgb2JqID0gY2ZsYWcudmFsO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBvYmogPSBjZmxhZztcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKF9pc09iaihjZmxhZykpIHtcbiAgICAgICAgICBpZiAoIWNhc2VzW2ldLm5lc3RlZFtuYW1lXSkge1xuICAgICAgICAgICAgX3JlY3VyKG9iaiwgY2ZsYWcsIG5hbWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChvYmoudmFsKSB7XG4gICAgICAgICAgb2JqLnZhbCA9IGNmbGFnO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cblxuXG4gIHJldHVybiBbb2JqLCBuZXN0ZWRdO1xufTtcbi8qXG4gIG1lcmdlXG4gIG1lcmdlIGR5bmFtaWMgY2FzZXMgKG92ZXJ3cml0ZSAvdyBjYXNlcyB0aGF0IGFyZSB0cnVlIGFuZCBmdXJ0aGVyIGluIHRoZSBvcmRlciBvZiBjYXNlcylcbiovXG5leHBvcnRzLm1ldGhvZHMubWVyZ2UgPSBmdW5jdGlvbihpc09iaiwgbmFtZSwgdmFsLCBjYXNlcykge1xuICB2YXIgb3JpZ2luYWwgPSB1dGlsLmNsb25lKGNhc2VzW25hbWVdLm9yaWcpLFxuICAgIHNWYWwgPSB2YWwsXG4gICAgb3ZlcndyaXRlLFxuICAgIGksXG4gICAgbWVyZ2UsXG4gICAgb3JpZ2luYWxDaGlsZDtcbiAgZm9yIChpIGluIGNhc2VzKSB7XG4gICAgaWYgKGkgIT09IG5hbWUgJiYgIWNhc2VzW25hbWVdLm5lc3RlZFtpXSkge1xuICAgICAgaWYgKGV4cG9ydHNbaV0udmFsKSB7XG4gICAgICAgIG1lcmdlID0gY2FzZXNbaV0udmFsO1xuICAgICAgICBpZiAoX2lzT2JqKG9yaWdpbmFsKSB8fCBfaXNPYmoobWVyZ2UpKSB7XG4gICAgICAgICAgaWYgKCFfaXNPYmoob3JpZ2luYWwpKSB7XG4gICAgICAgICAgICBvcmlnaW5hbCA9IHtcbiAgICAgICAgICAgICAgdmFsOiBvcmlnaW5hbFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKCFfaXNPYmoobWVyZ2UpKSB7XG4gICAgICAgICAgICBtZXJnZSA9IHtcbiAgICAgICAgICAgICAgdmFsOiBtZXJnZVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9XG4gICAgICAgICAgX3JlY3VyKG9yaWdpbmFsLCBtZXJnZSwgdHJ1ZSk7XG4gICAgICAgICAgZm9yIChpIGluIGV4cG9ydHMpIHtcbiAgICAgICAgICAgIG9yaWdpbmFsQ2hpbGQgPSBvcmlnaW5hbFtpXTtcbiAgICAgICAgICAgIGlmIChvcmlnaW5hbENoaWxkICE9PSBudWxsICYmIG9yaWdpbmFsQ2hpbGQgIT09IHZvaWQgMCkge1xuICAgICAgICAgICAgICBkZWxldGUgb3JpZ2luYWxbaV07IC8vZGVsZXRlIGlzIHByZXR0eSBzbG93XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChvdmVyd3JpdGUpIHtcbiAgICAgICAgICAgIGlmIChpc09iaikge1xuICAgICAgICAgICAgICBpZiAoc1ZhbCA9PT0gdmFsKSB7XG4gICAgICAgICAgICAgICAgc1ZhbCA9IHV0aWwuY2xvbmUoc1ZhbCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgbWVyZ2UgPSB1dGlsLmNsb25lKG1lcmdlKTtcbiAgICAgICAgICAgICAgZm9yIChpIGluIGV4cG9ydHMpIHtcbiAgICAgICAgICAgICAgICBpZiAobWVyZ2VbaV0gIT09IG51bGwgJiYgbWVyZ2VbaV0gIT09IHZvaWQgMCkge1xuICAgICAgICAgICAgICAgICAgLy8gY29uc29sZS5lcnJvcignUkVNT1ZFIEZJWCcsIGkpO1xuICAgICAgICAgICAgICAgICAgZGVsZXRlIG1lcmdlW2ldOyAvL2RlbGV0ZSBpcyBwcmV0dHkgc2xvd1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBfcmVjdXIoc1ZhbCwgbWVyZ2UsIHRydWUpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgaWYgKG1lcmdlLnZhbCkge1xuICAgICAgICAgICAgICAgIHNWYWwgPSBtZXJnZS52YWw7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgb3JpZ2luYWwgPSBtZXJnZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBvdmVyd3JpdGUgPSB0cnVlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gW3NWYWwsIG9yaWdpbmFsXTtcbn07XG4vKlxuICByZWFkZXJcbiAgYWJzdHJhY3Rpb24gZm9yIHVzZSBpbiBjYXNlcy5vYmplY3QgYW5kIGNhc2VzLmJhc2VcbiovXG5leHBvcnRzLm1ldGhvZHMucmVhZGVyID0gZnVuY3Rpb24oZm4sIGR5bmFtaWMsIF9zdGF0aWMpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKG5hbWUsIHZhbCkge1xuICAgIHZhciBpbnZlcnQgPSAobmFtZVswXSA9PT0gJyEnKSxcbiAgICAgIHZDYXNlID0gaW52ZXJ0ID8gZXhwb3J0c1sobmFtZS5zbGljZSgxKSldIDogZXhwb3J0c1tuYW1lXSxcbiAgICAgIHJldDtcbiAgICBpZiAodkNhc2UpIHtcbiAgICAgIGlmICh2Q2FzZSBpbnN0YW5jZW9mIG9iamVjdCkge1xuICAgICAgICBpZiAoaW52ZXJ0ICYmICFleHBvcnRzW25hbWVdKSB7XG4gICAgICAgICAgZXhwb3J0c1tuYW1lXSA9IG5ldyB2YWx1ZSh7XG4gICAgICAgICAgICB2YWw6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICByZXR1cm4gIXZDYXNlLnZhbDtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBsaXN0ZW46IHZDYXNlXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0ID0gZm4gPyBmbi5jYWxsKHRoaXMsIG5hbWUsIHZhbCwgdHJ1ZSwgaW52ZXJ0KSA6IGR5bmFtaWM7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXQgPSBpbnZlcnQgPyAhIWZuIDogZm4gPyBmbi5jYWxsKHRoaXMsIG5hbWUsIHZhbCkgOiBfc3RhdGljXG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChpbnZlcnQpIHtcbiAgICAgIHJldCA9IGZuID8gZm4uY2FsbCh0aGlzLCBuYW1lLCB2YWwsIGZhbHNlLCBpbnZlcnQpIDogX3N0YXRpYztcbiAgICB9XG4gICAgaWYgKHZDYXNlID09PSBmYWxzZSAmJiBmbikge1xuICAgICAgcmV0ID0gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIHJldDtcbiAgfTtcbn07XG5cbnJlcXVpcmUoJy4vb2JqZWN0Jyk7XG5yZXF1aXJlKCcuL2Jhc2UnKTsiLCIvKiFcbiAqIEBsaWNlbnNlIENvcHlyaWdodCAoYykgMjAxMi0yMDE0LCBWaWdvdXIuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBAYXV0aG9yOiBKaW0gZGUgQmVlciwgamltQHZpZ291ci5pb1xuICovXG5cbnZhciBmbGFncyA9IHJlcXVpcmUoJy4uLy4uL3ZhbHVlL2ZsYWdzJyksXG4gIENhc2VzID0gcmVxdWlyZSgnLi8nKSxcbiAgb2JqZWN0ID0gcmVxdWlyZSgnLi4vLi4vb2JqZWN0JyksXG4gIHV0aWwgPSByZXF1aXJlKCcuLi8uLi91dGlsJyksXG4gIG1ldGhvZHMgPSBDYXNlcy5tZXRob2RzLFxuICBkeW5hbWljID0ge1xuICAgIHNldDogZnVuY3Rpb24odmFsLCBzdGFtcCwgcmVzZXQsIG5hbWUpIHtcblxuICAgICAgaWYoIXRoaXMuX2ZsYWcpIHRoaXMuX2ZsYWcgPSB7fVxuXG4gICAgICB2YXIgdCA9IHRoaXMsXG4gICAgICAgICAgLy9zZWxlY3Rpb24gZm9yIHQuX2ZsYWcgZWFzeSBtYWtlblxuICAgICAgICAgIFxuICAgICAgICAgIFxuICAgICAgICBmbGFncyA9IHQuX2ZsYWcuY2FzZSB8fCAodC5fZmxhZy5jYXNlID0gW1xuICAgICAgICAgICdjYXNlJyxcbiAgICAgICAgICB0Ll92YWwsXG4gICAgICAgICAgZmFsc2UsIHt9LFxuICAgICAgICAgIGR5bmFtaWNcbiAgICAgICAgXSksXG4gICAgICAgIGNhc2VzID0gZmxhZ3NbM10sXG4gICAgICAgIGlzT2JqID0gdXRpbC5pc09iaih2YWwpLFxuICAgICAgICBzZXRWYWwgPSAoaXNPYmogJiYgIXZhbC52YWwpID8gZmFsc2UgOiB0cnVlO1xuICAgICAgaWYgKHZhbCA9PT0gbnVsbCkge1xuICAgICAgICBpZiAoY2FzZXNbbmFtZV0pIHtcbiAgICAgICAgICBDYXNlc1tuYW1lXS5yZW1vdmVMaXN0ZW5lcihjYXNlc1tuYW1lXS5tZXRob2QpO1xuICAgICAgICB9XG4gICAgICAgIGRlbGV0ZSBjYXNlc1tuYW1lXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZsYWdzWzVdID0gdHJ1ZTtcbiAgICAgICAgaWYgKCFjYXNlc1tuYW1lXSkge1xuICAgICAgICAgIHZhciB4ID0gbWV0aG9kcy5vcmlnaW5hbCh0LCBpc09iaiwgdmFsLCBjYXNlcywgZmFsc2UsIG5hbWUpO1xuICAgICAgICAgIGNhc2VzW25hbWVdID0ge1xuICAgICAgICAgICAgdmFsOiB2YWwsXG4gICAgICAgICAgICBvcmlnOiB4WzBdLFxuICAgICAgICAgICAgbmVzdGVkOiB4WzFdLFxuICAgICAgICAgICAgbWV0aG9kOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgdmFyIHNldCA9IG1ldGhvZHMubWVyZ2UoaXNPYmosIG5hbWUsIHZhbCwgY2FzZXMpLFxuICAgICAgICAgICAgICBzVmFsID0gc2V0WzBdLFxuICAgICAgICAgICAgICBvcmlnaW5hbCA9IHNldFsxXTtcbiAgICAgICAgICAgICAgZmxhZ3NbNV0gPSB0cnVlOyAvL3RoZSBjbG9zdXJlcyBoZXJlIGFyZSBub3QgcmVhbGx5IG5lc3NlY2FyeSBiZXR0ZXIgdG8gYXZvaWRcbiAgICAgICAgICAgICAgaWYgKENhc2VzW25hbWVdLnZhbCkge1xuICAgICAgICAgICAgICAgIGlmKCFzVmFsKSBjb25zb2xlLndhcm4obmFtZSwnd3JvbmcgaW4gY2FzZXMhJywgc1ZhbCwgQ2FzZXMsIGZsYWdzKVxuICAgICAgICAgICAgICAgIGlmIChzZXRWYWwgJiYgc1ZhbCkge1xuICAgICAgICAgICAgICAgICAgZmxhZ3NbMV0gPSBzVmFsLnZhbCB8fCBzVmFsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0LnZhbCA9IHNWYWw7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKHNldFZhbCkgZmxhZ3NbMV0gPSBvcmlnaW5hbCAmJiBvcmlnaW5hbC52YWwgfHwgb3JpZ2luYWxcbiAgICAgICAgICAgICAgICB0LnZhbCA9IG9yaWdpbmFsO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGZsYWdzWzVdID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9O1xuICAgICAgICAgIENhc2VzW25hbWVdLmFkZExpc3RlbmVyKGZsYWdzWzNdW25hbWVdLm1ldGhvZCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKENhc2VzW25hbWVdLnZhbCkge1xuICAgICAgICAgIGlmIChzZXRWYWwpIHtcbiAgICAgICAgICAgIGZsYWdzWzFdID0gdmFsLnZhbCB8fCB2YWw7XG4gICAgICAgICAgfVxuICAgICAgICAgIG9iamVjdC5zZXQuY2FsbCh0LCB2YWwsIHN0YW1wLCBmYWxzZSwgdHJ1ZSk7XG4gICAgICAgICAgLy9ub3QgYWx3YXlzXG4gICAgICAgICAgdC5faWdub3JlZm9ybm93ID0gdHJ1ZVxuXG4gICAgICAgIH1cbiAgICAgICAgZmxhZ3NbNV0gPSBudWxsO1xuICAgICAgfVxuICAgIH0sXG4gICAgLy8gcmVzZXQ6ZnVuY3Rpb24oKSB7XG4gICAgICAvLyBjb25zb2xlLmVycm9yKCdyZXNldCcpXG4gICAgLy8gfSxcbiAgICAvL2FkZCByZXNldCBsYXRlclxuICAgIHJlbW92ZTogZnVuY3Rpb24oZmxhZ3MsIG5hbWUpIHtcbiAgICAgIC8vIGNvbnNvbGUubG9nKGZsYWdzLCBuYW1lKVxuICAgICAgdmFyIGNudCA9IDBcbiAgICAgIGZvciAodmFyIGkgaW4gZmxhZ3NbM10pIHtcbiAgICAgICAgLy8gaWYoZmxhZ3NbM10pXG4gICAgICAgIGNudCsrXG4gICAgICAgIGlmKCF0aGlzLl9pZ25vcmVmb3Jub3cgJiYgIW5hbWUgfHwgaT09PW5hbWUpIHtcbiAgICAgICAgICBjbnQgLS1cbiAgICAgICAgICBDYXNlc1tpXS5yZW1vdmVMaXN0ZW5lcihmbGFnc1szXVtpXS5tZXRob2QpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGRlbGV0ZSB0aGlzLl9pZ25vcmVmb3Jub3dcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYoY250KSB7XG4gICAgICAgIC8vIGNvbnNvbGUubG9nKCdDQVNFIE9CSkVDVCBSRU1PVkFMIC0tLSBJVCBJUyBOT1QgRU1QWScpXG4gICAgICAgIHJldHVybiB0cnVlXG4gICAgICB9XG4gICAgfSxcbiAgICBzdGFjazogJ2Nhc2UnXG4gIH0sXG4gIF9zdGF0aWMgPSB7XG4gICAgc2V0OiBmdW5jdGlvbih2YWwsIHN0YW1wLCByZXNldCwgbmFtZSkge1xuICAgICAgaWYgKHZhbCAhPT0gbnVsbCkge1xuICAgICAgICBvYmplY3Quc2V0LmNhbGwodGhpcywgdmFsLCBzdGFtcCwgZmFsc2UsIHRydWUpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuZmxhZ3MuZHluYW1pYy5jYXNlcyA9IG1ldGhvZHMucmVhZGVyKGZhbHNlLCBkeW5hbWljLCBfc3RhdGljKTsiLCIvKiFcbiAqIEBsaWNlbnNlIENvcHlyaWdodCAoYykgMjAxMi0yMDE0LCBWaWdvdXIuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBAYXV0aG9yOiBKaW0gZGUgQmVlciwgamltQHZpZ291ci5pb1xuICovXG5cbi8qXG4gIGdldHMgYW5kIGNhY2hlcyB2YWx1ZXMgZm9yIGNzcyBjbGFzc2VzLCBhbHNvIHBvc3NpYmxlIHRvIGNoYW5nZSBzdHlsZXMgb2YgY2xhc3Nlc1xuICByZXR1cm4gYW4gYXJyYXkgb2YgbXVsdGlwbGUgY3NzIG9iamVjdHMgY29ycmVzcG9uZGluZyB0byB0aGUgY2xhc3MgbmFtZVxuICB3aGVuIHlvdSBwYXNzIGZpZWxkIGl0IHNlYXJjaGVzIHRoZSBmaWVsZCB0cm91Z2ggYWxsIHRoZSBjbGFzc2VzIHNlbGVjdGVkLCBhbHdheXMgdGFrZXMgZmlyc3QgYXJndW1lbnRcbiAgbWF5YmUgaGF2ZSB0byBtYWtlIHRoaXMgZm9yIHRoaW5ncyBzdWNoIGFzIGRpdiBzZWxlY3RvcnMgLyBuZXN0ZWQgc3R1ZmYgLS0tIHdpbGwgYmUgY3B1IGludGVuc2l2ZSE7XG4qL1xudmFyIHNlbGVjdG9yID0gJ2Nzc1J1bGVzJyxcbiAgcGFyc2VjbGFzcyA9IGZ1bmN0aW9uKHNsY3RyKSB7XG4gICAgc2xjdHIgPSAnLicgKyBzbGN0ci5yZXBsYWNlKC9cXC4vZywgJyAuJykudG9Mb3dlckNhc2UoKTtcbiAgICBmb3IgKHZhciByb2JqLCBzZWxlY3QgPSBkb2N1bWVudC5zdHlsZVNoZWV0cywgbGVuZ3RoID0gc2VsZWN0Lmxlbmd0aCwgaSA9IDAsIHNlbGVjdEl0ZW07IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgc2VsZWN0SXRlbSA9IHNlbGVjdFtpXVtzZWxlY3Rvcl0gfHwgc2VsZWN0W2ldWyhzZWxlY3RvciA9ICdydWxlcycpXTsgLy9sb2NhdGlvbiBvZiB0aGlzIHBvbHlmaWxsIGNhbiBiZSBpbXByb3ZlZFxuICAgICAgaWYoc2VsZWN0SXRlbSkge1xuICAgICAgICBmb3IgKHZhciBqID0gMCwgbCA9IHNlbGVjdEl0ZW0ubGVuZ3RoLCBpdGVtOyBzZWxlY3RJdGVtLCBqIDwgbDsgaXRlbSA9IHNlbGVjdEl0ZW1baisrXSwgaXRlbS5zZWxlY3RvclRleHQgPT09IHNsY3RyICYmIChyb2JqID0gaXRlbS5zdHlsZSkpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcm9iajtcbiAgfSxcbiAgYyA9IGZ1bmN0aW9uKGNzc0NsYXNzLCBjYWNoZSkge1xuICAgIHZhciB0ID0gZXhwb3J0cztcbiAgICBjYWNoZS5wdXNoKHRbY3NzQ2xhc3NdIHx8ICh0W2Nzc0NsYXNzXSA9IHBhcnNlY2xhc3MoY3NzQ2xhc3MpKSB8fCB7fSk7XG4gICAgcmV0dXJuIGNzc0NsYXNzO1xuICB9O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKHNsY3RyLCBmaWVsZCkge1xuICBpZiAoc2xjdHIpIHtcbiAgICB2YXIgY2FjaGUgPSB0aGlzW3NsY3RyXTtcbiAgICBpZiAoIWNhY2hlKSB7XG4gICAgICBjYWNoZSA9IFtdO1xuICAgICAgZm9yICh2YXIgc2VsZWN0YXJyYXkgPSBzbGN0ci5zcGxpdCgnICcpLCBpID0gMCwgbCA9IHNlbGVjdGFycmF5Lmxlbmd0aCwgY3NzQ2xhc3M7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgaWYgKChjc3NDbGFzcyA9IGMoc2VsZWN0YXJyYXlbaV0sIGNhY2hlKS5zcGxpdCgnLicpKSBpbnN0YW5jZW9mIEFycmF5KSB7XG4gICAgICAgICAgYyhjc3NDbGFzc1tjc3NDbGFzcy5sZW5ndGggLSAxXSwgY2FjaGUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB0aGlzW3NsY3RyXSA9IGNhY2hlO1xuICAgIH1cbiAgICBpZiAoZmllbGQpIHtcbiAgICAgIGlmKCEoY2FjaGUgaW5zdGFuY2VvZiBBcnJheSkpXG4gICAgICAgIHJldHVyblxuICAgICAgZm9yICh2YXIgcmV0LCBpID0gY2FjaGUubGVuZ3RoIC0gMTsgIXJldCAmJiBpID49IDA7IHJldCA9IGNhY2hlW2ktLV1bZmllbGRdKTtcbiAgICAgIGNhY2hlID0gcmV0OyAgXG4gICAgfVxuICAgIHJldHVybiBjYWNoZTtcbiAgfVxufTsiLCIvKiFcbiAqIEBsaWNlbnNlIENvcHlyaWdodCAoYykgMjAxMi0yMDE0LCBWaWdvdXIuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBAYXV0aG9yOiBKaW0gZGUgQmVlciwgamltQHZpZ291ci5pb1xuICovXG52YXIgYmFzZSA9IHJlcXVpcmUoJy4uLy4uL2Jhc2UnKVxuICAsIHZhbHVlQmFzZSA9IHJlcXVpcmUoJy4uLy4uL3ZhbHVlL2Jhc2UnKVxuICAsIHZpZ291ciA9IHJlcXVpcmUoJy4uLy4uLycpXG4gICwgdXRpbCA9IHJlcXVpcmUoJy4uLy4uL3V0aWwnKVxuICAsIGVsZW1lbnRCYXNlID0gbmV3IGJhc2UoKVxuXG5lbGVtZW50QmFzZS5kZWZhdWx0VHlwZSA9IHZhbHVlQmFzZS50eXBlXG5cbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0cyA9IHZpZ291ci5FbGVtZW50ID0gZWxlbWVudEJhc2UuQ2xhc3NcbmV4cG9ydHMuYmFzZSA9IGVsZW1lbnRCYXNlXG5cbnZhciBfZG9jID0gdHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJyA/IGRvY3VtZW50IDogJ25vIGRvY3VtZW50JywgLy9yZWZlcmVuY2UgdG8gZG9jdW1lbnQgaXMgZmFzdGVyIHRoYW4gdXNpbmcgd2luZG93LmRvY3VtZW50O1xuICAvKipcbiAgICogUmVtb3ZlcyBjaGlsZHJlbiBmcm9tIHBhcmVudCBub2RlXG4gICAqIEBtZXRob2QgX3JlbW92ZUNoaWxkcmVuXG4gICAqL1xuICBfcmVtb3ZlQ2hpbGRyZW4gPSBmdW5jdGlvbigpIHtcbiAgICBmb3IgKHZhciBjID0gdGhpcy5fbm9kZS5jaGlsZE5vZGVzLCBpID0gMCwgbCA9IGMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICBpZiAoY1tpXS5iYXNlKSB7XG4gICAgICAgIC8vIGNvbnNvbGUubG9nXG4gICAgICAgIGNbaV0uYmFzZS5yZW1vdmUoZmFsc2UsIGZhbHNlLCB0cnVlKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbi8qKlxuICogbm9kZVxuICogYWRkcyBhbmQgY2xvbmVzIGh0bWwgbm9kZXM7XG4gKiBAYXR0cmlidXRlXG4gKi9cbmV4cG9ydHMuYmFzZS5leHRlbmQoe1xuICAgIG5hbWU6ICdub2RlJyxcbiAgICB0eXBlOiBmYWxzZSAsXG4gICAgLyoqXG4gICAgICogRGVmaW5lcyB3aGF0IGhhcHBlbnMgd2hlbiBub2RlIGlzIHNldFxuICAgICAqIEBtZXRob2Qgc2V0XG4gICAgICogQHBhcmFtICB7Kn0gdmFsIERlZmluZXMgdGhlIHZhbHVlIG9mIHRoaXMuX25vZGVcbiAgICAgKi9cbiAgICBzZXQ6IGZ1bmN0aW9uKHZhbCkge1xuICAgICAgLy9jaGFuZ2luZyBub2RlIGJ1Z3MgL3cgY29udmVyc2lvbnNcbiAgICAgIC8vaWZyYW1lIHNlbGVjdG9ycyBkb250IGV2YWx1YXRlIHRvIGEgc3RyaW5nXG4gICAgICBpZiAodmFsIGluc3RhbmNlb2YgT2JqZWN0IHx8ICF2YWwubGVuZ3RoKSB7XG4gICAgICAgIHRoaXMuX25vZGUgPSB2YWw7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl9ub2RlID0gX2RvYy5jcmVhdGVFbGVtZW50KHZhbCk7XG4gICAgICB9XG4gICAgICB0aGlzLl9ub2RlLmJhc2UgPSB0aGlzO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogRGVmaW5lcyB3aGF0IGhhcHBlbnMgd2hlbiB5b3UgZ2V0IG5vZGVcbiAgICAgKiBAbWV0aG9kIGdldFxuICAgICAqL1xuICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICBpZiAoIXRoaXMuX25vZGUpIHtcbiAgICAgICAgdGhpcy5ub2RlID0gX2RvYy5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLl9ub2RlO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogRGVmaW5lcyB3aGF0IGhhcHBlbnMgd2hlbiB5b3UgY3JlYXRlIGEgbmV3IG5vZGVcbiAgICAgKiBAbWV0aG9kIG5ld1xuICAgICAqIEBwYXJhbSAge09iamVjdH0gZnJvbSAgICBUYXJnZXRcbiAgICAgKiBAcGFyYW0gIHtbdHlwZV19IG5ld25vZGUgW2Rlc2NyaXB0aW9uXVxuICAgICAqL1xuICAgIFwibmV3XCI6IGZ1bmN0aW9uKGZyb20sIG5ld25vZGUpIHtcbiAgICAgIGlmICghbmV3bm9kZSkge1xuICAgICAgICB2YXIgbm9kZSA9IGZyb20uX25vZGU7XG4gICAgICAgIGlmIChub2RlKSB7XG4gICAgICAgICAgdGhpcy5fbm9kZSA9IG5vZGUuY2xvbmVOb2RlKHRydWUpOyAvL2VzcGVjaWFseSBnb29kIHRvIGRvIGZvciBtZW1vcnkgKGFsc28gc2F2ZXMgMjAlIG9uIGNwdSlcbiAgICAgICAgICB0aGlzLl9ub2RlLmJhc2UgPSB0aGlzO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl9ub2RlID0gbmV3bm9kZTtcbiAgICAgIH1cbiAgICAgIGlmIChmcm9tLl9ub2RlICYmIGZyb20uX25vZGUuaGFzQ2hpbGROb2RlcygpKSB7XG4gICAgICAgIHZhciBpLCBjID0gdGhpcy5fbm9kZS5jaGlsZE5vZGVzLFxuICAgICAgICAgIGNmID0gZnJvbS5fbm9kZS5jaGlsZE5vZGVzLFxuICAgICAgICAgIGwgPSBjLmxlbmd0aCxcbiAgICAgICAgICBjaSwgY2ZiO1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgY2ZiID0gY2ZbaV0uYmFzZTtcbiAgICAgICAgICBpZiAoY2ZiKSB7XG4gICAgICAgICAgICBjW2ldLmJhc2UgPSBuZXcgY2ZiLkNsYXNzKGZhbHNlLCBmYWxzZSwgY1tpXSk7XG4gICAgICAgICAgICAvL21heWJlIGNhbGwgY2hpbGRyZW4gbmV3IHN0dWZmIHdpdGggYSBjdXN0b20gc2V0dGluZyBhcyB3ZWxsP1xuICAgICAgICAgICAgaWYgKGNmYi5fbmFtZSkge1xuICAgICAgICAgICAgICBjW2ldLmJhc2UuX25hbWUgPSBjZmIuX25hbWU7XG4gICAgICAgICAgICAgIHRoaXNbY2ZiLl9uYW1lXSA9IGNbaV0uYmFzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNbaV0uYmFzZS5zZXR0aW5nKCdwYXJlbnQnLCBbdGhpc10pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgLyoqXG4gICAgICogRGVmaW5lcyB3aGF0IGhhcHBlbnMgd2hlbiB5b3UgcmVtb3ZlIGEgbm9kZVxuICAgICAqIEBtZXRob2QgcmVtb3ZlXG4gICAgICogQHBhcmFtICB7Kn0gIFtwYXJhbV0gSWYgcGFyYW0gZG9lc24ndCByZW1vdmUgbm9kZSBmcm9tIHBhcmVudFxuICAgICAqL1xuICAgIHJlbW92ZTogZnVuY3Rpb24ocGFyYW0pIHtcbiAgICAgIF9yZW1vdmVDaGlsZHJlbi5jYWxsKHRoaXMpO1xuICAgICAgaWYodGhpcy5fbm9kZSkgdGhpcy5fbm9kZS5iYXNlID0gbnVsbCAvL2xpdHRsZSBzbG93IG9wdGltaXplIGxhdGVyXG4gICAgICBpZiAoIXBhcmFtKSB7XG4gICAgICAgIHZhciBfcCA9IHRoaXMuX25vZGUucGFyZW50Tm9kZTtcbiAgICAgICAgaWYgKF9wKSB7XG4gICAgICAgICAgX3AucmVtb3ZlQ2hpbGQodGhpcy5fbm9kZSk7XG4gICAgICAgICAgaWYgKHRoaXMuX25hbWUgJiYgX3AuYmFzZSkge1xuICAgICAgICAgICAgX3AuYmFzZVt0aGlzLl9uYW1lXSA9IG51bGw7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9LFxuICAvKipcbiAgICogU2V0IGNzcyBjbGFzcyBvZiBhIGRpdlxuICAgKiBVc2UgYWRkQ2xhc3Mgb3IgcmVtb3ZlQ2xhc3MgdG8gYWRkL3JlbW92ZSBhIGNsYXNzXG4gICAqIEBhdHRyaWJ1dGUgY3NzXG4gICAqIEBwYXJhbSAge09iamVjdH0gdmFsIFtkZXNjcmlwdGlvbl1cbiAgICogd2FybmluZzogdGhlIGFkZCBvcGVyYXRvciBpbiBjc3MgaXMgY3VycmVudGx5IHVzZWQgYnkgLm5hbWUsXG4gICAqIGFuZCB3aWxsIGJlIHJlcGxhY2VkIHdoZW4geW91IHRyeSB0byBidWlsZCBhIHN0cmluZ1xuICAgKiB1c2luZyB7dmFsOiAuLi4uIGFkZDogLi4uLn1cbiAgICovXG4gIHtcbiAgICBjc3M6IGZ1bmN0aW9uKHZhbCkge1xuICAgICAgdmFyIF92YWwgPSB2YWwudmFsIHx8ICcnO1xuICAgICAgdmFsLl9za2lwID0gdHJ1ZTsgLy9fc2tpcCBpcyBhbiB1Z2x5IG5hbWVcbiAgICAgIGlmICh2YWwuYWRkQ2xhc3MgJiYgIX5fdmFsLmluZGV4T2YodmFsLmFkZENsYXNzLnZhbCkpIHtcblxuICAgICAgICB2YWwuX3ZhbCA9ICgoX3ZhbC5sZW5ndGggPiAwID8gX3ZhbCArICcgJyA6ICcnKSArIHZhbC5hZGRDbGFzcy52YWwpO1xuXG4gICAgICAgIGlmKHZhbC5hZGQpIHZhbC5fdmFsID0gdmFsLl92YWwucmVwbGFjZSh2YWwuYWRkLnZhbCwnJylcblxuICAgICAgICB2YWwuX2x2YWwgPSBmYWxzZTtcbiAgICAgICAgdmFsLl9fbHZhbCA9IGZhbHNlO1xuICAgICAgICB2YWwuYWRkQ2xhc3MucmVtb3ZlKCk7XG4gICAgICAgIF92YWwgPSB2YWwudmFsO1xuICAgICAgICAvLyBjb25zb2xlLmVycm9yKCc/Pz8/IFJFU1VMVCBDTEFTUyEnLCB2YWwuX3ZhbCApXG4gICAgICB9XG4gICAgICBpZiAoX3ZhbCAmJiB2YWwucmVtb3ZlQ2xhc3MgJiYgdmFsLl92YWwpIHtcbiAgICAgICAgdmFsLl92YWwgPSB2YWwuX3ZhbC5yZXBsYWNlKG5ldyBSZWdFeHAoJyA/JyArIHZhbC5yZW1vdmVDbGFzcy52YWwpLCAnJyk7XG4gICAgICAgIHZhbC5fbHZhbCA9IGZhbHNlO1xuICAgICAgICB2YWwuX19sdmFsID0gZmFsc2U7XG4gICAgICAgIHZhbC5yZW1vdmVDbGFzcy5yZW1vdmUoKTtcbiAgICAgICAgX3ZhbCA9IHZhbC52YWw7XG4gICAgICB9XG4gICAgICB0aGlzLm5vZGUuY2xhc3NOYW1lID0gX3ZhbDtcbiAgICB9XG4gIH0sXG4gIC8qKlxuICAgKiBNYWtlcyBpdCBwb3NzaWJsZSB0byByZWZlcmVuY2UgYSBjaGlsZCBieSBuYW1lXG4gICAqIFNldHRpbmcgb24gYSBjbGFzcyBkb2VzIG5vdCB1cGRhdGUgbmFtZXMgb2YgaW5zdGFuY2VzXG4gICAqIEVsZW1lbnRbTkFNRV1cbiAgICogQGF0dHJpYnV0ZSBuYW1lXG4gICAqL1xuICB7XG4gICAgbmFtZTogJ25hbWUnLFxuICAgIHR5cGU6IGZhbHNlLFxuICAgIHNldDogZnVuY3Rpb24odmFsKSB7XG4gICAgICB2YXIgX3AgPSB0aGlzLnBhcmVudDtcbiAgICAgIGlmICh0aGlzLl9uYW1lKSB7XG4gICAgICAgIGlmIChfcCkge1xuICAgICAgICAgIF9wW3RoaXMuX25hbWVdID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdGhpcy5fbmFtZSA9IHZhbDtcbiAgICAgIGlmICghdGhpcy5fbm9kZSB8fCB2YWwgIT09IHRoaXMubm9kZS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpKSB7XG4gICAgICAgIC8vbmFtZSBkb2VzIG5vdCBpbmhlcml0LCBiZXdhcmUhXG4gICAgICAgIC8vIGNvbnNvbGUubG9nKCdXSEFUUyBUSElTPycsdmFsKTtcbiAgICAgICAgLy8gdGhpcy5jc3MgPSB7YWRkQ2xhc3M6dmFsfTtcbiAgICAgICAgLy8gdGhpcy5jbGFzc05hbWUgPSB0aGlzLl9uYW1lO1xuICAgICAgICBpZighdGhpcy5jc3MgfHwgdGhpcy5jc3MuX3ZhbCE9PXZhbCl0aGlzLmNzcyA9IHsgYWRkOiAnICcgKyB2YWwgfVxuICAgICAgICAvL3NwZWNpYWwgbmFtZSBmaWVsZD9cbiAgICAgIH1cbiAgICAgIGlmIChfcCkge1xuICAgICAgICBfcFt2YWxdID0gdGhpcztcbiAgICAgIH1cbiAgICB9LFxuICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5fbmFtZTtcbiAgICB9XG4gIH0sXG4gIC8qKlxuICAgKiBSZXR1cm5zIHBhcmVudCBiYXNlIGVsZW1lbnRcbiAgICogQGF0dHJpYnV0ZSBwYXJlbnRcbiAgICovXG4gIHtcbiAgICBuYW1lOiAncGFyZW50JyxcbiAgICB0eXBlOiBmYWxzZSxcbiAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKHRoaXMuX25vZGUpIHtcbiAgICAgICAgdmFyIF9wID0gdGhpcy5fbm9kZS5wYXJlbnROb2RlIHx8IHRoaXMuX3A7XG4gICAgICAgIHJldHVybiBfcCA/IF9wLmJhc2UgfHwgX3AuX3AgOiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gIH0sXG4gIC8qKlxuICAgKiBSZXR1cm5zIGNoaWxkTm9kZXMgL3cgYmFzZSBjbGFzc2VzIGFycmF5IHNsb3csIGNhY2hlIGlmIHBvc3NpYmxlXG4gICAqIEBhdHRyaWJ1dGUgY2hpbGRyZW5cbiAgICovXG4gIHtcbiAgICBuYW1lOiAnY2hpbGRyZW4nLFxuICAgIHR5cGU6IGZhbHNlLFxuICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICBpZighdGhpcy5fbm9kZSkgcmV0dXJuIFtdXG4gICAgICB2YXIgYyA9IHRoaXMuX25vZGUuY2hpbGROb2RlcyxcbiAgICAgICAgbCA9IGMubGVuZ3RoLFxuICAgICAgICBfYyA9IG5ldyBBcnJheShsKSxcbiAgICAgICAgaTtcbiAgICAgIGZvciAoaSA9IDA7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgX2NbaV0gPSBjW2ldLmJhc2UgfHwgY1tpXTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBfYztcbiAgICB9XG4gIH0pO1xuXG52YXIgcmVjdXJSZW5kZXIgPSBmdW5jdGlvbihwYXJlbnQpIHtcblxuICBpZiAoIXRoaXMubGFzdGluZGV4KSB0aGlzLnNldHRpbmcoJ3JlbmRlcicsIFtwYXJlbnRdKSAvL2V4ZWN1dGUgcmVuZGVyIHNldHRpbmdzXG5cbiAgaWYgKHRoaXMucmVuZGVycykge1xuXG4gICAgLy8gY29uc29sZS5lcnJvcignUkVOREVSIC0tLScsIHRoaXMubmFtZSwgdGhpcy5yZW5kZXJzKVxuXG4gICAgZm9yICh2YXIgcFxuICAgICAgLCBjID0gdGhpcy5ub2RlLmNoaWxkTm9kZXNcbiAgICAgICwgY2xcbiAgICAgICwgYXJyID0gdGhpcy5yZW5kZXJzXG4gICAgICAsIG9ialxuICAgICAgLCBpID0gdGhpcy5sYXN0aW5kZXggfHwgMCwgbCA9IGFyci5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIG9iaiA9IGFycltpXVxuXG4gICAgIGlmKG9iaikge1xuICAgICAgICBwID0gdXRpbC5jaGVja0FycmF5KGMsIG9iaiwgJ2Jhc2UnKVxuICAgICAgICBpZiAocCAhPT0gZmFsc2UpIHtcbiAgICAgICAgICByZWN1clJlbmRlci5jYWxsKG9iaiwgdGhpcylcbiAgICAgICAgfSBlbHNlIGlmKG9iai5fZnJvbSkge1xuXG4gICAgICAgICAgLy8gY29uc29sZS5sb2coJ0NMQVNTIScsb2JqLCBvYmoubmFtZSAmJiB0aGlzW29iai5uYW1lXSAmJiB0aGlzW29iai5uYW1lXSA9PT0gY2wpXG5cbiAgICAgICAgICBjbCA9IG9iai5DbGFzc1xuXG4gICAgICAgICAgaWYob2JqLm5hbWUgJiYgdGhpc1tvYmoubmFtZV0gJiYgdGhpc1tvYmoubmFtZV0gPT09IGNsKSB7XG4gICAgICAgICAgICByZWN1clJlbmRlci5jYWxsKHRoaXNbb2JqLm5hbWVdLCB0aGlzKVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgIGZvciAodmFyIGogaW4gYykge1xuICAgICAgICAgICAgIGlmIChjW2pdLmJhc2UgJiYgY1tqXS5iYXNlIGluc3RhbmNlb2YgY2wpIHtcbiAgICAgICAgICAgICAgIHJlY3VyUmVuZGVyLmNhbGwoY1tqXS5iYXNlLCB0aGlzKVxuICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgLy8gYXJyLnNwbGljZShpLDEpXG4gICAgfVxuICB9XG5cbiAgdGhpcy5sYXN0aW5kZXggPSBsXG59LFxuXG5zZXRSZW5kZXIgPSBmdW5jdGlvbigpIHtcbiAgdmFyIHAsIHBwO1xuICBpZiAodGhpcy5wYXJlbnQpIHtcbiAgICBwID0gdGhpcy5wYXJlbnQ7XG4gICAgaWYgKHAucmVuZGVycykge1xuICAgICAgcC5yZW5kZXJzLnB1c2godGhpcyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHAucmVuZGVycyA9IFt0aGlzXTtcbiAgICAgIHBwID0gcC5wYXJlbnQ7XG4gICAgICBpZiAocHAgJiYgIShwcC5fc2V0dGluZ3MgJiYgcHAuX3NldHRpbmdzLnJlbmRlciAhPT0gdHJ1ZSkpIHtcbiAgICAgICAgc2V0UmVuZGVyLmNhbGwocCk7XG4gICAgICB9XG4gICAgfVxuICB9XG59LFxuXG52YWxSZW5kZXIgPSBmdW5jdGlvbih2YWwpIHtcbiAgdmFyIF9zZXR0aW5ncyA9ICh2YWwuX18gJiYgdmFsLl9fLl9zZXR0aW5ncyB8fCB2YWwuXy5fc2V0dGluZ3MpXG4gIGlmICh2YWwuXy5yZW5kZXJzIHx8IHZhbC5fXyAmJiB2YWwuX18ucmVuZGVycyB8fCBfc2V0dGluZ3MucmVuZGVyICE9PSB0cnVlKSB7XG4gICAgaWYgKCF0aGlzLnJlbmRlcnMpIHRoaXMucmVuZGVycyA9IFtdXG4gICAgaWYgKCEodGhpcy5fXyAmJiB0aGlzLl9fLnJlbmRlcnMpKSB0aGlzLnJlbmRlcnMgPSB1dGlsLmNsb25lKHRoaXMucmVuZGVycylcbiAgICAvLyBjb25zb2xlLmxvZyh0aGlzLnJlbmRlcnM9PT10aGlzLl9fLnJlbmRlcnMsIHRoaXMuX18ucmVuZGVycywgdGhpcy5fLnJlbmRlcnMpXG5cbiAgICAvLyBjb25zb2xlLmxvZyh1dGlsLmNoZWNrQXJyYXkodGhpcy5yZW5kZXJzLHZhbC5fZnJvbSkpXG4gICAgLy8gY29uc29sZS5sb2coJ1hYWFhYWCcsdmFsKVxuICAgIC8vIGlmKHV0aWwuY2hlY2tBcnJheSh0aGlzLnJlbmRlcnMsdmFsLl9mcm9tLl9mcm9tLCdfZnJvbS5fZnJvbScpPT09ZmFsc2UmJnV0aWwuY2hlY2tBcnJheSh0aGlzLnJlbmRlcnMsdmFsLl9mcm9tLCdfZnJvbScpPT09ZmFsc2UpIHtcbiAgICAgIHRoaXMucmVuZGVycy5wdXNoKHZhbClcbiAgICAvLyB9XG4gICAgLy8gY29uc29sZS5sb2coJ3JlbmRlcnMgcHVzaCAtLS0gY3JlYXRlcyBsZWFrcyEnKVxuICB9XG59XG5cbi8vZGVmaW5lIHZhbnVpdCBiYXNlIChrb3J0ZXIhKVxudXRpbC5kZWZpbmUoZXhwb3J0cyxcbiAgICdhcHBlbmQnLCBmdW5jdGlvbihhcnIpIHtcblxuICAgIC8vIGFsZXJ0KCdBUFBFTkQnKVxuICAgIC8vIGNvbnNvbGUubG9nKCdBUFBFTkQnLmludmVyc2UsYXJyKVxuXG4gICAgICB2YXIgYXJncyA9IGFyZ3VtZW50c1xuXG4gICAgICBpZihhcmd1bWVudHMubGVuZ3RoPjEpIHtcbiAgICAgICAgYXJyID0gdXRpbC5hcmcoYXJndW1lbnRzKVxuICAgICAgfSAvL2Vsc2UgaWYoYXJyIClcblxuICAgICAgdmFyIGluc2VydGJlZm9yZVxuICAgICAgaWYoIWFyci5sZW5ndGggJiYgIShhcnIgaW5zdGFuY2VvZiBleHBvcnRzKSAmJiBhcnIudmFsKSB7XG4gICAgICAgIGluc2VydGJlZm9yZSA9IGFyci5iZWZvcmVcbiAgICAgICAgYXJyID0gYXJyLnZhbFxuICAgICAgfVxuICAgICAgdmFyIENsYXNzID0gYXJyWzBdXG4gICAgICAsIGkgPSAwXG4gICAgICAsIGwgPSBhcnIubGVuZ3RoXG4gICAgICBpZighYXJyLmxlbmd0aCkge1xuICAgICAgICB0aGlzLmFkZChhcnIsIGluc2VydGJlZm9yZSlcbiAgICAgIH0gZWxzZSBpZih0eXBlb2YgQ2xhc3MgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgZm9yKHZhciBpPTEsIGwgPSBhcnIubGVuZ3RoO2k8bDtpKyspIHtcbiAgICAgICAgICB0aGlzLmFkZChuZXcgQ2xhc3MoYXJyW2ldKSwgaW5zZXJ0YmVmb3JlKVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmb3IoO2k8bDtpKyspIHtcbiAgICAgICAgICB0aGlzLmFkZChhcnJbaV0sIGluc2VydGJlZm9yZSlcbiAgICAgICAgfVxuICAgICAgfVxuICB9LFxuICAnY2hlY2tSZW5kZXInLCBmdW5jdGlvbih2YWwsIG5vdFJlbmRlcmVkKSB7XG4gICAgaWYgKHZhbCkgdmFsUmVuZGVyLmNhbGwodGhpcywgdmFsKVxuICAgIGlmICghbm90UmVuZGVyZWQpIHtcbiAgICAgIHZhciBfcmVuZGVycyA9ICh0aGlzLl9fICYmIHRoaXMuX18ucmVuZGVycyB8fCB0aGlzLl8ucmVuZGVycylcbiAgICAgIGlmICggKCAoX3JlbmRlcnMgIHx8ICgodGhpcy5fXyAmJiB0aGlzLl9fLl9zZXR0aW5ncykgIHx8IHRoaXMuXy5fc2V0dGluZ3MpLnJlbmRlciAhPT0gdHJ1ZSlcbiAgICAgICAgICAmJiAoIXRoaXMubGFzdGluZGV4IHx8IChfcmVuZGVycyAmJiB0aGlzLmxhc3RpbmRleCA8IF9yZW5kZXJzLmxlbmd0aCkpXG4gICAgICAgICkgJiYgdGhpcy5yZW5kZXJlZCkge1xuICAgICAgICByZWN1clJlbmRlci5jYWxsKHRoaXMsIHRoaXMpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZih0aGlzLnBhcmVudCkgdmFsUmVuZGVyLmNhbGwodGhpcy5wYXJlbnQsIHRoaXMpXG4gICAgICB9XG4gICAgfVxuICB9LFxuICAnY2hlY2tQYXJlbnQnLCB1dGlsLmNoZWNrUGFyZW50RmFjdG9yeSgncGFyZW50JyksXG4gICdnZXQnLGZ1bmN0aW9uKHBhdGgsIHNlbGYpIHsgLy9nZXQgZG9lcyBub3QgbmVlZCBhbiBhcnJheSBhcyBwYXRoXG4gICAgcmV0dXJuIHV0aWwuZ2V0KHRoaXMsIHBhdGgsIHNlbGYpO1xuICB9LFxuICAnZmluZCcsIGZ1bmN0aW9uKGdldCwgbWF0Y2gsIGxldmVsKSB7XG4gICAgaWYobGV2ZWwgPT09IHZvaWQgMCkgbGV2ZWwgPSB0cnVlXG4gICAgdmFyIGNoaWxkcmVuID0gdGhpcy5ub2RlLmNoaWxkTm9kZXNcbiAgICAgICwgaSA9IDBcbiAgICAgICwgZm91bmRcbiAgICAgICwgY2hpbGRcbiAgICAgICwgbGVuID0gY2hpbGRyZW4ubGVuZ3RoXG4gICAgICAsIHBhc3NPbiA9IGxldmVsPT09dHJ1ZSA/IHRydWUgOiBsZXZlbC0xXG4gICAgZm9yKDtpPGxlbjtpKyspIHtcbiAgICAgIGNoaWxkID0gY2hpbGRyZW5baV0uYmFzZVxuICAgICAgaWYoY2hpbGQpIHtcbiAgICAgICAgaWYoY2hpbGQuZ2V0KGdldCwgdHJ1ZSk9PW1hdGNoKSB7XG4gICAgICAgICAgcmV0dXJuIGNoaWxkXG4gICAgICAgIH0gZWxzZSBpZihsZXZlbCkge1xuICAgICAgICAgIGZvdW5kID0gY2hpbGQuZmluZChnZXQsIG1hdGNoLCBwYXNzT24pXG4gICAgICAgICAgaWYoZm91bmQpIHJldHVybiBmb3VuZFxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9LFxuICAnc2V0UmVuZGVyJywgZnVuY3Rpb24obmFtZSwgdmFsKSB7XG4gICAgdGhpcy5zZXRTZXR0aW5nKHtcbiAgICAgIG5hbWU6IG5hbWUsXG4gICAgICByZW5kZXI6IHZhbFxuICAgIH0pO1xuICAgIHNldFJlbmRlci5jYWxsKHRoaXMpO1xuICAgIHRoaXMuZWFjaEluc3RhbmNlKGZ1bmN0aW9uKCkgeyAvL2xvb2sgZm9yIGN1cnJlbnQgY2FsbGVyIGluc3RhbmNlIHBlcmhhcHM/XG4gICAgICBzZXRSZW5kZXIuY2FsbCh0aGlzKVxuICAgIH0sIG5hbWUpO1xuICB9LFxuICAncmVuZGVycycsIGZhbHNlLFxuICAvKipcbiAgICogQWRkIGVsZW1lbnQgYXMgY2hpbGRcbiAgICogQG1ldGhvZFxuICAgKiBAcGFyYW0gIHtPYmplY3R9ICB2YWwgIE9iamVjdCB0byBiZSBhZGRlZFxuICAgKiBAcmV0dXJuIHtPYmplY3R9ICAgICAgIFJldHVybnMgdGhlIFYuZWxlbWVudFxuICAgKi9cbiAgJ2FkZCcsIGZ1bmN0aW9uKHZhbCwgaW5zZXJ0YmVmb3JlKSB7XG4gICAgXG4gICAgaWYoaW5zZXJ0YmVmb3JlKSB7XG4gICAgICBpZih0eXBlb2YgaW5zZXJ0YmVmb3JlID09PSAnc3RyaW5nJykgaW5zZXJ0YmVmb3JlID0gdGhpc1tpbnNlcnRiZWZvcmVdXG4gICAgICBpZihpbnNlcnRiZWZvcmUpIHtcbiAgICAgICAgdGhpcy5ub2RlLmluc2VydEJlZm9yZSh2YWwubm9kZSwgaW5zZXJ0YmVmb3JlLm5vZGUgfHwgaW5zZXJ0YmVmb3JlKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc29sZS5lcnJvcignY2Fubm90IGZpbmQgaW5zZXJ0YmVmb3JlJylcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAvLyBjb25zb2xlLmVycm9yKHZhbClcblxuICAgICAgdGhpcy5ub2RlLmFwcGVuZENoaWxkKHZhbC5ub2RlKVxuICAgIH1cblxuICAgIHZhbC5zZXR0aW5nKCdwYXJlbnQnLCBbdGhpc10pIC8vZXhlY3V0ZSBwYXJlbnQgc2V0dGluZ3NcbiAgICBpZiAodmFsLm5hbWUpIHRoaXNbdmFsLm5hbWVdID0gdmFsXG4gICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIC8vbmVlZHMgY2xlYW5pbmcgY29zdHMgMyUgbm93Li4uXG4gICAgdGhpcy5jaGVja1JlbmRlcih2YWwpXG4gICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIHJldHVybiB0aGlzXG4gIH0sXG4gIC8qKlxuICAgKiBSZW1vdmVzIGFsbCBjaGlsZHJlblxuICAgKiBAbWV0aG9kIGVtcHR5XG4gICAqIEBwYXJhbSAge0Jvb2xlYW59IGluc3RhbmNlcyBUcnVlIHdpbGwgcmVtb3ZlIGFsbCBpbnN0YW5jZXMgb2YgY2hpbGRyZW4gcmVtb3ZlZFxuICAgKi9cbiAgJ2VtcHR5JyxcbiAgZnVuY3Rpb24oaW5zdGFuY2VzKSB7XG4gICAgdmFyIGMgPSB0aGlzLm5vZGUuY2hpbGROb2Rlc1xuICAgICAgLCBpXG4gICAgdGhpcy5ub2RlLmlubmVySHRtbCA9ICcnXG4gICAgZm9yIChpID0gYy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgaWYgKGNbaV0uYmFzZSkgY1tpXS5iYXNlLnJlbW92ZShpbnN0YW5jZXMpXG4gICAgfVxuICB9KTtcblxuZXhwb3J0cy5iYXNlLmFkZFNldHRpbmcoJ3BhcmVudCcpXG5leHBvcnRzLmJhc2UuYWRkU2V0dGluZygncmVuZGVyJylcbnJlcXVpcmUoJy4vc2V0JykiLCJcbnZhciBjb2xsZWN0aW9uID0gcmVxdWlyZSgnLi91dGlsJylcbiAgLCB1dGlsID0gcmVxdWlyZSgnLi4vLi4vLi4vLi4vdXRpbCcpXG5cbi8qKlxuICogY29sbGVjdGlvblxuICogbGlua3MgYXJyYXlzIG9yIG9iamVjdCB0byBlbGVtZW50c1xuICogdXNlIGZpbHRlciBpZiB5b3Ugd2FudCB0byBjb252ZXJ0XG4gKiBAYXR0cmlidXRlXG4gKi9cblxuZXhwb3J0cy5leHRlbmQgPSB1dGlsLmV4dGVuZChcbiAgcmVxdWlyZSgnLi4vZGF0YScpLFxuICBmdW5jdGlvbihiYXNlKXtcblxuICAgIGJhc2UuZXh0ZW5kKHtcbiAgICAgIG5hbWU6J2NvbGxlY3Rpb24nLFxuICAgICAgLy8gcmVuZGVyOmZ1bmN0aW9uKCkge1xuICAgICAgLy8gICB0aGlzLnVwZGF0ZSgnY29sbGVjdGlvbicpIFxuICAgICAgLy8gfSxcbiAgICAgIHJlbW92ZTpmdW5jdGlvbigpIHtcbiAgICAgICAgaWYodGhpcy5fY29sRWxlbSkgdGhpcy5fY29sRWxlbS5yZW1vdmUoKVxuICAgICAgfSxcbiAgICAgIHNldDogZnVuY3Rpb24odmFsLCBzdGFtcCwgZnJvbSwgcmVtb3ZlLCBjaGFuZ2UsIGFkZGVkKSB7XG5cbiAgICAgICAgdmFsLl9za2lwID0gdHJ1ZVxuXG4gICAgICAgIHZhciBoYXNGaWx0ZXIgPSBjb2xsZWN0aW9uLmZpbHRlcih2YWwsIHRoaXMpXG4gICAgICAgICAgLCBkYXRhID0gdGhpcy5maWx0ZXIgfHwgdmFsLnZhbFxuICAgICAgICAgICwgb3B0aW9ucyA9IHRoaXMuX2NvbE9wdGlvbnMgfHwgdmFsLm9wdGlvbnMgXG4gICAgICAgICAgICAgICYmICh0aGlzLl9jb2xPcHRpb25zID0gdmFsLm9wdGlvbnMuY29udmVydCgpKVxuICAgICAgICAgICwgb3JpZyA9ICB2YWwuZWxlbWVudFxuICAgICAgICAgICwgZWwgPSB0aGlzLl9jb2xFbGVtIFxuICAgICAgICAgICAgICB8fCAob3JpZyAmJiBvcmlnLl92YWwpICYmICh0aGlzLl9jb2xFbGVtID0gbmV3IChvcmlnLl92YWwuQ2xhc3MgfHwgb3JpZy5fdmFsKSgpKVxuICAgICAgICAgICwgZmlyc3RSdW4gPSAhdGhpcy5fY29sSW5pdFxuICAgICAgICAgICwgc2xTdGFtcFxuICAgICAgICAgICwgZWxWYWxcbiAgICAgICAgICAsIGNvbEVsZW0gPSB0aGlzLl9jb2xFbGVtXG5cbiAgICAgICAgICAvLyBjb25zb2xlLmxvZygnISEhT1BUSU9OUyEnLCBvcHRpb25zKVxuXG4gICAgICAgIC8vZGlydHkgYmxvY2shIGNsZWFuIGl0IEZBU1RcblxuICAgICAgICAvLyB8fCAhdGhpcy5yZW5kZXJlZCBcblxuICAgICAgICBpZighKGRhdGEgJiYgZWwpKSByZXR1cm4gLy98fCF0aGlzLnJlbmRlcmVkXG4gICAgICAgIFxuICAgICAgICBzbFN0YW1wID0gb3JpZy5fc2xTdGFtcFxuICAgICAgICBlbFZhbCA9IG9yaWcuX3ZhbFxuXG4gICAgICAgIGlmKHNsU3RhbXApIHtcbiAgICAgICAgICBvcmlnLl9zbFN0YW1wID0gc3RhbXBcbiAgICAgICAgfSBlbHNlIGlmKGNvbEVsZW0gJiYgb3JpZy5fc2xTdGFtcCAhPT0gc3RhbXApIHtcbiAgICAgICAgICBpZighKGVsVmFsLkNsYXNzICYmIChjb2xFbGVtIGluc3RhbmNlb2YgZWxWYWwuQ2xhc3MpKSBcbiAgICAgICAgICAgICYmICEoIWVsVmFsLkNsYXNzICYmIChjb2xFbGVtIGluc3RhbmNlb2YgZWxWYWwpKSkge1xuICAgICAgICAgICAgZWwgPSB0aGlzLl9jb2xFbGVtID0gbmV3IChlbFZhbC5DbGFzcyB8fCBlbFZhbCkoKVxuICAgICAgICAgICAgb3JpZy5fc2xTdGFtcCA9IHN0YW1wXG4gICAgICAgICAgfVxuICAgICAgICB9XG5cblxuXG4gICAgICAgIC8vIGNvbnNvbGUubG9nKCdvb2sgbGV1ayBmZiB1cGRhdGUnLCB2YWwsIHN0YW1wLCBmcm9tLCByZW1vdmUsIGNoYW5nZSwgYWRkZWQpXG4gICAgICAgICAgLy8gY29uc29sZS5sb2coJ3Bhc3MhJylcbiAgICAgICAgICBcbiAgICAgICAgaWYoZmlyc3RSdW4pIHtcblxuICAgICAgICAgIG9wdGlvbnMgJiYgb3B0aW9ucy5wcmVwYXJlICYmIG9wdGlvbnMucHJlcGFyZShlbClcblxuICAgICAgICAgIHRoaXMuX2NvbEluaXQgPSB0cnVlXG4gICAgICAgICAgdGhpcy5ub2RlLmFwcGVuZENoaWxkKGNvbGxlY3Rpb24uZnJhZ21lbnQoIGRhdGEsIGVsLCB0aGlzLCBmYWxzZSwgb3B0aW9uc1xuICAgICAgICAgICAgLCBoYXNGaWx0ZXIgKSlcblxuICAgICAgICB9IGVsc2Uge1xuXG4gICAgICAgICAgaWYoZnJvbSAmJiBmcm9tLl9wYXJlbnQgPT09IGRhdGEuZnJvbSkge1xuICAgICAgICAgICAgaWYocmVtb3ZlKSB7XG4gICAgICAgICAgICAgIHZhciByID0gdXRpbC5jaGVja0FycmF5KGNvbGxlY3Rpb24uY2hpbGRyZW4odGhpcyksZnJvbSwnX2QnLHRydWUpXG4gICAgICAgICAgICAgIGlmKHIpIHtcbiAgICAgICAgICAgICAgICBpZighKG9wdGlvbnMgJiYgb3B0aW9ucy5yZW0gJiYgb3B0aW9ucy5yZW0ociwgdGhpcywgaGFzRmlsdGVyKSkpIHtcbiAgICAgICAgICAgICAgICAgIHIucmVtb3ZlKClcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZih1dGlsLmNoZWNrQXJyYXkoY29sbGVjdGlvbi5jaGlsZHJlbih0aGlzKSxmcm9tLCdfZCcpPT09ZmFsc2UpIHtcblxuICAgICAgICAgICAgICBjb2xsZWN0aW9uLmVsZW1lbnQoIGZyb20sIGVsLCB0aGlzLCB0cnVlLCB0aGlzLm5vZGUsIG9wdGlvbnMsIGhhc0ZpbHRlciwgdHJ1ZSApXG4gICAgICAgICAgICB9IGVsc2UgaWYoaGFzRmlsdGVyICYmIG9wdGlvbnMgJiYgb3B0aW9ucy5pbmRleENoYW5nZSkge1xuXG4gICAgICAgICAgICAgICAgb3B0aW9ucy5pbmRleENoYW5nZShcbiAgICAgICAgICAgICAgICAgIHV0aWwuY2hlY2tBcnJheShjb2xsZWN0aW9uLmNoaWxkcmVuKHRoaXMpLGZyb20sJ19kJyx0cnVlKVxuICAgICAgICAgICAgICAgICAgLCB0aGlzLCBoYXNGaWx0ZXIgKVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy8gY29uc29sZS5sb2coJzEyMlhYWFhYJywgZnJvbSwgaGFzRmlsdGVyLCBjb2xsZWN0aW9uLmZpbHRlcih2YWwsIHRoaXMpKSAvL3RyeSB0byBmaXggb3JkZXIgYnkgbmFtZSBiZXR0ZXJcblxuICAgICAgICAgICAgaWYoIWZyb20pIHtcblxuICAgICAgICAgICAgICBpZihyZW1vdmUpIHtcbiAgICAgICAgICAgICAgICBjb2xsZWN0aW9uLmNsZWFyKHRoaXMsIG9wdGlvbnMpXG4gICAgICAgICAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgICAgICAgICB2YXIgYyA9IGNvbGxlY3Rpb24uY2hpbGRyZW4odGhpcylcbiAgICAgICAgICAgICAgICAgICwgZXhjbHVkZSA9IHt9XG4gICAgICAgICAgICAgICAgICAsIG5hbWVcbiAgICAgICAgICAgICAgICAgICwgZkZpZWxkXG4gICAgICAgICAgICAgICAgICAsIGtleXNcbiAgICAgICAgICAgICAgICAgICwgY2hpbGRcblxuICAgICAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKCdYWFhYWCcsaGFzRmlsdGVyKSAvL3RyeSB0byBmaXggb3JkZXIgYnkgbmFtZSBiZXR0ZXJcbiAgICAgICAgICAgICAgICBpZihoYXNGaWx0ZXI9PT10cnVlKSB7XG4gICAgICAgICAgICAgICAgICBrZXlzID0gZGF0YS5rZXlzXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgZm9yKHZhciBqIGluIGMpIHtcbiAgICAgICAgICAgICAgICAgIGNoaWxkID0gY1tqXVxuICAgICAgICAgICAgICAgICAgbmFtZSA9IGNbal0uX2QuX25hbWVcblxuICAgICAgICAgICAgICAgICAgLy8gY29uc29sZS5sb2coY1tqXSwgaGFzRmlsdGVyLCBrZXlzLCB1dGlsLmNoZWNrQXJyYXkoZGF0YSxjaGlsZC5fZCkgPT09IGZhbHNlKVxuXG4gICAgICAgICAgICAgICAgICBpZihoYXNGaWx0ZXIgJiYgIWtleXMgPyB1dGlsLmNoZWNrQXJyYXkoZGF0YSxjaGlsZC5fZCkgPT09IGZhbHNlIDogIWRhdGFbbmFtZV0gfHwgZGF0YVtuYW1lXSE9PWNoaWxkLl9kICkge1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKCdDSEVDSyEtLS0nLGopXG5cbiAgICAgICAgICAgICAgICAgICAgaWYoIShvcHRpb25zICYmIG9wdGlvbnMucmVtICYmIG9wdGlvbnMucmVtKGNoaWxkLCB0aGlzLCBoYXNGaWx0ZXIsIGhhc0ZpbHRlcikpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgY2hpbGQucmVtb3ZlKClcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy90aGlzIGlzIG1vcmUgZWZmaWNpZW50XG4gICAgICAgICAgICAgICAgICAgIC8vIGlmKGRhdGFbbmFtZV0hPT1jW2pdLl9kKSBjW2pdLmRhdGEgPSBkYXRhW25hbWVdIFxuICAgICAgICAgICAgICAgICAgICBleGNsdWRlW25hbWVdPXRydWVcbiAgICAgICAgICAgICAgICAgICAgaWYoaGFzRmlsdGVyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgaWYob3B0aW9ucyAmJiBvcHRpb25zLmluZGV4Q2hhbmdlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZihjaGlsZC5fZC5faW5kZXhDYWNoZVtoYXNGaWx0ZXJdWzBdIT09Y2hpbGQuaSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zLmluZGV4Q2hhbmdlKGNoaWxkLCB0aGlzLCBoYXNGaWx0ZXIsIHRydWUpXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmKGhhc0ZpbHRlcj09PXRydWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmKGohPXV0aWwuY2hlY2tBcnJheShrZXlzLG5hbWUsdHJ1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgZGVsZXRlIGV4Y2x1ZGVbbmFtZV1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgaWYoIShvcHRpb25zICYmIG9wdGlvbnMucmVtICYmIG9wdGlvbnMucmVtKGNbal0sIHRoaXMsIGhhc0ZpbHRlciwgaGFzRmlsdGVyKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaGlsZC5yZW1vdmUoKVxuICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9IFxuICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHRoaXMubm9kZS5hcHBlbmRDaGlsZChcbiAgICAgICAgICAgICAgICAgIGNvbGxlY3Rpb24uZnJhZ21lbnQoZGF0YSwgZWwsIHRoaXMsIGV4Y2x1ZGUsIG9wdGlvbnMsIGhhc0ZpbHRlcilcbiAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pXG59KSIsInZhciBlbGVtZW50ID0gcmVxdWlyZSgnLi4vJylcbiAgLCBEYXRhID0gcmVxdWlyZSgnLi4vLi4vLi4vLi4vZGF0YScpLmluamVjdChyZXF1aXJlKCcuLi8uLi8uLi8uLi9kYXRhL3NlbGVjdGlvbicpKVxuICAsIHV0aWwgPSByZXF1aXJlKCcuLi8uLi8uLi8uLi91dGlsJylcblxudmFyIHIgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIFN0cmluZyh+fihNYXRoLnJhbmRvbSgpKjkpKSsnJ1xufVxuXG5leHBvcnRzLmVsZW1lbnQgPSBmdW5jdGlvbiAoZGF0YSwgZWxlbWVudCwgdCwgdXBkYXRlLCBub2RlLCBvcHRpb25zLCBoYXNGaWx0ZXIsIHJlc29sdmUpIHtcbiAgdmFyIGVsZW1cbiAgaWYob3B0aW9ucyAmJiBvcHRpb25zLm5ld0VsZW1lbnQpIHtcbiAgICBlbGVtID0gb3B0aW9ucy5uZXdFbGVtZW50LmFwcGx5KHRoaXMsYXJndW1lbnRzKVxuICAgIGlmKGVsZW09PT10cnVlKSByZXR1cm5cbiAgfVxuICBlbGVtID0gZWxlbSB8fCBuZXcgZWxlbWVudC5DbGFzcygpXG4gIFxuICBlbGVtLl9jb2wgPSB0cnVlXG5cbi8vICAgY29uc29sZS5sb2coICctLS0tPicsIGRhdGEgKVxuXG4gIGlmIChkYXRhICE9PSB2b2lkIDApIGVsZW0uX2RTZXQoZGF0YSlcbiAgaWYgKG5vZGUpIG5vZGUuYXBwZW5kQ2hpbGQoZWxlbS5ub2RlKVxuICBlbGVtLnNldHRpbmcoJ3BhcmVudCcsIFt0XSlcbiAgO29wdGlvbnMmJm9wdGlvbnMuZWxlbWVudCYmb3B0aW9ucy5lbGVtZW50KGVsZW0sIHQsIGhhc0ZpbHRlciwgcmVzb2x2ZSlcbiAgaWYgKHVwZGF0ZSAmJiBkYXRhICE9PSB2b2lkIDApIGVsZW0udXBkYXRlRGF0YSgpXG4gIHQuY2hlY2tSZW5kZXIoZWxlbSwgdHJ1ZSlcbiAgcmV0dXJuIGVsZW1cbn1cblxuZXhwb3J0cy5mcmFnbWVudCA9IGZ1bmN0aW9uIChkYXRhLCBlbGVtZW50LCB0LCBleGNsdWRlLCBvcHRpb25zLCBoYXNGaWx0ZXIpIHtcbiAgdmFyIGZyYWcgPSBkb2N1bWVudC5jcmVhdGVEb2N1bWVudEZyYWdtZW50KClcbiAgICAsIGl0ZW0gPSBmdW5jdGlvbihpKSB7XG4gICAgICAgIC8vaWYgeW91IHVzZSB0aGUgcGFzc2VkIGkgaXQgaXMgYSBkaWZmZXJlbnQgdmFsdWUgZm9yIHNlbGVjdGlvbnNcbiAgICAgICAgaWYodGhpcy5fbmFtZSkgaSA9IHRoaXMuX25hbWVcbiAgICAgICAgaWYoIShvcHRpb25zJiZvcHRpb25zLmZyYWdtZW50JiZvcHRpb25zLmZyYWdtZW50KHQsdGhpcyxleGNsdWRlLGkpKVxuICAgICAgICAgICYmICghZXhjbHVkZSB8fCAhZXhjbHVkZVtpXSkgKSB7XG4gICAgICAgICAgdmFyIGVsZW0gPSBleHBvcnRzLmVsZW1lbnQoIHRoaXMgfHwgbnVsbCwgZWxlbWVudCwgdCwgZmFsc2UsIGZyYWcsIG9wdGlvbnNcbiAgICAgICAgICAgICAgLCBoYXNGaWx0ZXIpXG4gICAgICAgICAgaWYoZWxlbSkgZnJhZy5hcHBlbmRDaGlsZCggZWxlbS5ub2RlIClcbiAgICAgICAgfVxuICAgICAgfVxuICBmcmFnLl9wID0gdFxuXG4gIGlmKGRhdGEuZWFjaCkge1xuICAgIGRhdGEuZWFjaChpdGVtKVxuICB9IGVsc2Uge1xuICAgIC8vbm9ybWFsIGRhdGFcbiAgICBmb3IodmFyIGkgaW4gZGF0YSkge1xuICAgICAgaXRlbS5jYWxsKCBkYXRhW2ldICxpIClcbiAgICB9XG4gIH1cblxuICBlbGVtZW50LnVwZGF0ZURhdGEodHJ1ZSlcbiAgcmV0dXJuIGZyYWdcbn1cblxuZXhwb3J0cy5jaGlsZHJlbiA9IGZ1bmN0aW9uICh0LCBvcHRpb25zKSB7XG4gIGlmKCF0KSByZXR1cm5cbiAgdmFyIGNoID0gW11cbiAgZm9yKHZhciBpIGluIHQubm9kZS5jaGlsZE5vZGVzKSB7XG4gICAgdmFyIGNoaWxkID0gdC5ub2RlLmNoaWxkTm9kZXNbaV0uYmFzZVxuICAgIGlmKGNoaWxkICYmIGNoaWxkLl9jb2wpIHtcbiAgICAgIGNoLnB1c2goY2hpbGQpXG4gICAgfVxuICB9XG4gIDtvcHRpb25zJiZvcHRpb25zLmNoaWxkcmVuJiZvcHRpb25zLmNoaWxkcmVuKGNoKVxuICByZXR1cm4gY2hcbn1cblxuZXhwb3J0cy5jbGVhciA9IGZ1bmN0aW9uICh0LCBvcHRpb25zKSB7XG4gIHQuY29sSW5pdCA9IG51bGxcbiAgdmFyIGMgPSBleHBvcnRzLmNoaWxkcmVuKHQpXG4gIGZvcih2YXIgaSBpbiBjKSB7IGNbaV0ucmVtb3ZlKCkgfVxuICA7b3B0aW9ucyYmb3B0aW9ucy5jbGVhciYmb3B0aW9ucy5jbGVhcih0KVxufVxuXG5leHBvcnRzLmZpbHRlciA9IGZ1bmN0aW9uICh2YWwsdCkge1xuXG5cbiAgdmFyIGRhdGEgPSB2YWwudmFsXG5cblxuICAvLyBjb25zb2xlLmxvZygnRE8gSSBIQVZFIEZVTFRFUiE+PycsZGF0YSwgIHZhbCwgdClcblxuXG4gIGlmKHZhbC5maWx0ZXIgJiYgdmFsLmZpbHRlci52YWw9PT10cnVlKSB7XG4gICAgLy8gY29uc29sZS5sb2coJ3NvcnQgYnkgbmFtZScpIG1vZXQgYmV0ZXJcbiAgICAgICAgLy8gY29uc29sZS5sb2coJ2dvdCBpdCFEQVRBeCEnKVxuXG4gICAgcmV0dXJuIHRydWVcbiAgICAvL2RpZmZlcmVudCB2aWJlc1xuICB9XG5cbiAgaWYgKGRhdGEgJiYgdmFsLmZpbHRlciAmJiAhdC5maWx0ZXIpIHtcblxuICAgIC8vIGNvbnNvbGUubG9nKCdNQUtFIE5FVyBTVFlVRkZGJylcblxuICAgIHZhciBhID0gdmFsLmZpbHRlci5yYXdcbiAgICAvL2RpdCBpcyBrYXBvdFxuICAgIGRhdGEgPSB0LmZpbHRlciA9IG5ldyBEYXRhKGRhdGEsIGEpXG5cbiAgICAvLyBjb25zb2xlLmxvZygnRklMVEVSU1NTUyEnLCBhLCB0KVxuICAgIC8vIGRlYnVnZ2VyXG5cbiAgICBhLl9jb2wgPSB0cnVlXG4gICAgXG4gICAgZGF0YS5hZGRMaXN0ZW5lcihmdW5jdGlvbiAodmFsLCBzdGFtcCwgZnJvbSwgcmVtb3ZlKSB7XG4gICAgICB0LmNvbGxlY3Rpb24uX3VwZGF0ZSh2YWwsIHN0YW1wLCBmcm9tLCByZW1vdmUpXG4gICAgfSlcbiAgICBcbiAgICB0LnNldFNldHRpbmcoe1xuICAgICAgLy8gbmFtZTogJ2NvbGxlY2l0b25maWx0ZXInLFxuICAgICAgcmVtb3ZlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHQuZmlsdGVyLnJlbW92ZSgpXG4gICAgICAgIHQuZmlsdGVyID0gbnVsbFxuICAgICAgfVxuICAgIH0pXG5cbiAgICAvLyBjb25zb2xlLmxvZygnREFUQXghJylcbiAgICByZXR1cm4gZGF0YS5fdWlkXG4gICAgLy8gcmV0dXJuIHQuZmlsdGVyLl91aWQvL2RhdGEgaXMgZmlsdGVyXG4gIH0gZWxzZSBpZihkYXRhICYmIGRhdGEuX2ZpbHRlcikge1xuICAgICAgICAvLyBjb25zb2xlLmxvZygnRHh4eEFUQXghJylcblxuICAgIHJldHVybiBkYXRhLl91aWRcbiAgfSBcbiAgZWxzZSBpZih0LmZpbHRlcikge1xuXG4gICAgcmV0dXJuIHQuZmlsdGVyLl91aWRcbiAgfVxuXG4gICAgLy8gY29uc29sZS5sb2coJ05PIERBVEFYISBGSUxURVInLCB0KVxuXG59XG5cbi8vIGV4cG9ydHMuaW5kZXhDaGFuZ2UgPSBmdW5jdGlvbihlbCwgdCwgaGFzRmlsdGVyLCBub1Jlc29sdmUpIHtcbi8vIHZhciBvbGRJbmRleCA9IGVsLl9kLl9pbmRleENhY2hlW2hhc0ZpbHRlcl1bMV1cbi8vICAgICAsIG5ld0luZGV4ID0gZWwuX2QuX2luZGV4Q2FjaGVbaGFzRmlsdGVyXVswXVxuLy8gICAgICwgY2ggPSAhbm9SZXNvbHZlICYmIGNvbGxlY3Rpb24uY2hpbGRyZW4odCxleHBvcnRzKVxuLy8gICAgICwgbFxuXG5cbi8vICAgZXhwb3J0cy54eShlbClcblxuLy8gICBpZihub1Jlc29sdmUpIHJldHVyblxuXG4vLyAgIGwgPSBjaC5sZW5ndGhcbiAgXG4gIFxuLy8gICB2YXIgY2xvbmUgPSBlbC5ub2RlLmNsb25lTm9kZSh0cnVlKVxuLy8gICB0Lm5vZGUucmVtb3ZlQ2hpbGQoZWwpXG4vLyAgIGVsLl9ub2RlID0gY2xvbmVcblxuXG4gICBcbi8vICAgLy8gdC5oID0gdC5ub2RlLnNjcm9sbEhlaWdodFxuLy8gfSIsIi8qIVxuICogQGxpY2Vuc2UgQ29weXJpZ2h0IChjKSAyMDEyLTIwMTQsIFZpZ291ci4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIEBhdXRob3I6IEppbSBkZSBCZWVyLCBqaW1Admlnb3VyLmlvXG4gKi9cbnZhciBkYXRhID0gcmVxdWlyZSgnLi4vLi4vLi4vZGF0YS9iYXNlJylcbiAgLCB1dGlsID0gcmVxdWlyZSgnLi4vLi4vLi4vdXRpbCcpXG4gICwgZmxhZ3MgPSByZXF1aXJlKCcuLi8uLi8uLi92YWx1ZS9mbGFncycpXG5cbi8qKlxuICAqIGV4dGVuZHMgdXBkYXRlRGF0YSB0byB0YWtlIGNoaWxkTm9kZXMgaW50byBhY2NvdW50XG4gICogbWF5IG5lZWQgdG8gYWRkIGV4dHJhIGFyZ3VtZW50IGZvciBnbyBkZWVwXG4gICogQG1ldGhvZFxuKi9cbmV4cG9ydHMuZXh0ZW5kID0gdXRpbC5leHRlbmQoW2RhdGEsIHtcbiAgdXBkYXRlRGF0YTogZnVuY3Rpb24gKCBpbnN0YW5jZXMsIGRhdGEsIGZtb2RlbCApIHtcblxuICAgIC8vIGNvbnNvbGUubG9nKCc/Pz8/LS0tLS0tLS0tLS0+Pj4+PicpXG4gICAgaWYgKHRoaXMuX2QpIHtcbiAgICAgIHRoaXMuX3N1YnNjcmliZWQgPSBmYWxzZVxuICAgICAgZGF0YSA9IHRoaXMuX2RcbiAgICB9XG5cbiAgICB2YXIgZmZtb2RlbCA9IGZhbHNlXG5cbiAgICAvLyBjb25zb2xlLmxvZyhmbW9kZWwsIHRoaXMubW9kZWwpXG4gICAgLy9kaXQgaXMgb21kYXQgZXIgZ2VlbiBtb2RlbCBwcm9wZXJ0eSBpcyBvcCBoZXQgZGluZyB3YWFyIGRhdGEgb3Agd29yZHQgZ2ViaW5kZWQgZGFuIGRlZmF1bHQgaWUgbmFhciBtb2RlbHMgZGllIGVyIHdlbCB6aWpuXG4gICAgLy9vcGxvc3NpbmcgbWFhayBtb2RlbCBhYW4gYWx0aWpkIGFscyBkYXRhIGVuIG5pZXQgZGZyb21cblxuICAgIGlmICghZm1vZGVsICYmICF0aGlzLm1vZGVsICYmICF0aGlzLl9mbW9kZWwpIGZmbW9kZWwgPSB0cnVlXG4gICAgLy9mbW9kZWwgaXMgZmlyc3QgbW9kZWxcbiAgICBmb3IgKHZhciBjaGlsZHJlbiA9IHRoaXMubm9kZS5jaGlsZE5vZGVzXG4gICAgICAsIGkgPSBjaGlsZHJlbi5sZW5ndGggLSAxXG4gICAgICAsIGJhc2U7IGkgPj0gMDsgaS0tKSB7XG4gICAgICBiYXNlID0gY2hpbGRyZW5baV0uYmFzZVxuICAgICAgaWYgKGJhc2VcbiAgICAgICYmICghKGJhc2UubW9kZWwgJiYgYmFzZS5tb2RlbC5pbmhlcml0ICYmIGJhc2UubW9kZWwuaW5oZXJpdC52YWw9PT1mYWxzZSkpXG4gICAgICAmJiAoYmFzZS5fZCA9PT0gdm9pZCAwIHx8IGJhc2UuX2Rmcm9tKSkge1xuICAgICAgICBpZiAoYmFzZS5tb2RlbCAmJiBkYXRhKSB7XG4gICAgICAgICAgaWYgKGZmbW9kZWwpIGJhc2UuX2Ztb2RlbCA9IHRydWVcblxuICAgICAgICAgIC8vIGNvbnNvbGUubG9nKCdGTU9ERUwhIC0tIGRTZXQnLCBkYXRhKVxuICAgICAgICAgIC8vIGNvbnNvbGUubG9nKCctLS0tLS0gWFhYWFhYWFhYWFhYWFhYWFgnLCBmZm1vZGVsLCBiYXNlLl9uYW1lLCAnXFxuJywgYmFzZSwgZGF0YSApXG4gICAgICAgICAgYmFzZS5fZFNldChkYXRhLCB0cnVlKVxuICAgICAgICB9XG4gICAgICAgIGJhc2UudXBkYXRlRGF0YShpbnN0YW5jZXMsIGRhdGEsIGJhc2UuX2Ztb2RlbCB8fCBmbW9kZWwpXG4gICAgICB9XG4gICAgfVxuICB9XG59XSlcbiIsIi8qIVxuICogQGxpY2Vuc2UgQ29weXJpZ2h0IChjKSAyMDEyLTIwMTQsIFZpZ291ci4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIEBhdXRob3I6IEppbSBkZSBCZWVyLCBqaW1Admlnb3VyLmlvXG4gKi9cblxuICAvKlxuICAgIGhlcmUgc29tZSBiYXNpYyBodG1sIHByb3BlcnRpZXMgYXJlIGFkZGVkIHRvIFYuRWxlbWVudC5OZXNzZWNhcnlcbiAgICBmb3IgdmFsdWVzIHRoYXQgeW91IHdhbnQgdG8gYmUgYWJsZSB0byBiaW5kIHRvIFYuT2JqZWN0c1xuICAgIFVzZXMgYmFzZS5leHRlbmQgLS0gc2VlIGNvcmUuYmFzZSBmb3IgbW9yZSBpbmZvcm1hdGlvblxuICAqL1xuXG52YXIgdWEgPSByZXF1aXJlKCcuLi8uLi91YScpXG4gICwgY3NzID0gcmVxdWlyZSgnLi4vLi4vY3NzJylcbiAgLCBWYWx1ZSA9IHJlcXVpcmUoJy4uLy4uLy4uL3ZhbHVlJylcbiAgLCB1dGlsID0gcmVxdWlyZSgnLi4vLi4vLi4vdXRpbCcpXG4gICwgaGFzaCA9IHJlcXVpcmUoJy4uLy4uLy4uL3V0aWwvaGFzaCcpXG4gICwgcmFmID0gcmVxdWlyZSgnLi4vLi4vYW5pbWF0aW9uL3JhZicpXG4gICwgX2xvYWQgPSByZXF1aXJlKCcuLi8nKS5pbWFnZXMgPSB7fVxuICAsIF90cmFuc2Zvcm0gPSB1YS5wcmVmaXggKyAnVHJhbnNmb3JtJ1xuICAsIF9jc3NUcmFuc2Zvcm0gPSB1YS5wcmVmaXggKyAnLXRyYW5zZm9ybSdcbiAgLCBib2R5ID0gZG9jdW1lbnQuYm9keS5zdHlsZVxuICAgIC8vdGhpbmsgYWJvdXQgZG9jIHJlYWR5IGV2ZW50IG9yIGZhbGxiYWNrIGlmIG5vIGJvZHlcbiAgLCBfdHJhbnNsYXRlID0gYm9keS5wZXJzcGVjdGl2ZVByb3BlcnR5ICE9IHZvaWQgMFxuICAgICAgICAgICAgICAgICB8fCBib2R5LldlYmtpdFBlcnNwZWN0aXZlICE9IHZvaWQgMFxuICAgICAgICAgICAgICAgICAgICA/IFsndHJhbnNsYXRlM2QoJywgJywwcHgpJ11cbiAgICAgICAgICAgICAgICAgICAgOiBbJ3RyYW5zbGF0ZSgnLCAnKSddXG4gICwgX2Nvb3JkaW5hdGUgPSBmdW5jdGlvbihzdHlsZSkge1xuICAgICAgdmFyIG1hcmdpbiA9ICdtYXJnaW4nICsgKHN0eWxlWzBdLnRvVXBwZXJDYXNlKCkgKyBzdHlsZS5zbGljZSgxKSk7XG4gICAgICByZXR1cm4gZnVuY3Rpb24odmFsKSB7XG4gICAgICAgIGlmKHZhbC5jbGVhbikge1xuICAgICAgICAgIF9jbGVhbkNvb3JkaW5hdGUuY2FsbCh0aGlzLHN0eWxlLG1hcmdpbilcbiAgICAgICAgICB2YWwuY2xlYW4gPSBudWxsXG4gICAgICAgIH1cbiAgICAgICAgaWYgKHZhbC50cmFuc2xhdGUpIHtcbiAgICAgICAgICB0aGlzLnRyYW5zbGF0ZSh2YWwpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5ub2RlLnN0eWxlW3RoaXMucmVsYXRpdmUgPyBtYXJnaW4gOiBzdHlsZV0gPSB2YWwudmFsICsgJ3B4J1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAsIF9jbGVhclRyYW5zZm9ybSA9IG5ldyBSZWdFeHAoX2Nzc1RyYW5zZm9ybSsnKC4qPyk7JylcbiAgLCBfY2xlYXIgPVxuICAgIHsgeDogLyhtYXJnaW4tbGVmdCguKj8pOyl8KGxlZnQoLio/KTspL2dcbiAgICAsIHk6IC8obWFyZ2luLXRvcCguKj8pOyl8KHRvcCguKj8pOykvZ1xuICAgIH1cbiAgLCBfY2xlYW5Db29yZGluYXRlID0gZnVuY3Rpb24oIGNoZWNrICkge1xuICAgICAgdmFyIHQgPSB0aGlzLl90XG4gICAgICAsIGtlZXAgPSBmYWxzZVxuICAgICAgLCB2YWwgPSB0aGlzW2NoZWNrXVxuICAgICAgLCBjc3NUZXh0ID0gdGhpcy5ub2RlLnN0eWxlLmNzc1RleHQucmVwbGFjZSggX2NsZWFyW2NoZWNrXSwgJycgKVxuXG4gICAgaWYoIHZhbCAmJiB2YWwudHJhbnNsYXRlICYmIHZhbC50cmFuc2xhdGUudmFsPT09ZmFsc2UpIHZhbC50cmFuc2xhdGUgPSBudWxsXG5cbiAgICBpZih0aGlzLm5vZGUuc3R5bGVbX3RyYW5zZm9ybV0gJiYgIXZhbC50cmFuc2xhdGUpIHtcbiAgICAgIGlmKHQpIHtcbiAgICAgICAgaWYoIXRoaXNbY2hlY2tdLnRyYW5zbGF0ZSkge1xuICAgICAgICAgIGZvcih2YXIgaSA9IDIgOyBpIDwgNiA7IGkrKykge1xuICAgICAgICAgICAgaWYodFtpXSlrZWVwPXRydWVcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAga2VlcD10cnVlXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmKCFrZWVwKSBjc3NUZXh0ID0gY3NzVGV4dC5yZXBsYWNlKF9jbGVhclRyYW5zZm9ybSwnJylcbiAgICB9XG4gICAgdGhpcy5ub2RlLnN0eWxlLmNzc1RleHQgPSBjc3NUZXh0XG4gIH1cblxuZXhwb3J0cy5leHRlbmQgPSB1dGlsLmV4dGVuZChmdW5jdGlvbihiYXNlKSB7XG4gIHV0aWwuZGVmaW5lKGJhc2UuQ2xhc3MsXG4gICAgJ2NsZWFuQ29vcmRpbmF0ZXMnLCBmdW5jdGlvbihjb29yZCkge1xuICAgICAgIGlmKHRoaXMuX25vZGUpIHtcbiAgICAgICAgaWYoIWNvb3JkKSB7XG4gICAgICAgICAgX2NsZWFuQ29vcmRpbmF0ZS5jYWxsKHRoaXMsJ3gnKVxuICAgICAgICAgIF9jbGVhbkNvb3JkaW5hdGUuY2FsbCh0aGlzLCd5JylcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBfY2xlYW5Db29yZGluYXRlLmNhbGwodGhpcyxjb29yZClcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgJ3RyYW5zbGF0ZScsIGZ1bmN0aW9uKHZhbCkge1xuICAgIHZhciBfeFxuICAgICAgLCBfeVxuICAgICAgLCBfdmFsID0gIHZhbC52YWxcbiAgICAgICwgX3NjYWxlXG4gICAgICAsIF9yb3RhdGVcbiAgICAgICwgX3JvdGF0ZVlcbiAgICAgICwgX3JvdGF0ZVhcbiAgICAgICwgX3N0ciA9ICcnXG4gICAgICAsIF9uYW1lID0gdmFsICYmIHZhbC5fcHJvcC5uYW1lXG4gICAgICAsIF90ID0gdGhpcy5fdCA9IHRoaXMuX3QgfHwgW11cbiAgICAgICwgbm9wZSA9IGZhbHNlXG5cbiAgICAvL2NpcnRpY2FsIHBlcmZvcm1hbmNlIHBvaW50IGhlbmNlIHVzZSBvZiB8IDBcbiAgICBpZiAoX25hbWUgPT09ICd4Jykge1xuICAgICAgX3ggPSBfdmFsIHwgMFxuICAgICAgaWYgKF94ID09PSBfdFswXSkgbm9wZSA9IHRydWVcbiAgICB9IGVsc2UgaWYgKF9uYW1lID09PSAneScpIHtcbiAgICAgIF95ID0gX3ZhbCB8IDBcbiAgICAgIGlmIChfeSA9PT0gX3RbMV0pIG5vcGUgPSB0cnVlXG4gICAgfSBlbHNlIGlmIChfbmFtZSA9PT0gJ3JvdGF0ZScpIHtcbiAgICAgIF9yb3RhdGUgPSBfdmFsXG4gICAgICBpZiAoX3JvdGF0ZSA9PT0gX3RbMl0pIG5vcGUgPSB0cnVlXG4gICAgfSBlbHNlIGlmIChfbmFtZSA9PT0gJ3NjYWxlJykge1xuICAgICAgX3NjYWxlID0gX3ZhbFxuICAgICAgaWYgKF9zY2FsZSA9PT0gX3RbM10pIG5vcGUgPSB0cnVlXG4gICAgfSBlbHNlIGlmIChfbmFtZSA9PT0gJ3JvdGF0ZVknKSB7XG4gICAgICBfcm90YXRlWSA9IF92YWxcbiAgICAgIGlmIChfcm90YXRlWSA9PT0gX3RbNF0pIG5vcGUgPSB0cnVlXG4gICAgfSBlbHNlIGlmIChfbmFtZSA9PT0gJ3JvdGF0ZVgnKSB7XG4gICAgICBfcm90YXRlWCA9IF92YWxcbiAgICAgIGlmIChfcm90YXRlWCA9PT0gX3RbNF0pIG5vcGUgPSB0cnVlXG4gICAgfVxuXG4gICAgaWYgKCFub3BlKSB7XG4gICAgICBfdFswXSA9ICBfeCB8fCAodGhpcy54LnRyYW5zbGF0ZSAmJiB0aGlzLngudmFsIHwgMCkgfHwgMFxuICAgICAgX3RbMV0gPSAgX3kgfHwgKHRoaXMueS50cmFuc2xhdGUgJiYgdGhpcy55LnZhbCB8IDApIHx8IDBcbiAgICAgIF90WzJdID0gX3JvdGF0ZSB8fCB0aGlzLnJvdGF0ZS52YWxcbiAgICAgIF90WzNdID0gX3NjYWxlIHx8IHRoaXMuc2NhbGUudmFsXG4gICAgICBfdFs0XSA9IF9yb3RhdGVZIHx8IHRoaXMucm90YXRlWS52YWxcbiAgICAgIF90WzVdID0gX3JvdGF0ZVggfHwgdGhpcy5yb3RhdGVYLnZhbFxuICAgICAgaWYgKF90WzBdIHx8IF90WzFdKSB7XG4gICAgICAgIF9zdHIgPSBfc3RyXG4gICAgICAgICAgLmNvbmNhdChcbiAgICAgICAgICAgIF90cmFuc2xhdGVbMF1cbiAgICAgICAgICArIF90WzBdICsgJ3B4LCdcbiAgICAgICAgICArIF90WzFdICsgJ3B4J1xuICAgICAgICAgICsgX3RyYW5zbGF0ZVsxXVxuICAgICAgICAgIClcbiAgICAgIH1cbiAgICAgIGlmIChfdFsyXSkgeyBfc3RyID0gX3N0ci5jb25jYXQoJyByb3RhdGUoJyArIF90WzJdICsgJ2RlZyknKSB9XG4gICAgICBpZiAoX3RbM10pIHsgX3N0ciA9IF9zdHIuY29uY2F0KCcgc2NhbGUoJyArIF90WzNdICsgJyknKSB9XG4gICAgICBpZiAoX3RbNF0pIHsgX3N0ciA9IF9zdHIuY29uY2F0KCcgcm90YXRlWSgnICsgX3RbNF0gKyAnZGVnKScpIH1cbiAgICAgIGlmIChfdFs1XSkgeyBfc3RyID0gX3N0ci5jb25jYXQoJyByb3RhdGVYKCcgKyBfdFs1XSArICdkZWcpJykgfVxuICAgICAgdGhpcy5ub2RlLnN0eWxlW190cmFuc2Zvcm1dID0gX3N0clxuICAgIH1cbiAgICByZXR1cm4gdGhpc1xuICB9LCAndXBkYXRlJywgZnVuY3Rpb24oKSB7XG4gICAgZm9yICh2YXIgaSA9IDAsIF9hcmdzID0gdXRpbC5hcmcoYXJndW1lbnRzKSwgbCA9IF9hcmdzLmxlbmd0aCwgcDsgaSA8IGw7IGkrKyApIHtcbiAgICAgIGlmIChfYXJnc1tpXSBpbnN0YW5jZW9mIEFycmF5KSB7XG4gICAgICAgIHRoaXMudXBkYXRlLmFwcGx5KHRoaXMsIF9hcmdzW2ldKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHAgPSB1dGlsLmdldCh0aGlzLCBfYXJnc1tpXSk7XG4gICAgICAgIGlmIChwKSB7XG4gICAgICAgICAgcC51cGRhdGUodGhpcyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0pO1xuXG4gIGZ1bmN0aW9uIGNyZWF0ZVNjcm9sbChkaXIpe1xuICAgIHZhciBzID0gJ3Njcm9sbCdcbiAgICAgICwgc2RpciA9IHMgKyBkaXIgLy9zY3JvbGxMZWZ0IG9yIHNjcm9sbFRvcFxuXG4gICAgcmV0dXJuIHtcbiAgICAgIG5hbWU6c2RpcixcbiAgICAgIHNldDpmdW5jdGlvbih2YWwpIHtcbiAgICAgICAgdmFyIHYgPSB2YWwudmFsXG4gICAgICAgICAgLCBzZWxmID0gdGhpc1xuICAgICAgICBpZih2ICE9PSB2b2lkIDApIHNlbGYubm9kZVtzZGlyXSA9IHZcbiAgICAgICAgaWYoIXNlbGYuX19zVCl7XG4gICAgICAgICAgc2VsZi5fX3NUID0gdHJ1ZVxuICAgICAgICAgIHNlbGYuYWRkRXZlbnQocyxmdW5jdGlvbigpe1xuICAgICAgICAgICAgaWYodmFsLl9saXN0ZW5lcnMgIT09IHZvaWQgMCkgdmFsLnZhbCA9IHNlbGYubm9kZVtzZGlyXVxuICAgICAgICAgICAgZWxzZSBzZWxmW3NkaXJdLl9fbHZhbCA9IHZvaWQgMFxuICAgICAgICAgIH0pXG4gICAgICAgIH1cblxuICAgICAgfSxcbiAgICAgIGdldDpmdW5jdGlvbih2YWwpe1xuICAgICAgICBpZih2YWwuX19sdmFsID09PSB2b2lkIDApIHZhbC52YWwgPSB0aGlzLm5vZGVbc2Rpcl1cbiAgICAgICAgcmV0dXJuIHZhbFxuICAgICAgfSxcbiAgICAgIHJlbmRlcjpmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzXG4gICAgICAgICAgLCB2YWwgPSBzZWxmW3NkaXJdLl9fbHZhbFxuICAgICAgICBpZih2YWwpe1xuICAgICAgICAgIHJhZihmdW5jdGlvbigpe1xuICAgICAgICAgICAgc2VsZi5ub2RlW3NkaXJdID0gdmFsXG4gICAgICAgICAgfSlcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICB9XG5cbiAgYmFzZS5leHRlbmQoe1xuICAgIG5hbWU6ICdyZWxhdGl2ZScsXG4gICAgdHlwZTogZmFsc2UsXG4gICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBzID0gdGhpcy5wb3NpdGlvbiAhPT0gZmFsc2UgPyB0aGlzLnBvc2l0aW9uLnZhbCA6ICh0aGlzLnBvc2l0aW9uID0ge1xuICAgICAgICBjc3M6IHRydWUsXG4gICAgICAgIHZhbDogY3NzKHRoaXMuY3NzLnZhbCwgJ3Bvc2l0aW9uJylcbiAgICAgIH0pXG4gICAgICByZXR1cm4gcyAhPT0gJ2Fic29sdXRlJ1xuICAgIH1cbiAgfSxcbiAge1xuICAgIHR5cGU6IGZhbHNlLFxuICAgIG5hbWU6ICdyZW5kZXJlZCcsXG4gICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciByZXQgPSB0aGlzLl9yZW5kZXJlZCB8fCAodGhpcy5ub2RlID09PSBkb2N1bWVudC5ib2R5KSxcbiAgICAgICAgcGFyZW50O1xuICAgICAgaWYgKCFyZXQpIHtcbiAgICAgICAgcGFyZW50ID0gdGhpcy5ub2RlLnBhcmVudE5vZGU7XG4gICAgICAgIHdoaWxlICghcmV0ICYmIHBhcmVudCkge1xuICAgICAgICAgIGlmIChwYXJlbnQuYmFzZSAmJiBwYXJlbnQuX3JlbmRlcmVkKSB7XG4gICAgICAgICAgICByZXQgPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAocGFyZW50ID09IGRvY3VtZW50LmJvZHkpIHtcbiAgICAgICAgICAgIHJldCA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIHBhcmVudCA9IHBhcmVudC5wYXJlbnROb2RlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZXQpIHtcbiAgICAgICAgICB0aGlzLl9yZW5kZXJlZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiByZXQ7XG4gICAgfVxuICB9LFxuICBjcmVhdGVTY3JvbGwoJ0xlZnQnKSxcbiAgY3JlYXRlU2Nyb2xsKCdUb3AnKSxcbiAge1xuICAgIHBvc2l0aW9uOiBmdW5jdGlvbih2YWwpIHtcbiAgICAgIC8vIGNvbnNvbGUubG9nKCc/Pz8/PycsdmFsLmNzcy52YWwpXG4gICAgICAvLyBpZiAoIXZhbC5jc3MpIHsgLy9jaGVjayB3aGVuIGlnbm9yaW5nIHRoaXMgYmVjb21lcyBhIHByb2JsZW1cbiAgICAgICAgdGhpcy5ub2RlLnN0eWxlLnBvc2l0aW9uID0gdmFsLnZhbDtcbiAgICAgIC8vIH1cbiAgICB9LFxuICAgIC8vIHNjcm9sbFRvcDpmdW5jdGlvbih2YWwpIHtcbiAgICAvLyAgIGNvbnNvbGUuZXJyb3IodmFsLnZhbClcbiAgICAvLyAgIHRoaXMubm9kZS5zY3JvbGxUb3AgPSB2YWwudmFsXG4gICAgLy8gfSxcbiAgICByb3RhdGU6IGZ1bmN0aW9uKHZhbCkge1xuICAgICAgdGhpcy50cmFuc2xhdGUodmFsKTtcbiAgICB9LFxuICAgIHJvdGF0ZVk6IGZ1bmN0aW9uKHZhbCkge1xuICAgICAgdGhpcy50cmFuc2xhdGUodmFsKTtcbiAgICB9LFxuICAgIHJvdGF0ZVg6IGZ1bmN0aW9uKHZhbCkge1xuICAgICAgdGhpcy50cmFuc2xhdGUodmFsKTtcbiAgICB9LFxuICAgIHNjYWxlOiBmdW5jdGlvbih2YWwpIHtcbiAgICAgIHRoaXMudHJhbnNsYXRlKHZhbCk7XG4gICAgfSxcbiAgICBzcmM6IGZ1bmN0aW9uKHZhbCkge1xuICAgICAgdmFyIHYgPSB2YWwudmFsO1xuICAgICAgaWYgKHYgJiYgdlt2Lmxlbmd0aCAtIDFdICE9PSAnLycpIHtcbiAgICAgICAgdGhpcy5ub2RlLnNyYyA9IHY7XG4gICAgICB9XG4gICAgfSxcbiAgICBhdHRyOmZ1bmN0aW9uKHZhbCkge1xuICAgICAgdmFyIHQgPSB0aGlzXG4gICAgICB2YWwuZWFjaChmdW5jdGlvbihpKSB7XG4gICAgICAgIHQubm9kZS5zZXRBdHRyaWJ1dGUoaSx0aGlzLnZhbClcbiAgICAgIH0pXG4gICAgfSxcbiAgICBiYWNrZ3JvdW5kUG9zOiBmdW5jdGlvbih2YWwpIHtcbiAgICAgIHRoaXMubm9kZS5zdHlsZS5iYWNrZ3JvdW5kUG9zaXRpb24gPSB2YWwudmFsXG4gICAgfSxcbiAgICBiYWNrZ3JvdW5kQmF0Y2g6IGZ1bmN0aW9uKHZhbCkge1xuXG5cbiAgICB9LFxuICAgIGJhY2tncm91bmQ6IGZ1bmN0aW9uKHZhbCkgeyAvL29wdGlvbmFsIG1heWJlIGluIGEgc2VwZXJhdGUgbW9kdWxlXG4gICAgICB2YXIgdiA9IHZhbC52YWxcbiAgICAgICAgLCB0ID0gdGhpc1xuICAgICAgICAsIHN0eWxlID0gdGhpcy5ub2RlLnN0eWxlXG4gICAgICAgICwgdXJsXG4gICAgICAgICwgaGFzaGVkXG4gICAgICAgICwgcGFyZW50QmF0Y2hcbiAgICAgICAgLCBiYXRjaFxuXG4gICAgICBpZih2YWwuZ29uZSAmJiB2YWwuZ29uZS52YWwpIHtcbiAgICAgICAgdmFsLl9za2lwID0gdHJ1ZVxuICAgICAgICBzdHlsZS5iYWNrZ3JvdW5kSW1hZ2UgPSAnJ1xuICAgICAgfSBlbHNlIGlmICh2ICYmIHZbdi5sZW5ndGggLSAxXSAhPT0gJy8nKSB7XG4gICAgICAgIHVybCA9ICd1cmwoJyArIHYgKyAnKSdcbiAgICAgICAgaWYoc3R5bGUuYmFja2dyb3VuZEltYWdlPT09dXJsKSByZXR1cm5cblxuICAgICAgICAvL1ZhbHVlXG4gICAgICAgIGlmICh2YWwuc2l6ZSkgc3R5bGUuYmFja2dyb3VuZFNpemUgPSB2YWwuc2l6ZS52YWxcblxuICAgICAgICBpZiAodmFsLmxvYWQpIHtcblxuICAgICAgICAgIGhhc2hlZCA9IGhhc2godilcbiAgICAgICAgICBwYXJlbnRCYXRjaCA9IHRoaXMuY2hlY2tQYXJlbnQoJ2JhY2tncm91bmRCYXRjaCcpXG4gICAgICAgICAgaWYocGFyZW50QmF0Y2gpIGJhdGNoID0gcGFyZW50QmF0Y2guYmFja2dyb3VuZEJhdGNoXG5cbiAgICAgICAgICBpZighX2xvYWRbaGFzaGVkXSkge1xuICAgICAgICAgICAgdGhpcy5fbG9hZGVkID0gbnVsbFxuICAgICAgICAgICAgLy9hbHNvIHJlbW92ZSBzZXR0aW5nXG5cbiAgICAgICAgICAgIGlmKGJhdGNoKSB7XG4gICAgICAgICAgICAgIHdpbmRvdy5jYW5jZWxBbmltYXRpb25GcmFtZShiYXRjaC5fcmFmKVxuICAgICAgICAgICAgICBpZighYmF0Y2guYmF0Y2gpIGJhdGNoLmJhdGNoID0gW11cbiAgICAgICAgICAgICAgYmF0Y2guYmF0Y2gucHVzaChoYXNoKVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBfbG9hZFtoYXNoZWRdPW5ldyBWYWx1ZShmYWxzZSlcbiAgICAgICAgICAgIHZhciBpbWcgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdpbWcnKVxuICAgICAgICAgICAgaW1nLm9ubG9hZCA9IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgICAgICAgaWYoYmF0Y2gpIHtcbiAgICAgICAgICAgICAgIGJhdGNoLmJhdGNoLnNwbGljZSh1dGlsLmNoZWNrQXJyYXkoYmF0Y2guYmF0Y2gsaGFzaGVkKSwxKVxuICAgICAgICAgICAgICAgaWYoYmF0Y2guYmF0Y2gubGVuZ3RoPT09MCkge1xuICAgICAgICAgICAgICAgIGJhdGNoLmJhdGNoID0gbnVsbFxuICAgICAgICAgICAgICAgIGJhdGNoLl9yYWYgPSByYWYoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICBpZihwYXJlbnRCYXRjaC5fbm9kZSkgYmF0Y2guX3ZhbC5jYWxsKHBhcmVudEJhdGNoKVxuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIF9sb2FkW2hhc2hlZF0udmFsID0gdHJ1ZVxuICAgICAgICAgICAgICBpbWcub25sb2FkID0gbnVsbFxuICAgICAgICAgICAgICBpbWcgPSBudWxsXG4gICAgICAgICAgICAgIF9sb2FkW2hhc2hlZF0ucmVtb3ZlKGZhbHNlLGZhbHNlLGZhbHNlLGZhbHNlLGZhbHNlLHRydWUpXG4gICAgICAgICAgICAgIF9sb2FkW2hhc2hlZF0gPSB0cnVlXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpbWcuc3JjID0gdlxuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmKF9sb2FkW2hhc2hlZF0hPT10cnVlKSB7XG4gICAgICAgICAgICAgdGhpcy5fbG9hZGVkID0gbnVsbFxuXG4gICAgICAgICAgICBfbG9hZFtoYXNoZWRdLmFkZExpc3RlbmVyKFtmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgaWYodmFsLmxvYWQgJiYgdmFsLmxvYWQudmFsIT09dHJ1ZSkgdmFsLmxvYWQuX3ZhbC5jYWxsKHRoaXMsIHQpO1xuICAgICAgICAgICAgfSx2YWwuX2Jhc2VdLCB0cnVlKVxuICAgICAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgICAgIHRoaXMuX2xvYWRlZCA9IHRydWVcblxuICAgICAgICAgICAgaWYoYmF0Y2gpIHtcbiAgICAgICAgICAgICAgaWYoKCFiYXRjaC5iYXRjaCkgfHwgYmF0Y2guYmF0Y2gubGVuZ3RoPT09MCkge1xuICAgICAgICAgICAgICAgIGJhdGNoLmJhdGNoID0gbnVsbFxuICAgICAgICAgICAgICAgIHdpbmRvdy5jYW5jZWxBbmltYXRpb25GcmFtZShiYXRjaC5fcmFmKVxuICAgICAgICAgICAgICAgIGJhdGNoLl9yYWYgPSByYWYoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgaWYocGFyZW50QmF0Y2guX25vZGUpIGJhdGNoLl92YWwuY2FsbChwYXJlbnRCYXRjaClcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmKHZhbC5sb2FkLnZhbCE9PXRydWUpIHZhbC5sb2FkLl92YWwuY2FsbCh0aGlzLCB0KTtcblxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHN0eWxlLmJhY2tncm91bmRJbWFnZSA9IHVybFxuXG4gICAgICB9XG4gICAgfSxcbiAgICBwYWRkaW5nOiBmdW5jdGlvbih2YWwpIHtcbiAgICAgIHRoaXMubm9kZS5zdHlsZS5wYWRkaW5nID0gdmFsLnZhbCArICdweCc7XG4gICAgfSxcbiAgICB5OiBfY29vcmRpbmF0ZSgndG9wJyksXG4gICAgeDogX2Nvb3JkaW5hdGUoJ2xlZnQnKSxcbiAgICBkaXNwbGF5OiBmdW5jdGlvbih2YWwpIHtcbiAgICAgIHRoaXMubm9kZS5zdHlsZS5kaXNwbGF5ID0gdmFsLnZhbDtcbiAgICB9LFxuICAgIHc6IGZ1bmN0aW9uKHZhbCkge1xuICAgICAgLy8gY29uc29sZS5sb2coJ3cnKTtcbiAgICAgIHZhciB2ID0gdmFsLnZhbFxuICAgICAgdGhpcy5ub2RlLnN0eWxlLndpZHRoID0gKHYgPiAtMSA/ICh2IHwgMCkgICsgJ3B4JyA6IHYgKSB8fCAnMTAwJScgXG4gICAgfSxcbiAgICBoOiBmdW5jdGlvbih2YWwpIHtcbiAgICAgIHZhciB2ID0gdmFsLnZhbCB8IDBcbiAgICAgIHRoaXMubm9kZS5zdHlsZS5oZWlnaHQgPSAodiA+IC0xID8gKHYgfCAwKSAgKyAncHgnIDogdiApIHx8ICcxMDAlJ1xuICAgIH0sXG4gICAgb3BhY2l0eTogZnVuY3Rpb24odmFsKSB7XG4gICAgICB2YXIgdiA9IHZhbC52YWw7XG4gICAgICB0aGlzLm5vZGUuc3R5bGUub3BhY2l0eSA9IHYgPiAtMSA/IHYgOiAxO1xuICAgIH0sXG4gICAgaHRtbDogZnVuY3Rpb24odmFsKSB7XG4gICAgICB2YXIgdiA9IHZhbC52YWwgfHwgJydcbiAgICAgIGlmKCB2LnJlcGxhY2UgKVxuICAgICAge1xuICAgICAgICAvL2FkZCBzb21lIGluamVjdGlvbiBwcmV2ZW50aW9uIGFzIG9wdGlvbj8gKG5vIHNjcmlwdCBldGMpXG4gICAgICAgIHYgPSB2LnJlcGxhY2UoL1xcdC9nLCAnICAgICcpXG4gICAgICAgICAgICAgLnJlcGxhY2UoL1xcclxcbnxcXG58XFxyL2csICc8YnIvPicpXG4gICAgICAgICAgICAgLnJlcGxhY2UoLyAgL2csICcmbmJzcDsgJylcbiAgICAgICAgICAgICAucmVwbGFjZSgvICAvZywgJyAmbmJzcDsnKSAvLyBzZWNvbmQgcGFzc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGhhbmRsZXMgb2RkIG51bWJlciBvZiBzcGFjZXMsIHdoZXJlIHdlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gZW5kIHVwIHdpdGggXCImbmJzcDtcIiArIFwiIFwiICsgXCIgXCJcbiAgICAgICAgdGhpcy5ub2RlLmlubmVySFRNTCA9IHZcbiAgICAgIH1cblxuICAgIH0sXG4gICAgaHJlZjogZnVuY3Rpb24odmFsKSB7XG4gICAgICB0aGlzLm5vZGUuaHJlZiA9IHZhbC52YWw7XG4gICAgfSxcbiAgICB0ZXh0OiBmdW5jdGlvbih2YWwpIHtcblxuICAgICAgLy8gY29uc29sZS5sb2coJ1NFVFRJTkcgVEVYVCcuZ3JlZW4uaW52ZXJzZS4gdmFsLnZhbCwgdmFsKVxuXG4gICAgICB2YXIgbm9kZSA9IHRoaXMubm9kZVxuICAgICAgICAsIG5vZGVzID0gbm9kZS5jaGlsZE5vZGVzXG4gICAgICAgICwgdiA9IHZhbC52YWwgfHwgJydcblxuICAgICAgaWYodiBpbnN0YW5jZW9mIE9iamVjdCkgdiA9ICcnXG5cbiAgICAgIGlmICgvdGV4dC8udGVzdChub2RlLnR5cGUpKSB7XG4gICAgICAgIG5vZGUudmFsdWUgPSB2O1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmIChub2Rlcykge1xuICAgICAgICBmb3IgKHZhciBpID0gMCwgbCA9IG5vZGVzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgIGlmIChub2Rlc1tpXS5ub2RlVHlwZSA9PT0gMykge1xuICAgICAgICAgICAgLy8gY29uc29sZS5sb2coJ0JMQUJMQScuaW52ZXJzZSx2KVxuICAgICAgICAgICAgbm9kZXNbaV0ubm9kZVZhbHVlID0gdjtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIG5vZGUuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUodikpO1xuICAgIH1cbiAgfSk7XG59KTsiLCIvKiFcbiAqIEBsaWNlbnNlIENvcHlyaWdodCAoYykgMjAxMi0yMDE0LCBWaWdvdXIuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBAYXV0aG9yOiBKaW0gZGUgQmVlciwgamltQHZpZ291ci5pb1xuICovXG52YXIgdXRpbCA9IHJlcXVpcmUoJy4uLy4uLy4uL3V0aWwnKVxuXG5leHBvcnRzLmV4dGVuZCA9IHV0aWwuZXh0ZW5kKGZ1bmN0aW9uKGJhc2UpIHtcbiAgdmFyIHByb3RvID0gYmFzZS5DbGFzcy5wcm90b3R5cGVcbiAgICAsIGFkZCA9IHByb3RvLmFkZFxuXG4gIHV0aWwuZGVmaW5lXG4gICggcHJvdG9cbiAgLCAnYWRkJ1xuICAsICBmdW5jdGlvbih2YWwpIHtcbiAgICAgICBpZiggIXZhbC5wcm9jZXNzIClcbiAgICAgICB7XG4gICAgICAgICAgYWRkLmFwcGx5KCB0aGlzLCBhcmd1bWVudHMgKVxuICAgICAgIH0gZWxzZVxuICAgICAgIHtcbiAgICAgICAgICB2YWwuX190ZW1wQWRkID0gdXRpbC5hcmcoIGFyZ3VtZW50cyApXG4gICAgICAgICAgdmFsLl9fdGVtcEFkZC51bnNoaWZ0KHRoaXMpXG4gICAgICAgfVxuICAgICB9XG4gIClcblxuICBiYXNlLmV4dGVuZCh7XG4gICAgcHJvY2VzczogZnVuY3Rpb24odmFsKSB7XG4gICAgICBjb25zb2xlLmxvZygneHh4eF9fX3h4eHgnKVxuICAgICAgaWYodGhpcy5fX3RlbXBBZGQgJiYgIXRoaXMucGFyZW50KSB7XG4gICAgICAgIGFkZC5hcHBseSh0aGlzLl9fdGVtcEFkZFswXSwgdGhpcy5fX3RlbXBBZGQuc2xpY2UoMSkpXG4gICAgICAgIHRoaXMuX190ZW1wQWRkID0gbnVsbFxuICAgICAgfVxuICAgIH1cbiAgfSlcblxufSlcblxuLy9wcm9jZXNzIHdvcmR0IG1pc2NoaWVuIG1lZXIgZWVuIG9wZXJhdG9yP1xuLy9zb29ydCBmaWVsZCBlaWdlbmxpamsiLCIvKiFcbiAqIEBsaWNlbnNlIENvcHlyaWdodCAoYykgMjAxMi0yMDE0LCBWaWdvdXIuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBAYXV0aG9yOiBKaW0gZGUgQmVlciwgamltQHZpZ291ci5pb1xuICovXG52YXIgZXZlbnRzID0gcmVxdWlyZSgnLi4vLi4vZXZlbnRzJylcbiAgLCBjYXNlcyA9IHJlcXVpcmUoJy4uLy4uL2Nhc2VzJylcbiAgLCB1YSA9IHJlcXVpcmUoJy4uLy4uL3VhJylcbiAgLCBnbG9iYWwgPSBmYWxzZVxuICAsIE5PTkUgPSAnbm9uZSdcbiAgLCBfaW9zID0gdWEucGxhdGZvcm09PT0naW9zJ1xuICAsIF9hbmRyb2lkID0gdWEucGxhdGZvcm09PT0nYW5kcm9pZCdcbiAgLCBWSVNJQkxFID0gJ3Zpc2libGUnXG4gICwgZXh0ZW5kID0gcmVxdWlyZSgnLi4vLi4vLi4vdXRpbCcpLmV4dGVuZFxuICAsIGRvYyA9IGV2ZW50cy5kb2N1bWVudFxuICAsIHRpbWVyXG4gICwgZm5cblxuaWYoY2FzZXMudG91Y2gpe1xuXG4gIGZ1bmN0aW9uIGJsdXIgKGUpe1xuICAgIGlmKCFkb2N1bWVudC5hY3RpdmVFbGVtZW50KXtcbiAgICAgIGRvYy5yZW1vdmVFdmVudChmYWxzZSwnYmx1cicpXG4gICAgfWVsc2UgaWYoZS50YXJnZXQudGFnTmFtZSE9PSdJTlBVVCcgJiYgZS50YXJnZXQudGFnTmFtZSE9PSdGT1JNJyl7XG4gICAgICBkb2N1bWVudC5hY3RpdmVFbGVtZW50LmJsdXIoKVxuICAgICAgZG9jLnJlbW92ZUV2ZW50KGZhbHNlLCdibHVyJylcbiAgICB9XG4gIH1cblxuICBldmVudHMucHJldmVudERvd24gPSBcbiAgeyB2YWw6XG4gICAgeyBkb3duOmZ1bmN0aW9uKGUsbWV0aG9kKSB7XG4gICAgICAgIGlmKGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQpIGRvYy5hZGRFdmVudCgndXAnLGJsdXIsJ2JsdXInKVxuICAgICAgICBlbHNlIGlmKGUudGFyZ2V0LnRhZ05hbWUhPT0nSU5QVVQnICYmIGUudGFyZ2V0LnRhZ05hbWUhPT0nRk9STScgJiYgIWV2ZW50cy5fbWF5YmVzY3JvbGwpIGUucHJldmVudERlZmF1bHQoKVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGV2ZW50cy5zY3JvbGxiYXIgPSBcbiAgeyB2YWw6IFxuICAgIHsgZG93bjpmdW5jdGlvbihlLG1ldGhvZCx2YWwpIHtcblxuICAgICAgICB2YXIgc2Nyb2xsU3RhcnRcbiAgICAgICAgICAsIHQgPSB0aGlzXG4gICAgICAgICAgLCBzY3JvbGxTdHJcbiAgICAgICAgICAsIHhBeGlzID0gKHZhbC5fdmFsID09PSAneCcpXG4gICAgICAgICAgLCBheGlzXG4gICAgICAgICAgLCBvdGhlcmF4aXNcbiAgICAgICAgICAsIG1vdmVcbiAgICAgICAgICAsIGRcbiAgICAgICAgICAsIGJvdHRvbVByZXZlbnRcbiAgICAgICAgICBcbiAgICAgICAgaWYoeEF4aXMpIHtcbiAgICAgICAgICBheGlzID0gJ3gnXG4gICAgICAgICAgb3RoZXJheGlzID0gJ3knXG4gICAgICAgICAgc2Nyb2xsU3RyID0gJ3Njcm9sbExlZnQnXG4gICAgICAgICAgZCA9IHQubm9kZS5zY3JvbGxXaWR0aCAtIHQubm9kZS5vZmZzZXRXaWR0aFxuICAgICAgICB9ZWxzZXtcbiAgICAgICAgICBheGlzID0gJ3knXG4gICAgICAgICAgb3RoZXJheGlzID0gJ3gnXG4gICAgICAgICAgc2Nyb2xsU3RyID0gJ3Njcm9sbFRvcCdcbiAgICAgICAgICBkID0gdC5ub2RlLnNjcm9sbEhlaWdodCAtIHQubm9kZS5vZmZzZXRIZWlnaHRcbiAgICAgICAgfVxuXG4gICAgICAgIHNjcm9sbFN0YXJ0ID0gdC5ub2RlW3Njcm9sbFN0cl0gLy88PT09PT09PT0gbGVzcyBlZmZpY2llbnQgYnV0IG1vcmUgcHJlZGljdGFibGUgZm9yIGNvbXBlbnNhdGlvblxuXG4gICAgICAgIGlmKGQgPiAwKXtcbiAgICAgICAgICBldmVudHNbYXhpc10gPSB0cnVlXG4gICAgICAgICAgZXZlbnRzLl9tYXliZXNjcm9sbCA9IHRydWVcbiAgICAgICAgICBpZigheEF4aXMpe1xuICAgICAgICAgICAgaWYgKCFzY3JvbGxTdGFydCl7XG4gICAgICAgICAgICAgIHNjcm9sbFN0YXJ0ID0gdC5ub2RlW3Njcm9sbFN0cl0gPSAgMVxuICAgICAgICAgICAgfWVsc2UgaWYoc2Nyb2xsU3RhcnQ9PT1kKSB7XG4gICAgICAgICAgICAgIHNjcm9sbFN0YXJ0ID0gdC5ub2RlW3Njcm9sbFN0cl0gPSBkIC0gMVxuICAgICAgICAgICAgfWVsc2UgaWYoc2Nyb2xsU3RhcnQgPiBkKXtcbiAgICAgICAgICAgICAgYm90dG9tUHJldmVudCA9IHRydWVcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgeSA9IGUueVxuICAgICAgICAgICAgLCB4ID0gZS54XG4gICAgICAgICAgICAsIG1vdmVpZCA9IHNjcm9sbFN0ciArIGF4aXNcbiAgICAgICAgICBcbiAgICAgICAgICBkb2MuYWRkRXZlbnQoJ21vdmUnLGZ1bmN0aW9uKGUpe1xuICAgICAgICAgICAgdmFyIGR4ID0gTWF0aC5hYnMoeC1lLngpXG4gICAgICAgICAgICAgICwgZFkgPSB5LWUueVxuICAgICAgICAgICAgICAsIGR5ID0gTWF0aC5hYnMoZFkpXG5cbiAgICAgICAgICAgIGlmKHhBeGlzKXtcbiAgICAgICAgICAgICAgaWYoZHkgPiBkeCl7XG4gICAgICAgICAgICAgICAgZXZlbnRzW2F4aXNdID0gZmFsc2VcbiAgICAgICAgICAgICAgICBpZighZXZlbnRzW290aGVyYXhpc10pIGUucHJldmVudERlZmF1bHQoKVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9ZWxzZXtcbiAgICAgICAgICAgICAgaWYoZHggPiBkeSl7XG4gICAgICAgICAgICAgICAgZXZlbnRzW2F4aXNdID0gZmFsc2VcbiAgICAgICAgICAgICAgICBpZighZXZlbnRzW290aGVyYXhpc10pIGUucHJldmVudERlZmF1bHQoKVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmKGJvdHRvbVByZXZlbnQgJiYgZFkgPiAwKXtcbiAgICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KClcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc29sZS5sb2coJ21vdmUnKVxuICAgICAgICAgICAgbW92ZSA9IHRydWVcbiAgICAgICAgICAgIGJsdXIoZSlcbiAgICAgICAgICAgIGRvYy5yZW1vdmVFdmVudChmYWxzZSxtb3ZlaWQpXG4gICAgICAgICAgfSxtb3ZlaWQpXG5cbiAgICAgICAgICBkb2MuYWRkRXZlbnQoJ3VwJyxmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICB2YXIgbXMgPSBldmVudHMuX21heWJlc2Nyb2xsLCBtc2wsIGFyclxuXG4gICAgICAgICAgICBpZighbW92ZSl7XG4gICAgICAgICAgICAgIHZhciBzY3JsbCA9IHQubm9kZVtzY3JvbGxTdHJdXG4gICAgICAgICAgICAgIG1vdmUgPSAhKHNjcmxsID09PSBzY3JvbGxTdGFydCkgfHwgc2NybGwgPCAwIHx8ICggc2NybGwgPiBkICYmICFib3R0b21QcmV2ZW50IClcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYoICFtb3ZlICYmICFldmVudHNbb3RoZXJheGlzXSAmJiAhZXZlbnRzLmNsaWNrLmJsb2NrICYmIG1zICYmIG1zLmxlbmd0aCApe1xuICAgICAgICAgICAgICBtc2wgPSBtcy5sZW5ndGhcbiAgICAgICAgICAgICAgd2hpbGUobXNsLS0pXG4gICAgICAgICAgICAgIHsgaWYoIWUucHJldmVudCl7XG4gICAgICAgICAgICAgICAgICBhcnIgPSBtc1ttc2xdXG4gICAgICAgICAgICAgICAgICBhcnJbMF0uY2FsbChhcnJbMV0sZSlcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYoIWV2ZW50c1tvdGhlcmF4aXNdIHx8IG1vdmUpIGV2ZW50cy5fbWF5YmVzY3JvbGwgPSBmYWxzZVxuXG4gICAgICAgICAgICBldmVudHNbYXhpc10gPSBmYWxzZVxuICAgICAgICAgICAgZG9jLnJlbW92ZUV2ZW50KGZhbHNlLHNjcm9sbFN0cilcblxuICAgICAgICAgICAgd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZShmdW5jdGlvbigpe1xuICAgICAgICAgICAgICBkb2N1bWVudC5ib2R5LnNjcm9sbFRvcCA9IDBcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgfSxzY3JvbGxTdHIpXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmbiA9IGZ1bmN0aW9uICh2YWwpIHtcbiAgICAgIFxuICAgIHZhciBzdHlsZSA9IHRoaXMubm9kZS5zdHlsZVxuXG4gICAgaWYgKHZhbC52YWwgPT09ICd4Jykge1xuICAgICAgc3R5bGUubXNUb3VjaEFjdGlvbiA9ICdwYW4teCdcbiAgICAgIHN0eWxlLnRvdWNoQWN0aW9uID0gJ3Bhbi14J1xuICAgICAgc3R5bGUub3ZlcmZsb3dZID0gJ2hpZGRlbidcbiAgICAgIC8vIHN0eWxlLm92ZXJmbG93WCA9ICdzY3JvbGwnXG4gICAgfWVsc2UgaWYgKHZhbC52YWwgPT09ICd5Jykge1xuICAgICAgc3R5bGUubXNUb3VjaEFjdGlvbiA9ICdwYW4teSdcbiAgICAgIHN0eWxlLnRvdWNoQWN0aW9uID0gJ3Bhbi15J1xuICAgICAgc3R5bGUub3ZlcmZsb3dYID0gJ2hpZGRlbidcbiAgICAgIC8vIHN0eWxlLm92ZXJmbG93WSA9ICdzY3JvbGwnXG4gICAgfVxuXG4gICAgc3R5bGUub3ZlcmZsb3cgPSAnc2Nyb2xsJ1xuXG4gICAgc3R5bGUud2Via2l0T3ZlcmZsb3dTY3JvbGxpbmcgPSAndG91Y2gnXG4gICAgc3R5bGUubXNUb3VjaEFjdGlvbiA9ICdhdXRvJ1xuICAgIHN0eWxlLnRvdWNoQWN0aW9uID0gJ2F1dG8nXG5cbiAgICB0aGlzLmV2ZW50cyA9IHsgc2Nyb2xsYmFyOnZhbC52YWwgfVxuICAgIGlmKCFnbG9iYWwpIHtcbiAgICAgIGdsb2JhbCA9IHRydWVcbiAgICAgIGRvYy5ldmVudHMgPSB7IHByZXZlbnREb3duOnRydWUgfVxuICAgIH1cbiAgfVxuXG59ZWxzZXtcbiAgZm4gPSBmdW5jdGlvbiAodmFsKSB7XG4gICAgdmFyIHN0eWxlID0gdGhpcy5ub2RlLnN0eWxlO1xuICAgIHN0eWxlLm92ZXJmbG93ID0gJ2F1dG8nO1xuICAgIHN0eWxlLm92ZXJmbG93WSA9IHZhbC52YWwgIT09ICd4JyA/ICdzY3JvbGwnIDogJ2hpZGRlbic7XG4gICAgc3R5bGUub3ZlcmZsb3dYID0gdmFsLnZhbCAhPT0gJ3knID8gJ3Njcm9sbCcgOiAnaGlkZGVuJztcbiAgfVxufVxuXG5leHBvcnRzLmV4dGVuZCA9IGV4dGVuZChmdW5jdGlvbihiYXNlKSB7XG4gIGJhc2UuZXh0ZW5kKHsgc2Nyb2xsYmFyOmZuIH0pXG59KSAgIiwiLyohXG4gKiBAbGljZW5zZSBDb3B5cmlnaHQgKGMpIDIwMTItMjAxNCwgVmlnb3VyLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogQGF1dGhvcjogSmltIGRlIEJlZXIsIGppbUB2aWdvdXIuaW9cbiAqL1xuXG52YXIgdXRpbCA9IHJlcXVpcmUoJy4uLy4uL3V0aWwnKVxuICAsIGVsZW1lbnQgPSByZXF1aXJlKCcuLycpXG4gICwgb2JqZWN0ID0gcmVxdWlyZSgnLi4vLi4vb2JqZWN0JylcblxuLyoqXG4gKiBmbGFnc1xuICogYWRkIGtleXdvcmRzIHRvIHNldCBvYmplY3RzIHdoaWNoIGFyZSBjaGVja2VkIHVzaW5nIGEgZnVuY3Rpb24gaW4gZmxhZ3NcbiAqIHNpbXBseSBhZGQgZmllbGRzIHRvIHRoZSBzZXQgbW9kdWxlXG4gKi9cbnZhciBmbGFncyA9IGV4cG9ydHNcbiAgLyoqXG4gICAqIF9mbGFnXG4gICAqIGZ1bmN0aW9uIHRoYXQgY2FsbHMgZmxhZyBmdW5jdGlvbnMgb24gZWxlbWVudC5zZXQuZmxhZ3NcbiAgICovXG4gICwgX2ZsYWcgPSBmdW5jdGlvbihuYW1lLCB2YWwsIGNvcHksIHRvcCkge1xuICAgICAgdmFyIGY7XG4gICAgICBmb3IgKHZhciBpIGluIGZsYWdzKSB7XG4gICAgICAgIGYgPSBmbGFnc1tpXS5jYWxsKHRoaXMsIG5hbWUsIHZhbCwgY29weSwgdG9wKTtcbiAgICAgICAgaWYgKGYpIHtcbiAgICAgICAgICByZXR1cm4gZjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxudXRpbC5kZWZpbmUoZWxlbWVudCxcbiAgLyoqXG4gICAqIHNldFxuICAgKiBhZGRzIGNoaWxkcmVuIGZvciBub24gZXhpc3RpbmcgYXR0cmlidXRlc1xuICAgKiBfb3JpZ2luYWwgYXJlIG9yaWdpbmFsIHZhbHVlcyBjaGFuZ2VkIGJ5IGNhc2VzIGFuZCBldmVudHNcbiAgICogaW5zdGFuY2VzIC0gYWRkIG9yIHJlbW92ZSBjaGlsZHJlbiBmcm9tIGluc3RhbmNlcztcbiAgICovXG4gICdfc2V0JywgZnVuY3Rpb24odmFsLCBpLCBpbnN0YW5jZXMpIHtcblxuICAgIGlmICghX2ZsYWcuY2FsbCh0aGlzLCBpLCB2YWxbaV0sIGluc3RhbmNlcywgdmFsKSkge1xuICAgICAgaWYgKCAhdGhpcy5pc1Byb3BlcnR5KCBpLCB2YWwgKSApIHtcbiAgICAgICAgaWYgKHZhbFtpXSBpbnN0YW5jZW9mIGVsZW1lbnQpIHtcbiAgICAgICAgICB2YXIgYmVmb3JlXG4gICAgICAgICAgaWYgKHRoaXNbaV0pIHtcbiAgICAgICAgICAgIGZvcih2YXIgYz10aGlzLm5vZGUuY2hpbGROb2Rlcyxub2RlJD0wLGxlbj1jLmxlbmd0aDtub2RlJDxsZW47bm9kZSQrKykge1xuICAgICAgICAgICAgICBpZihjW25vZGUkXT09PXRoaXNbaV0ubm9kZSkge1xuICAgICAgICAgICAgICAgIGJlZm9yZSA9IGNbKG5vZGUkKzEpXVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzW2ldLnJlbW92ZSAmJiB0aGlzW2ldLnJlbW92ZSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICAvL3JlcGxhY2UgZWxlbWVudCBpZiBpdHMgYWxyZWFkeSB0aGVyZVxuICAgICAgICAgIC8vIGNvbnNvbGUuZXJyb3IoYWRkLCBpbnN0YW5jZXMsIHZhbFtpXSlcbiAgICAgICAgICB2YXIgYWRkID0gaW5zdGFuY2VzID8gbmV3IHZhbFtpXS5DbGFzcyA6IHZhbFtpXTtcbiAgICAgICAgICBhZGQubmFtZSA9IGk7XG4gICAgICAgICAgdGhpcy5hZGQoYWRkLCBiZWZvcmUpO1xuICAgICAgICAgIGlmIChpbnN0YW5jZXMpIHtcbiAgICAgICAgICAgIHRoaXMuZWFjaEluc3RhbmNlKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICB2YXIgYSA9IG5ldyBhZGQuQ2xhc3MoKTtcbiAgICAgICAgICAgICAgYS5fbmFtZSA9IGk7XG4gICAgICAgICAgICAgIHRoaXMuYWRkKGEpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmKCB0aGlzW2ldIGluc3RhbmNlb2Ygb2JqZWN0ICkgXG4gICAgICAgICAge1xuICAgICAgICAgICAgLy9UT0RPOiB0b3JvdWdoIHRlc3RpbmdcbiAgICAgICAgICAgIHRoaXNbaV0udmFsID0gdmFsW2ldXG4gICAgICAgICAgfSBcbiAgICAgICAgICBlbHNlIGlmKCB2YWxbaV0gaW5zdGFuY2VvZiBvYmplY3QgKSBcbiAgICAgICAgICB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oJ2FyZSB5b3Ugc3VyZSB5b3Ugd2FudCB0byBzZXQgdXNpbmcgYSB2T2JqZWN0PyBtYXliZSByZXF1aXJlIHNvbWUgc3R1ZmYgKGUuZy4gZGF0YSknKVxuICAgICAgICAgICAgdGhpc1tpXSA9IHZhbFtpXVxuICAgICAgICAgIH0gXG4gICAgICAgICAgZWxzZSBpZiggdGhpc1tpXSBpbnN0YW5jZW9mIGVsZW1lbnQgKSBcbiAgICAgICAgICB7XG4gICAgICAgICAgICB0aGlzW2ldLnNldCh2YWxbaV0sIGluc3RhbmNlcylcbiAgICAgICAgICB9IFxuICAgICAgICAgIGVsc2UgXG4gICAgICAgICAge1xuICAgICAgICAgICAgdmFyIGFkZCA9IG5ldyBlbGVtZW50KCkuc2V0KHZhbFtpXSwgaW5zdGFuY2VzKVxuICAgICAgICAgICAgYWRkLm5hbWUgPSBpO1xuICAgICAgICAgICAgdGhpcy5hZGQoYWRkKVxuICAgICAgICAgICAgaWYgKGluc3RhbmNlcykgXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIHRoaXMuZWFjaEluc3RhbmNlKCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICB2YXIgYSA9IG5ldyBhZGQuQ2xhc3MoKVxuICAgICAgICAgICAgICAgIGEuX25hbWUgPSBpXG4gICAgICAgICAgICAgICAgdGhpcy5hZGQoYSlcbiAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmICh2YWxbaV0gPT09IGZhbHNlICYmICh0aGlzW2ldIGluc3RhbmNlb2YgZWxlbWVudCkpIHtcbiAgICAgICAgICBpZiAoaW5zdGFuY2VzKSB7XG4gICAgICAgICAgICB0aGlzLmVhY2hJbnN0YW5jZShmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgaWYgKHRoaXNbaV0pIHRoaXNbaV0ucmVtb3ZlKClcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXNbaV0ucmVtb3ZlKClcbiAgICAgICAgICB0aGlzW2ldID0gbnVsbFxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vaGllciBmZiBjaGVja2tlbiB2b29yIGZ1bmN0aWVcbiAgICAgICAgICBpZih0eXBlb2YgdGhpc1tpXSA9PT0gJ2Z1bmN0aW9uJykge1xuXG4gICAgICAgICAgICAvLyBhbGVydCgnQ0FMTCBGVU5DVElPTicpXG5cbiAgICAgICAgICAgIGlmKHZhbFtpXSBpbnN0YW5jZW9mIEFycmF5KSB7XG4gICAgICAgICAgICAgIHRoaXNbaV0uYXBwbHkodGhpcyx2YWxbaV0pXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB0aGlzW2ldKHZhbFtpXSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpc1tpXSA9IHZhbFtpXVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgLy9keW5hbWljIGNoYW5nZXMgdG8gdGhlIF9vcmlnaW5hbCBzZXQgb2JqZWN0IHBvb2xcbiAgICAgIC8vaWYgKCFjb3B5ICYmIHRoaXMuX29yaWdpbmFsKSB7XG4gICAgICAvL3RoaXMuX29yaWdpbmFsW2ldID0gdmFsW2ldOyAvL2NoZWNrIGlmIHN0dWZmIC93IGNsYXNzZXMgaXMgbmVzc2VjYXJ5O1xuICAgICAgLy99XG4gICAgfVxuICB9LFxuICAvKipcbiAgICogY29udmVydFxuICAgKiBmb3IgZWFjaCBmaWVsZHMgaW4gdmFsIGNvbnZlcnQgYmFjayB0byBhIHNldE9iamVjdDtcbiAgICovXG4gICdjb252ZXJ0JywgZnVuY3Rpb24odmFsKSB7XG4gICAgdmFyIHNldE9iaiA9IHt9LFxuICAgICAgaXNPYmo7XG4gICAgZm9yICh2YXIgaSBpbiB2YWwpIHtcbiAgICAgIGlzT2JqID0gdXRpbC5pc09iaih2YWxbaV0pXG4gICAgICBpZiAodGhpc1tpXSBpbnN0YW5jZW9mIGVsZW1lbnQpIHtcbiAgICAgICAgc2V0T2JqW2ldID0gaXNPYmogPyB0aGlzW2ldLmNvbnZlcnQodmFsW2ldKSA6IHRoaXNbaV1cbiAgICAgIH0gZWxzZSBpZiAodGhpc1tpXSBpbnN0YW5jZW9mIG9iamVjdCkge1xuICAgICAgICBzZXRPYmpbaV0gPSB0aGlzW2ldLmNvbnZlcnQoaXNPYmogJiYgdmFsW2ldKVxuICAgICAgfSBlbHNlIGlmICh0aGlzW2ldID09PSB2b2lkIDAgfHwgKHV0aWwubG9va3VwLmNhbGwodGhpcywgaSkgJiYgdGhpc1tpXSA9PT0gZmFsc2UpKSB7XG4gICAgICAgIHNldE9ialtpXSA9IGZhbHNlXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzZXRPYmpbaV0gPSB0aGlzW2ldXG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBzZXRPYmpcbiAgfSkiLCIvKiFcbiAqIEBsaWNlbnNlIENvcHlyaWdodCAoYykgMjAxMi0yMDE0LCBWaWdvdXIuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBAYXV0aG9yOiBKaW0gZGUgQmVlciwgamltQHZpZ291ci5pb1xuICovXG52YXIgZXZlbnRzID0gbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuLycpXG4gICwgY2FzZXMgPSByZXF1aXJlKCcuLi9jYXNlcycpXG4gICwgdXRpbCA9IHJlcXVpcmUoJy4uLy4uL3V0aWwnKVxuICAsIHVhID0gcmVxdWlyZSgnLi4vdWEnKVxuXG5jYXNlcy50b3VjaCA9XG4oICggJ29udG91Y2hzdGFydCcgaW4gd2luZG93IClcbiAgfHwgd2luZG93LkRvY3VtZW50VG91Y2hcbiAgJiYgZG9jdW1lbnQgaW5zdGFuY2VvZiBEb2N1bWVudFRvdWNoXG4pXG58fCBuYXZpZ2F0b3IubXNNYXhUb3VjaFBvaW50c1xufHwgZmFsc2VcblxuZnVuY3Rpb24gX2Jhc2ljKGUsIG1ldGhvZCwgdmFsKSB7XG4gIGUueCA9IGUucGFnZVhcbiAgZS55ID0gZS5wYWdlWVxuICBtZXRob2QuY2FsbCh0aGlzLCBlLCB2YWwpXG59XG5cbnV0aWwuZGVmaW5lXG4oIGV2ZW50c1xuLCAnX291dCdcbiwgeyB2YWx1ZTogW10gfVxuKVxuLy9jbGlja291dCBjYW5ub3QgYmUgdXNlZCB0byBjcmVhdGUgY29tcGxleCBldmVudHMhIGl0J3MgdG9vIGN1c3RvbSBcbi8vdHJpZWQgdG8gZml4XG5cbmZ1bmN0aW9uIGtleUJvYXJkRXZlbnQoIG5hbWUsIGRvbUV2ZW50LCB3cmFwcGVyICkge1xuXG4gIHZhciBfbmFtZSA9ICdfJytuYW1lXG5cbiAgdXRpbC5kZWZpbmUoIGV2ZW50cywgX25hbWUsIHsgdmFsdWU6W10gfSApXG5cbiAgdmFyIGV2ZW50ID0gXG4gIHtcbiAgICBjcmVhdGU6IGZ1bmN0aW9uKCBmaWVsZCwgZnJvbSApIHtcbiAgICAgIHZhciBleGVjID0gZnVuY3Rpb24oIGUgKSB7XG5cbiAgICAgICAgLy9kaXQgZ2FhdCBoZWVsIHNuZWwgZm91dCBoaWVyb1xuICAgICAgICAvLyBjb25zb2xlLmxvZygnbnUgZmYgb29rIGRlIHdyYXBwZXIgY2FsbGVuIScsIGZpZWxkLCBmcm9tLCBldmVudHNbZnJvbV0pXG4gICAgICAgICBpZiggdGhpcy5yZW5kZXJlZCApIHtcblxuICAgICAgICAgIGlmKCB3cmFwcGVyICkge1xuICAgICAgICAgICAgd3JhcHBlci5jYWxsKHRoaXMsIGUsIHRoaXMuZXZlbnRzW2Zyb21dLl92YWwgKVxuICAgICAgICAgICAgLy90aGlzLmV2ZW50c1tmcm9tXS5fdmFsLmNhbGwodGhpcywgZSlcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSBpZiggZXZlbnRzW2Zyb21dICYmIGV2ZW50c1tmcm9tXS52YWwpIHtcbiAgICAgICAgICAgIHZhciBtZXRob2QgPSBldmVudHNbZnJvbV0udmFsXG4gICAgICAgICAgICBmb3IodmFyIGkgaW4gZXZlbnRzW2Zyb21dKSB7XG4gICAgICAgICAgICAgIGlmKCBjYXNlc1tpXSkge1xuICAgICAgICAgICAgICAgIG1ldGhvZCA9IGV2ZW50c1tmcm9tXVtpXVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBtZXRob2QgPSBtZXRob2RbZmllbGRdXG4gICAgICAgICAgICBpZiggbWV0aG9kICkge1xuICAgICAgICAgICAgICBtZXRob2QuY2FsbCh0aGlzLCBlLCB0aGlzLmV2ZW50c1tmcm9tXS5fdmFsIClcbiAgICAgICAgICAgIH0gXG4gICAgICAgICAgfSBlbHNlIGlmKCB0aGlzLmV2ZW50c1tmcm9tXSApIHtcbiAgICAgICAgICAgIHRoaXMuZXZlbnRzW2Zyb21dLl92YWwuY2FsbCh0aGlzLCBlKVxuICAgICAgICAgIH1cblxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBldmVudHMuZG9jdW1lbnQuYWRkRXZlbnQoIGRvbUV2ZW50LCBmdW5jdGlvbihlKSB7XG5cbiAgICAgICAgZm9yICggdmFyIGFyciA9IGV2ZW50c1sgX25hbWUgXSwgaSA9IGFyci5sZW5ndGggLSAxOyBpID49IDA7IGktLSApIHtcbiAgICAgICAgICBleGVjLmNhbGwoIGFycltpXSwgZSApXG4gICAgICAgICAgXG4gICAgICAgICAgaWYoIGFycltpXSApIHtcbiAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKCAnZG8gaXQgbm93IScsIF9uYW1lLCBhcnIsIGFycltpXSwgZSlcbiAgICAgICAgICAgIGFycltpXS5lYWNoSW5zdGFuY2UoIGV4ZWMsICdldmVudHMnLCBlIClcbiAgICAgICAgICB9XG5cbiAgICAgICAgfVxuICAgICAgfSwgbmFtZSApXG4gICAgfSxcbiAgICBhZGQ6IGZ1bmN0aW9uKCBpZCwgZmllbGQgKSB7XG5cbiAgICAgIGZpZWxkID0gX25hbWVcblxuICAgICAgdGhpcy5zZXRTZXR0aW5nKFxuICAgICAgeyBuYW1lOiBmaWVsZFxuICAgICAgLCByZW1vdmU6IGV2ZW50c1sgbmFtZSBdLnJlbW92ZVxuICAgICAgfSlcblxuICAgICAgaWYgKCAhdXRpbC5jaGVja0FycmF5KCBldmVudHNbIF9uYW1lIF0sIHRoaXMgKSApIFxuICAgICAge1xuICAgICAgICBldmVudHNbIF9uYW1lIF0ucHVzaCh0aGlzKVxuICAgICAgfVxuXG4gICAgfSxcbiAgICByZW1vdmU6IGZ1bmN0aW9uKCkge1xuICAgICAgLy8gY29uc29sZS5sb2coJ1dST05HV1JPTkdXUk9ORyEhISEhJywgX25hbWUsIGV2ZW50c1tfbmFtZV0sIGV2ZW50cylcbiAgICAgIC8vc2VsZWN0ZWQgbW9ldCBtaXNjaGVpbiBhbGxlZW4gdmFudWl0IFZhbHVlICRmb2N1c2VkIC0tIG5pZXQgb3AgZWxrIGl0ZW0gb3Aga2V5IHVwLi4uLlxuICAgICAgLy9kb2UgZGl0IHNtYXJ0IC0tIGZvciBub3cgem91IGF1dG8gcmVtb3ZlIGt1bm5lbiBkb2VuIGFscyBpZXRzIGVyIG5pZXQgbWVlciBpcz9cbiAgICAgIHZhciBpbmRleCA9IHV0aWwuY2hlY2tBcnJheSggZXZlbnRzWyBfbmFtZSBdLCB0aGlzLCB0cnVlICkgXG4gICAgICBpZiggfmluZGV4ICkge1xuXG4gICAgICAgIHZhciBub1JlbW92ZVxuXG4gICAgICAgIC8vIGNvbnNvbGUubG9nKCd0aGlzOicsIHRoaXMgKVxuICAgICAgICAvLyBjb25zb2xlLmxvZygnZnJvbSBiYXNlOicsIHRoaXMuX2Zyb20uYmFzZSlcbiAgICAgICAgLy8gY29uc29sZS5sb2coJ2V2ZW50IG5hbWU6JywgbmFtZSlcbiAgICAgICAgLy8gY29uc29sZS5sb2coJ2V2ZW50czonLCB0aGlzLmV2ZW50cyApXG4gICAgICAgIGlmKHRoaXMuZXZlbnRzICYmIHRoaXMuX2Zyb20uYmFzZS5ldmVudHMpIHsgXG4gICAgICAgICAgbm9SZW1vdmUgPSB0aGlzLmV2ZW50c1tuYW1lXSA9PT0gdGhpcy5fZnJvbS5iYXNlLmV2ZW50c1tuYW1lXVxuICAgICAgICAgIC8vIGNvbnNvbGUubG9nKCdldmVudHMgZXF1YWxzIGNsYXNzOicsIG5vUmVtb3ZlIClcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBjb25zb2xlLmVycm9yKCdubyBuaWNlIGV2ZW50cycpXG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIGlmKCFub1JlbW92ZSkge1xuICAgICAgICAgIGV2ZW50c1sgX25hbWUgXS5zcGxpY2UoIGluZGV4LCAxIClcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBjb25zb2xlLmxvZyhub1JlbW92ZSwgJ25vUmVtb3ZlIGV2bnQsIGFyZSB3ZSBzdXJlIC0gZml4IHRoaXMgYXNhcCcpXG4gICAgICAgIH1cbiAgICAgICAgLy8gZGVidWdnZXJcbiAgICAgICAgLy8gdGhpcy5yZW1vdmVTZXR0aW5nKCBuYW1lICkgLS0tIHJlZG8gdGhpcyBsYXRlclxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGV2ZW50c1sgbmFtZSBdID0gZXZlbnRcblxufVxuXG5ldmVudHMuJG1ha2VLZXlCb2FyZEV2ZW50ID0ga2V5Qm9hcmRFdmVudFxuXG5rZXlCb2FyZEV2ZW50KCAna2V5Ym9hcmQnLCAna2V5dXAnIClcbmtleUJvYXJkRXZlbnQoICdrZXlib2FyZERvd24nLCAna2V5ZG93bicgKVxua2V5Qm9hcmRFdmVudCggJ2tleWJvYXJkRG93biRkb3duJywgJ2tleWRvd24nIClcbmtleUJvYXJkRXZlbnQoICdrZXlib2FyZERvd24kY2xpY2snLCAna2V5ZG93bicgKVxuXG4vLy0tLS0tZGl0IGZmIGVjaHQgZ29lZCBmaXhlbiFcblxuZnVuY3Rpb24gYmFzaWNEb3duKGUsIG1ldGhvZCwgdmFsKSB7XG4gIGlmKCBlLndoaWNoICE9PSAxIHx8IGV2ZW50cy5kb3duLmJsb2NrICkgcmV0dXJuXG4gICBfYmFzaWMuY2FsbCh0aGlzLGUsIG1ldGhvZCwgdmFsKVxufVxuXG5ldmVudHMuZG93biA9XG57IHRvdWNoOlxuICB7IHRvdWNoc3RhcnQ6IGZ1bmN0aW9uKGUsIG1ldGhvZCwgdmFsKSB7XG4gICAgICBpZihldmVudHMuZG93bi5ibG9jaykgcmV0dXJuXG4gICAgICB2YXIgdGFyZ2V0VG91Y2hlcyA9IGUudGFyZ2V0VG91Y2hlc1swXSB8fCB7fVxuICAgICAgZS54ID0gdGFyZ2V0VG91Y2hlcy5wYWdlWFxuICAgICAgZS55ID0gdGFyZ2V0VG91Y2hlcy5wYWdlWVxuICAgICAgbWV0aG9kLmNhbGwodGhpcywgZSwgdmFsKVxuICAgIH1cbiAgfVxuLCB2YWw6IHsgbW91c2Vkb3duOiBiYXNpY0Rvd24gfVxuLy8gLCB0djogXG4vLyAgIHsgIC8vIG1vdXNlZG93bjogYmFzaWNEb3duIC8vY29tYmluZXJlbiBiaW5uZW4ga29ydCBtb2V0IHZvb3IgTEdcbi8vICAgICAga2V5Ym9hcmREb3duJGRvd246IGZ1bmN0aW9uKCBlLCBtZXRob2QsIHZhbCApIHtcbi8vICAgICAgIC8vdGhpcy5fJGZvY3VzZWQgJiYgXG4vLyAgICAgICBpZiggdGhpcy5fJGZvY3VzZWQgJiYgdXRpbC5jaGVja0FycmF5KCBbIDEzLCAyOTQ0MyBdICwgZS5rZXlDb2RlICkgIT09IGZhbHNlICkgXG4vLyAgICAgICB7XG4vLyAgICAgICAgIG1ldGhvZC5jYWxsKHRoaXMsIGUsIHZhbClcbi8vICAgICAgIH1cblxuLy8gICAgIH1cbi8vICAgfVxufVxuXG4vL3JpZ2h0LWRvd25cbmV2ZW50cy5yZG93biA9XG57IHRvdWNoOlxuICB7IHRvdWNoc3RhcnQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIC8vMiBmaW5nZXJzP1xuICAgIH1cbiAgfVxuLCB2YWw6XG4gIHsgbW91c2Vkb3duOiBmdW5jdGlvbiAoZSwgbWV0aG9kLCB2YWwpIHtcbiAgICAgIGlmKGUud2hpY2g9PT0zKSB7XG4gICAgICAgIGRvY3VtZW50Lm9uY29udGV4dG1lbnUgPSBmdW5jdGlvbigpIHsgcmV0dXJuIGZhbHNlIH1cbiAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpXG4gICAgICAgIC8vIGUucmRvd24gPSB0cnVlXG4gICAgICAgIF9iYXNpYy5jYWxsKHRoaXMsZSxtZXRob2QsdmFsKVxuICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkgeyBkb2N1bWVudC5vbmNvbnRleHRtZW51ID0gZmFsc2UgfSwgMClcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuLy9tb3ZlXG5ldmVudHMubW92ZSA9IHtcbiAgdG91Y2g6XG4gIHsgdG91Y2htb3ZlOiBmdW5jdGlvbiAoZSwgbWV0aG9kLCB2YWwpIHtcbiAgICAgIHZhciB0YXJnZXRUb3VjaGVzID0gZS50YXJnZXRUb3VjaGVzWzBdXG4gICAgICBlLnggPSB0YXJnZXRUb3VjaGVzLnBhZ2VYXG4gICAgICBlLnkgPSB0YXJnZXRUb3VjaGVzLnBhZ2VZXG4gICAgICBtZXRob2QuY2FsbCh0aGlzLCBlLCB2YWwpXG4gICAgICAvLyBkb2N1bWVudC53cml0ZShlLnRhcmdldFRvdWNoZXNbMF0ucGFnZVgpO1xuICAgIH1cbiAgfVxuICAsIHZhbDoge1xuICAgIG1vdXNlbW92ZTogX2Jhc2ljXG4gIH1cbn1cblxuLy91cFxuZXZlbnRzLnVwID0ge1xuICAvL2tleVVwXG4gIHRvdWNoOiB7XG4gICAgdG91Y2hlbmQ6IGZ1bmN0aW9uKGUsIG1ldGhvZCwgdmFsKSB7XG4gICAgICB2YXIgY3QgPSBlLmNoYW5nZWRUb3VjaGVzXG4gICAgICBlLnggPSBjdFswXS5wYWdlWFxuICAgICAgZS55ID0gY3RbMF0ucGFnZVlcbiAgICAgIG1ldGhvZC5jYWxsKHRoaXMsIGUsIHZhbClcbiAgICB9XG4gIH1cbiwgdmFsOiB7XG4gICAgbW91c2V1cDogX2Jhc2ljXG4gIH1cbn1cblxuLy9jbGlja1xuZXZlbnRzLmNsaWNrID0ge1xuICAvLyB0djoge1xuICAvLyAgIGtleWJvYXJkRG93biRjbGljazogZnVuY3Rpb24oZSwgbWV0aG9kLCB2YWwgKSB7XG5cbiAgLy8gICAgIGlmKCB0aGlzLl8kZm9jdXNlZCAmJiB1dGlsLmNoZWNrQXJyYXkoIFsgMTMsIDI5NDQzIF0gLCBlLmtleUNvZGUgKSAhPT0gZmFsc2UgKSB7XG4gIC8vICAgICAgIG1ldGhvZC5jYWxsKHRoaXMsIGUsIHZhbClcbiAgLy8gICAgIH1cblxuICAvLyAgIH1cbiAgLy8gfSxcbiAgdmFsOiB7XG4gICAgZG93bjogZnVuY3Rpb24oZSwgbWV0aG9kLCB2YWwpIHtcbiAgICAgIHZhciB0ID0gdGhpc1xuICAgICAgICAsIG5hbWUgPSAnY2xpY2snXG4gICAgICBpZiggIWV2ZW50cy5jbGljay5ibG9jayApXG4gICAgICB7XG4gICAgICAgIHQuYWRkRXZlbnQoJ3VwJywgZnVuY3Rpb24oZSkge1xuICAgICAgICAgIHQucmVtb3ZlRXZlbnQoJ3VwJywgbmFtZSlcbiAgICAgICAgICB2YXIgbXMgPSBldmVudHMuX21heWJlc2Nyb2xsXG4gICAgICAgICAgaWYobXMpe1xuICAgICAgICAgICAgaWYobXMubGVuZ3RoKSBldmVudHMuX21heWJlc2Nyb2xsLnVuc2hpZnQoW21ldGhvZCx0XSlcbiAgICAgICAgICAgIGVsc2UgZXZlbnRzLl9tYXliZXNjcm9sbCA9IFtbbWV0aG9kLHRdXVxuICAgICAgICAgIH1lbHNlIGlmKCFldmVudHMuY2xpY2suYmxvY2spIG1ldGhvZC5jYWxsKHQsIGUsIHZhbClcbiAgICAgICAgfSwgbmFtZSk7XG5cbiAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgICB0LnJlbW92ZUV2ZW50KCd1cCcsIG5hbWUpXG4gICAgICAgIH0sIDMwMClcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuZXZlbnRzLnJjbGljayA9IHtcbiAgdmFsOiB7XG4gICAgcmRvd246ZXZlbnRzLmNsaWNrLnZhbC5kb3duXG4gIH1cbn1cblxudmFyIF9vdXRSZW1vdmUgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgaW5kZXggPSB1dGlsLmNoZWNrQXJyYXkoZXZlbnRzLl9vdXQsIHRoaXMsIHRydWUpXG4gICAgaWYgKH5pbmRleCkge1xuICAgICAgZXZlbnRzLl9vdXQuc3BsaWNlKGluZGV4LCAxKVxuICAgICAgdGhpcy5yZW1vdmVTZXR0aW5nKCdfb3V0JywgX291dFNldHRpbmcpXG5cbiAgICAgIC8vIGRlYnVnZ2VyXG5cbiAgICB9XG4gIH1cbiwgX291dFNldHRpbmcgPSB7XG4gIG5hbWU6ICdfb3V0JyxcbiAgcmVuZGVyOiBmdW5jdGlvbigpIHtcbiAgICBpZiAoIXV0aWwuY2hlY2tBcnJheShldmVudHMuX291dCwgdGhpcykpIHtcbiAgICAgIGV2ZW50cy5fb3V0LnB1c2godGhpcylcbiAgICB9XG4gIH0sXG4gIHJlbW92ZTogX291dFJlbW92ZVxufVxuXG5ldmVudHMub3V0ID0ge1xuICBjcmVhdGU6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMubSA9IHRydWU7XG4gICAgZXZlbnRzLmRvY3VtZW50LmFkZEV2ZW50KCd1cCcsIGZ1bmN0aW9uKGUpIHtcblxuICAgICAgdmFyIGJhc2UgPSBlLnRhcmdldCxcbiAgICAgICAgZXhlYyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHZhciBwID0gYmFzZVxuICAgICAgICAgICAgLCB0XG4gICAgICAgICAgd2hpbGUgKHAgJiYgIXQpIHtcbiAgICAgICAgICAgIGlmIChwLmJhc2UgJiYgdGhpcyA9PT0gcC5iYXNlKSB7XG4gICAgICAgICAgICAgIHQgPSB0cnVlO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcCA9IHAucGFyZW50Tm9kZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKCF0ICYmIHRoaXMucmVuZGVyZWQpIHRoaXMuZXZlbnRzLm91dC5fdmFsLmNhbGwodGhpcywgZSlcbiAgICAgICAgfVxuICAgICAgZm9yICh2YXIgYXJyID0gZXZlbnRzLl9vdXQsIGkgPSBhcnIubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgZXhlYy5jYWxsKGFycltpXSlcbiAgICAgICAgaWYgKGFycltpXSkgYXJyW2ldLmVhY2hJbnN0YW5jZShleGVjLCAnZXZlbnRzJylcbiAgICAgIH1cbiAgICB9LCdvdXQnKVxuICB9LFxuICBhZGQ6IGZ1bmN0aW9uKCkge1xuICAgIHZhciB0ID0gdGhpc1xuICAgICAvLyBldmVudHMuX291dC5wdXNoKHRoaXMpXG4gICAgdGhpcy5zZXRTZXR0aW5nKF9vdXRTZXR0aW5nKVxuICB9LFxuICByZW1vdmU6X291dFJlbW92ZVxufTsiLCIvKiFcbiAqIEBsaWNlbnNlIENvcHlyaWdodCAoYykgMjAxMi0yMDE0LCBWaWdvdXIuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBAYXV0aG9yOiBKaW0gZGUgQmVlciwgamltQHZpZ291ci5pb1xuICovXG52YXIgZWxlbWVudCA9IHJlcXVpcmUoJy4uL2VsZW1lbnQnKVxuICAsIGNhc2VzID0gcmVxdWlyZSgnLi4vY2FzZXMnKVxuICAsIHV0aWwgPSByZXF1aXJlKCcuLi8uLi91dGlsJylcbiAgLCBGaWVsZFN0b3JlID0gZnVuY3Rpb24gKCkge31cblxudXRpbC5kZWZpbmUoRmllbGRTdG9yZSwgJ191aWQnLCB7IHZhbHVlOiAwIH0pXG5cbmV4cG9ydHMuX3IgPSB7fSAvL2xpc3Qgb2YgYmFzaWMgKHJhdykgZXZlbnRzIGUuZy4gJ21vdXNlZG93bidcblxuLy9yZW1vdmUgZXZlbnRzIGlmIHRoZXJlIGFyZSBubyBjaGlsZHJlbiB0aGF0IHVzZSB0aGVtIGFueW1vcmVcblxuZXhwb3J0cy5kb2N1bWVudCA9IG5ldyBlbGVtZW50KHsgbm9kZTogZG9jdW1lbnQgfSlcblxuZXhwb3J0cy5kb2N1bWVudC5leGVjID0gZnVuY3Rpb24oIGV2ZW50ICkge1xuICBpZiggdGhpcy5fX2VbZXZlbnRdIClcbiAge1xuICAgIHZhciBhcmdzID0gdXRpbC5hcmcoIGFyZ3VtZW50cywgMSApXG4gICAgZm9yKCB2YXIgaSBpbiB0aGlzLl9fZVtldmVudF0gKVxuICAgIHtcbiAgICAgIHRoaXMuX19lW2V2ZW50XVtpXS5hcHBseSggdGhpcywgYXJncyApXG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIF9jcmVhdGUoIGksIGZyb20gKSB7XG4gIGlmKCBleHBvcnRzW2ldIClcbiAge1xuICAgIC8vIGNvbnNvbGUubG9nKCdjb21wbGV4JywgaSwgZnJvbSlcbiAgICBfY3JlYXRlQ29tcGxleCggaSwgZnJvbSApXG4gIH1cbiAgZWxzZVxuICB7XG4gICAgLy8gY29uc29sZS5sb2coJ19iYXNpYycsIGkpXG5cbiAgICBleHBvcnRzW2ldID0geyBfYmFzaWM6IHRydWUgfVxuICAgIF9jcmVhdGVCYXNpYyggaSApXG4gIH1cbn1cblxuZnVuY3Rpb24gX2NyZWF0ZVdoaWxlIChpLCBtKSB7XG4gIHJldHVybiBmdW5jdGlvbihlKSB7XG4gICAgdmFyIHBhcmVudCA9IGUudGFyZ2V0XG4gICAgICAsIGJhc2UsIGV2ZW50c1xuICAgIHdoaWxlIChwYXJlbnQpIHtcbiAgICAgIGJhc2UgPSBwYXJlbnQuYmFzZVxuICAgICAgaWYgKGJhc2UpIHtcbiAgICAgICAgZXZlbnRzID0gYmFzZS5ldmVudHNcbiAgICAgICAgaWYgKGV2ZW50c1tpXSkge1xuICAgICAgICAgIGlmIChtKSB7XG4gICAgICAgICAgICBleHBvcnRzW2ldLl9tLmNhbGwoYmFzZSwgZSwgZXZlbnRzW2ldKVxuICAgICAgICAgIH0gZWxzZSBpZiAoZXZlbnRzW2ldLl92YWwpIHtcbiAgICAgICAgICAgIGV2ZW50c1tpXS5fdmFsLmNhbGwoYmFzZSwgZSlcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGUucHJldmVudCkgcmV0dXJuXG4gICAgICAgIH1cbiAgICAgICAgZXZlbnRzID0gYmFzZS5fX2VcbiAgICAgICAgaWYgKGV2ZW50cyAmJiBldmVudHNbaV0pIHtcblxuICAgICAgICAgIGZvciAodmFyIGogaW4gZXZlbnRzW2ldKSB7XG4gICAgICAgICAgICBpZihqIT09J191aWQnKSB7XG4gICAgICAgICAgICAgIGlmIChtKSB7XG4gICAgICAgICAgICAgICAgZXhwb3J0c1tpXS5fbS5jYWxsKGJhc2UsIGUsIGV2ZW50c1tpXVtqXSlcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBjb25zb2xlLmxvZygnP3doYXQnLCBpLCBqLCBiYXNlLCBiYXNlLl9ub2RlKVxuICAgICAgICAgICAgICAgIGV2ZW50c1tpXVtqXS5jYWxsKGJhc2UsIGUpXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKGUucHJldmVudCkgcmV0dXJuXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBwYXJlbnQgPSBwYXJlbnQucGFyZW50Tm9kZVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBfY3JlYXRlQmFzaWMgKGksIHIpIHtcbiAgdmFyIHR5cGUgPSBpIHx8IHJcblxuICAvLyBjb25zb2xlLmxvZygnY3JlYXRlQmFzaWMnLCB0eXBlKVxuXG4gIGV4cG9ydHMuX3JbaV0gPSB0cnVlXG4gIGlmKHR5cGUgPT09ICdzY3JvbGwnKSB7XG4gICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcih0eXBlLCBmdW5jdGlvbihlKXtcbiAgICAgIHZhciBiYXNlID0gZS50YXJnZXQuYmFzZVxuICAgICAgICAsIGV2ZW50c1xuICAgICAgaWYoYmFzZSkge1xuICAgICAgICBldmVudHMgPSBiYXNlLmV2ZW50c1xuICAgICAgICBpZihldmVudHMgJiYgZXZlbnRzW2ldKSBldmVudHNbaV0uX3ZhbC5jYWxsKGJhc2UsIGUpXG4gICAgICAgIGV2ZW50cyA9IGJhc2UuX19lXG4gICAgICAgIGlmIChldmVudHMgJiYgZXZlbnRzW2ldKSB7XG4gICAgICAgICAgZm9yICh2YXIgaiBpbiBldmVudHNbaV0pIHtcbiAgICAgICAgICAgIGlmKGohPT0nX3VpZCcpIGV2ZW50c1tpXVtqXS5jYWxsKGJhc2UsIGUpXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSx0cnVlKVxuICB9ZWxzZSBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKHR5cGUsIChleHBvcnRzW2ldLm0gPSBfY3JlYXRlV2hpbGUoaSkpKVxufVxuXG5mdW5jdGlvbiBfc2V0Q29tcGxleCAoIGksIG0sIHIsIGZyb20gKSB7XG4gIHZhciBtZXQgPSBleHBvcnRzW2ldLl9tID0gZnVuY3Rpb24gKGUsIHZhbCkge1xuICAgIGlmIChlLnByZXZlbnQpIHJldHVyblxuICAgIG0uY2FsbCh0aGlzLCBlLCAodmFsLl92YWwgfHwgdmFsLnZhbCB8fCB2YWwpLCB2YWwpXG4gIH1cbiAgZXhwb3J0c1tpXS5tID0gX2NyZWF0ZVdoaWxlKGksIHRydWUpXG4gIGV4cG9ydHMuX3JbaV0gPSB0cnVlXG4gIGlmIChleHBvcnRzW3JdKSB7XG4gICAgaWYgKCFleHBvcnRzW3JdLm0pIHtcbiAgICAgIF9jcmVhdGUociwgZnJvbSApXG4gICAgfVxuICAgIGlmICghZXhwb3J0c1tyXS5fYmFzaWMpIHtcbiAgICAgIGV4cG9ydHNbaV0uX19lID0gZXhwb3J0c1tyXS5fX2VcbiAgICAgIGV4cG9ydHNbaV0uX20gPSBmdW5jdGlvbiAoZSwgbSkge1xuICAgICAgICBleHBvcnRzW3JdLl9tLmNhbGwodGhpcywgZSwgZnVuY3Rpb24oZSkge1xuICAgICAgICAgIG1ldC5jYWxsKHRoaXMsIGUsIG0pXG4gICAgICAgIH0pXG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGV4cG9ydHNbaV0uX19lID0gclxuICAgIH1cbiAgfVxuICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKChleHBvcnRzW3JdICYmIGV4cG9ydHNbcl0uX19lKSB8fCByLCBleHBvcnRzW2ldLm0pXG59XG5cbnZhciBhZGRXcmFwcGVyID0gZnVuY3Rpb24oIGFkZCwgZmllbGQsIG9yaWcgKSB7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAvLyBjb25zb2xlLmxvZyggJ0FERCBXUkFQIScsIGZpZWxkLCBvcmlnICwgYXJndW1lbnRzIClcbiAgICByZXR1cm4gYWRkLmFwcGx5KHRoaXMsIGFyZ3VtZW50cylcbiAgfVxufVxuXG5mdW5jdGlvbiBfY3JlYXRlQ29tcGxleCggZmllbGQsIGZyb20gKSB7XG5cbiAgLy8gY29uc29sZS5sb2coJ19jcmVhdGVDb21wbGV4JyAsZmllbGQsIGZyb20gKVxuXG4gIGlmKCBleHBvcnRzW2ZpZWxkXS5jcmVhdGUgKSBleHBvcnRzW2ZpZWxkXS5jcmVhdGUoIGZpZWxkLCBmcm9tKVxuICB2YXIgbVxuICAgICwgaVxuICAgICwgalxuICBmb3IgKCBpIGluIGV4cG9ydHNbZmllbGRdICkge1xuICAgIGlmIChjYXNlc1tpXSA9PT0gdHJ1ZSkgbSA9IGV4cG9ydHNbZmllbGRdW2ldXG4gIH1cbiAgaWYgKCBtIHx8ICggbSA9IGV4cG9ydHNbZmllbGRdLnZhbCApICkge1xuICAgIGZvciAoaiBpbiBtKSAvL29ubHkgb25lXG4gICAgO2V4cG9ydHNbZmllbGRdLl9fZSA9IGpcblxuICAgIGlmIChtW2pdID09PSB0cnVlKSBcbiAgICB7XG4gICAgICBleHBvcnRzW2ZpZWxkXS5fYmFzaWMgPSB0cnVlXG4gICAgICBfY3JlYXRlQmFzaWMoZmllbGQsIGopXG4gICAgfSBcbiAgICBlbHNlIFxuICAgIHtcbiAgICAgIC8vYmFzaWMgZW4gbm9uIGJhc2ljIGlqbiBuaWV0IHRlIGNvbWJpbmVyZW4gLS0gY29tYmluZXJlbiBub2cga2Fwb3RcbiAgICAgIC8vIGNvbnNvbGUubG9nKCdzZXQgY29tcGxleCBmaWVsZCcsIGZpZWxkLCBtLCBqLCAgZXhwb3J0c1tqXSkgXG4gICAgICAvLyEhIXRyaXBwbGUgY2hlY2sgZGl0ISEhXG4gICAgICAgZm9yKCBqIGluIG0gKSBcbiAgICAgICB7IFxuICAgICAgICBpZiggZXhwb3J0c1tqXSAmJiBleHBvcnRzW2pdLmFkZCBcbiAgICAgICAgICYmIGV4cG9ydHNbZmllbGRdICYmICFleHBvcnRzW2ZpZWxkXS5hZGRcbiAgICAgICAgKSBcbiAgICAgICAge1xuICAgICAgICAgIGV4cG9ydHNbZmllbGRdLmFkZCA9IGFkZFdyYXBwZXIoIGV4cG9ydHNbal0uYWRkLCBmaWVsZCwgaiApXG4gICAgICAgIH1cbiAgICAgICAgX3NldENvbXBsZXgoZmllbGQsIG1bal0sIGosIGZyb20gKVxuICAgICAgfVxuICAgICAgLy8hISFkYW5nZXIgbG9vcCEhIVxuICAgIH1cblxuICB9XG59XG5cbmV4cG9ydHMuX3NldCA9IGZ1bmN0aW9uICh2YWwsIHN0YW1wLCBmcm9tLCByZW1vdmUsIGN2YWwsIGJsYWNrbGlzdCkge1xuICB2YXIgdCA9IHRoaXNcbiAgdmFsLmVhY2goZnVuY3Rpb24gKGkpIHtcbiAgICBpZiAoIWJsYWNrbGlzdCB8fCAhYmxhY2tsaXN0W2ldKSB7XG4gICAgICBpZiAodGhpcy5fdmFsID09PSBmYWxzZSkge1xuICAgICAgICBpZiAoZXhwb3J0c1tpXSkge1xuICAgICAgICAgIGlmIChleHBvcnRzW2ldLnJlbW92ZSkgZXhwb3J0c1tpXS5yZW1vdmUuY2FsbCh0KVxuICAgICAgICAgIHQuZWFjaEluc3RhbmNlKGV4cG9ydHNbaV0ucmVtb3ZlLCB2YWwuX3Byb3AubmFtZSlcbiAgICAgICAgICB0aGlzLnJlbW92ZSgpXG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIFxuICAgICAgICAvLyBjb25zb2xlLmxvZygnX2NyZScsIGksIGV4cG9ydHNbaV0pXG5cbiAgICAgICAgaWYgKCEoZXhwb3J0c1tpXSAmJiBleHBvcnRzW2ldLm0pKSB7XG4gICAgICAgICAgLy8gY29uc29sZS5sb2coJy0tLXBhc3MnLCBpKVxuICAgICAgICAgIF9jcmVhdGUoaSwgaSlcbiAgICAgICAgfVxuICAgICAgICAvL2FkZCB3cmFwcGVyP1xuXG5cbiAgICAgICAgLy8gY29uc29sZS5sb2coJ19zZXQnLGksIGV4cG9ydHNbaV0uYWRkLCBleHBvcnRzW2ldKVxuXG4gICAgICAgIGlmIChleHBvcnRzW2ldLmFkZCkgZXhwb3J0c1tpXS5hZGQuY2FsbCggdCwgZmFsc2UsIGkgKVxuICAgICAgfVxuICAgIH1cbiAgfSlcbn1cblxuZWxlbWVudC5iYXNlLmV4dGVuZChcbnsgbmFtZTogJ2V2ZW50cydcbiwgc2V0OiBleHBvcnRzLl9zZXRcbn0pXG5cbnV0aWwuZGVmaW5lKGVsZW1lbnRcbiwgJ2FkZEV2ZW50JywgZnVuY3Rpb24oZmllbGQsIGZuLCBpZCkge1xuICAgICAgICAgIC8vIGNvbnNvbGUubG9nKCdYWFhYJyxmaWVsZClcblxuICAgIGlmICghKGV4cG9ydHNbZmllbGRdICYmIGV4cG9ydHNbZmllbGRdLm0pKSBfY3JlYXRlKGZpZWxkKVxuICAgIHZhciBldmVudHMgPSB0aGlzLl9fZSB8fCAodGhpcy5fX2UgPSB7fSlcbiAgICAgICwgZiA9IGV2ZW50c1tmaWVsZF0gfHwgKGV2ZW50c1tmaWVsZF0gPSBuZXcgRmllbGRTdG9yZSgpKVxuXG4gICAgaWYgKCFpZCkge1xuICAgICAgZi5fdWlkKytcbiAgICAgIGlkID0gZi5fdWlkXG4gICAgfVxuICAgIGZbaWRdID0gZm5cblxuICAgIC8vIGNvbnNvbGUubG9nKCdhZGRFdmVudCEhIScsIGZpZWxkKVxuXG4gICAgaWYgKGV4cG9ydHNbZmllbGRdLmFkZCkgZXhwb3J0c1tmaWVsZF0uYWRkLmNhbGwodGhpcywgaWQsIGZpZWxkKVxuICAgIHJldHVybiB0aGlzXG4gIH1cbiwgJ3JlbW92ZUV2ZW50JywgZnVuY3Rpb24gKGZpZWxkLCBpZCwgZm4pIHtcbiAgICB2YXIgZXZlbnRzID0gdGhpcy5fX2VcbiAgICAgICwgcmVtb3ZlXG4gICAgaWYgKGV2ZW50cykge1xuICAgICAgaWYgKGZpZWxkICYmIGV2ZW50c1tmaWVsZF0pIHtcbiAgICAgICAgcmVtb3ZlID0gKGV4cG9ydHNbZmllbGRdICYmIGV4cG9ydHNbZmllbGRdLnJlbW92ZSlcbiAgICAgICAgaWYgKGlkKSB7XG4gICAgICAgICAgaWYgKGV2ZW50c1tmaWVsZF1baWRdICYmICghZm4gfHwgZXZlbnRzW2ZpZWxkXVtpZF0gPT09IGZuKSkge1xuICAgICAgICAgICAgaWYgKHJlbW92ZSkgZXhwb3J0c1tmaWVsZF0ucmVtb3ZlLmNhbGwodGhpcywgaWQpXG4gICAgICAgICAgICBkZWxldGUgZXZlbnRzW2ZpZWxkXVtpZF1cbiAgICAgICAgICB9XG4gICAgICAgIH0gXG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIGZvciAoaWQgaW4gZXZlbnRzW2ZpZWxkXSkge1xuICAgICAgICAgICAgaWYgKCFmbiB8fCBldmVudHNbZmllbGRdW2lkXSA9PT0gZm4pIHtcbiAgICAgICAgICAgICAgaWYgKHJlbW92ZSkgZXhwb3J0c1tmaWVsZF0ucmVtb3ZlLmNhbGwodGhpcywgaWQpXG4gICAgICAgICAgICAgIGRlbGV0ZSBldmVudHNbZmllbGRdW2lkXVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAodXRpbC5lbXB0eShldmVudHNbZmllbGRdKSkgZGVsZXRlIGV2ZW50c1tmaWVsZF1cbiAgICAgIH0gXG4gICAgICBlbHNlIGlmICghZmllbGQpIHtcbiAgICAgICAgZm9yIChmaWVsZCBpbiBldmVudHMpIHtcbiAgICAgICAgICB0aGlzLnJlbW92ZUV2ZW50KGZpZWxkLCBpZCwgZm4pXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHV0aWwuZW1wdHkoZXZlbnRzKSkgZGVsZXRlIHRoaXMuX19lXG4gICAgcmV0dXJuIHRoaXNcbiAgfSlcblxucmVxdWlyZSgnLi9iYXNpYycpXG4iLCIvKiFcbiAqIEBsaWNlbnNlIENvcHlyaWdodCAoYykgMjAxMi0yMDE0LCBWaWdvdXIuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBAYXV0aG9yOiBKaW0gZGUgQmVlciwgamltQHZpZ291ci5pb1xuICovXG52YXIgX2EgPSAnYWRkRXZlbnRMaXN0ZW5lcidcbiAgLCB1dGlsID0gcmVxdWlyZSgnLi4vLi4vdXRpbCcpXG4gICwgdWEgPSByZXF1aXJlKCcuLi91YScpXG4gICwgY250ID0gMFxuXG4vKipcbiAqIHhociB3cmFwcGVyLCBhZGRzIHNvbWUgbmljZSBleHRyYXMgc3VjaCBhcyBtdWx0aXBsZSByZXF1ZXN0cyB0byBhIHNpbmdsZSBhcGkgY2FsbFxuICogeGhyIHdyYXBwZXIgd2lsbCBpbmNsdWRlIGpzb25wIGluIGEgbGF0ZXIgc3RhZ2VcbiAqIEBtZXRob2QgZXh0ZW5kXG4gKiBAcGFyYW0gICB7U3RyaW5nfEFycmF5fSBwYXJhbXMudXJsICAgICAgICAgU3BlY2lmaXkgdGhlIHVybCwgYXJyYXkgZmV0Y2hlcyBtdWx0aXBsZSB1cmwnc1xuICogQHBhcmFtICAge1N0cmluZ30gICBbcGFyYW1zLmFwaV0gICAgICAgICAgIFJlcGVhdCB0aGlzIHN0cmluZyBmb3IgdGhlIHVybCB0aGF0IG5lZWRzIHRvIGJlIGNhbGxlZFxuICogQHBhcmFtICAge0Z1bmN0aW9ufSBbcGFyYW1zLmNvbXBsZXRlXSAgICAgIFNwZWNpZnkgYSBjYWxsYmFjayB3aGVuIGFuIGFycmF5IGlzIHBhc3NlZCB0byB1cmwgY29tcGxldGUgaXMgY2FsbGVkIHdoZW4gYWxsIGl0ZW1zIGFyZSBjb21wbGV0ZVxuICogQHBhcmFtICAge0Z1bmN0aW9ufSBbcGFyYW1zLmVycm9yXSAgICAgICAgIE9uIGVycm9yIGNhbGxiYWNrXG4gKiBAcGFyYW0gICB7RnVuY3Rpb259IFtwYXJhbXMuY2hhbmdlXSAgICAgICAgRnVuY3Rpb24gY2FsbGVkIG9uIHhoci5vbnJlYWR5c3RhdGVjaGFuZ2VcbiAqIEBwYXJhbSAgIHtCb29sZWFufSAgW3BhcmFtcy5hc3luY10gICAgICAgICBJZiBzZXQgdG8gZmFsc2Ugd2lsbCBjYWxsIGFuIHN5bmNyb25vdXMgcmVxdWVzdCAobm90IHJlY29tbWVuZGVkISlcbiAqIEBwYXJhbSAgIHtTdHJpbmd9ICAgW3BhcmFtcy51c2VyXSAgICAgICAgICBVc2VyIHBhcmFtZXRlclxuICogQHBhcmFtICAge1N0cmluZ30gICBbcGFyYW1zLnBhc3NdICAgICAgICAgIFBhc3N3b3JkIHBhcmFtZXRlclxuICogQHBhcmFtICAge0Jvb2xlYW59ICBbcGFyYW1zLnBhcnNlXSAgICAgICAgIElmIHNldCB0byBmYWxzZSB3aWxsIG5vdCB0cnkgdG8gcGFyc2UgcmVzcG9uc2UgdG8gSlNPTlxuICogQHBhcmFtICAge1N0cmluZ30gICBbcGFyYW1zLnR5cGV8Lm1ldGhvZF0gIFBPU1Qgb3IgR0VULCBkZWZhdWx0IGlzIGdldDtcbiAqIEBwYXJhbSAgIHtTdHJpbmd9ICAgW3BhcmFtcy5jb250ZW50VHlwZV0gICByZXF1ZXN0IGNvbnRlbnQgdHlwZSBkZWZhdWx0IGlkIFwiYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkXCJcbiAqIEBwYXJhbSAgIHtTdHJpbmd9ICAgW3BhcmFtcy5taW1lXSAgICAgICAgICBkZWZpbmVzIG1pbWUgdHlwZVxuICogQHBhcmFtICAge0Z1bmN0aW9ufSBbcGFyYW1zLnByb2dyZXNzXSAgICAgIFByb2dyZXNzIGNhbGxiYWNrXG4gKiBAcGFyYW0gICB7Qm9vbGVhbnxTdHJpbmd9IFtwYXJhbXMuanNvbnBdICAgVXNlIGpzb25wICwgaWYgcGFzc2VkIGFzIGEgc3RyaW5nIGRldGVybWluZXMgc2NyaXB0Kz9jYWxsYmFjaz1cbiAqIEBwYXJhbSAgIHtPYmplY3R9ICAgW3BhcmFtcy5oZWFkZXJdICAgICAgICBTZXRzIHJlcXVlc3QgaGVhZGVyc1xuICogQHBhcmFtICAgeyp9ICAgICAgICBbcGFyYW1zLmRhdGFdICAgICAgICAgIFBhc3MgZGF0YSB0byB0aGUgcmVxdWVzdCwgZGVmYXVsdHMgdG8gPyBvbiBnZXQ7XG4gKi9cblxudmFyIGlmcmFtZXNcbiAgLCBhamF4ID0gbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihwYXJhbXMsIHVybHNldCkge1xuICAgIHZhciBfdXJsID0gcGFyYW1zLnVybDtcbiAgICBpZiAoIXVybHNldCAmJiBfdXJsIGluc3RhbmNlb2YgQXJyYXkpIHtcbiAgICAgIHBhcmFtcy5tID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICgoKytwYXJhbXMucikgPT09IHBhcmFtcy5uKSB7XG4gICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGFyciA9IFtdLCBsID0gX3VybC5sZW5ndGg7IGkgPCBsOyBhcnIucHVzaChwYXJhbXMuZFtfdXJsW2krK11dKSk7XG4gICAgICAgICAgcGFyYW1zLmNvbXBsZXRlKGFycik7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICBwYXJhbXMuciA9IDA7XG4gICAgICBwYXJhbXMuZCA9IHt9O1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBwYXJhbXMubiA9IF91cmwubGVuZ3RoOyBpIDwgbDsgbW9kdWxlLmV4cG9ydHMocGFyYW1zLCBfdXJsW2krK10pKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGRhdGEgPSBwYXJhbXMuZGF0YVxuICAgICAgICAsIGVuY29kZSA9IHBhcmFtcy5lbmNvZGVcbiAgICAgICAgLCB1cmwgPSAocGFyYW1zLmFwaSB8fCAnJykgKyAodXJsc2V0IHx8IF91cmwpXG4gICAgICAgICwgaGVhZGVycyA9IHBhcmFtcy5oZWFkZXJzXG4gICAgICAgICwgc3VjY2VzcyA9IHBhcmFtcy5jb21wbGV0ZVxuICAgICAgICAsIHByb2dyZXNzID0gcGFyYW1zLnByb2dyZXNzXG4gICAgICAgICwgZXJyb3IgPSBwYXJhbXMuZXJyb3JcbiAgICAgICAgLCBjaGFuZ2UgPSBwYXJhbXMuY2hhbmdlXG4gICAgICAgICwgbWltZSA9IHBhcmFtcy5taW1lXG4gICAgICAgICwgdXNlciA9IHBhcmFtcy51c2VyXG4gICAgICAgICwgcGFzcyA9IHBhcmFtcy5wYXNzXG4gICAgICAgICwganNvbnAgPSBwYXJhbXMuanNvbnBcbiAgICAgICAgLCBwYXJzZSA9IHBhcmFtcy5wYXJzZVxuICAgICAgICAsIGlmcmFtZSA9IHBhcmFtcy5pZnJhbWVcbiAgICAgICAgLCByZXFkYXRhID0gbnVsbFxuICAgICAgICAsIGZhbGxiYWNrID0gcGFyYW1zLmZhbGxiYWNrXG4gICAgICAgICwgZmFsbGJhY2tJbmRleCA9IHBhcmFtcy5fZmFsbGJhY2tJbmRleFxuICAgICAgICAsIG1ldGhvZCA9IHBhcmFtcy50eXBlIHx8IHBhcmFtcy5tZXRob2QgfHwgJ0dFVCdcbiAgICAgICAgLCBjb250ZW50VHlwZSA9IHBhcmFtcy5jb250ZW50VHlwZSB8fCBlbmNvZGUgPT09ICdqc29uJ1xuICAgICAgICAgID8gJ2FwcGxpY2F0aW9uL2pzb24nXG4gICAgICAgICAgOiAnYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkJ1xuICAgICAgICAsIGFzeW5jID0gKHBhcmFtcy5hc3luYyA9PT0gZmFsc2UpID8gZmFsc2UgOiB0cnVlXG4gICAgICAgIFxuICAgICAgaWYoIGpzb25wICkgXG4gICAgICB7XG4gICAgICAgIGFqYXguanNvbnAoIHVybCwgc3VjY2VzcywgZXJyb3IgKSAgXG4gICAgICAgIC8vZnVuY3Rpb24oIHVybCwgc3VjY2VzcywgZXJyb3IsIGNvbnRleHQsIGNiTmFtZSApIHtcbiAgICAgIH0gXG4gICAgICBlbHNlIFxuICAgICAge1xuICAgICAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gREFUQVxuICAgICAgICB2YXIgeGhyID0gbmV3IFhNTEh0dHBSZXF1ZXN0KClcbiAgICAgICAgaWYoaWZyYW1lKSB7XG4gICAgICAgICAgY250KytcbiAgICAgICAgICB2YXIgZWxlbVxuICAgICAgICAgICAgLCBtc2cgPSB7fVxuICAgICAgICAgICAgLCByZXFpZCA9IGNudFxuXG4gICAgICAgICAgZm9yKHZhciBmaWVsZCBpbiBwYXJhbXMpIHtcbiAgICAgICAgICAgIGlmKGZpZWxkIT09J2Vycm9yJyYmZmllbGQhPT0naWZyYW1lJyYmZmllbGQhPT0nY29tcGxldGUnKSB7XG5cbiAgICAgICAgICAgICAgbXNnW2ZpZWxkXT1wYXJhbXNbZmllbGRdXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciBzZXRtc2cgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciBlbGVtXG4gICAgICAgICAgICBpZnJhbWVzW2lmcmFtZV0ub25sb2FkID0gbnVsbFxuICAgICAgICAgICAgdmFyIG1zZ2NvbXBsZXRlID0gZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgICAvLyBjb25zb2xlLmVycm9yKCdJRlJBTUUgUkVRIE1TRyBDT01QTEVURScsZS5kYXRhKVxuICAgICAgICAgICAgICBpZihlLmRhdGEpIHtcbiAgICAgICAgICAgICAgICB2YXIgZFxuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICBkID0gSlNPTi5wYXJzZShlLmRhdGEpXG4gICAgICAgICAgICAgICAgfSBjYXRjaChlKSB7XG4gICAgICAgICAgICAgICAgICBpZihlcnJvcikgZXJyb3IoZSlcbiAgICAgICAgICAgICAgICAgIHJldHVyblxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZihkLmlkIT09cmVxaWQpIHJldHVyblxuICAgICAgICAgICAgICAgIGlmKGQuZXJyKSB7XG4gICAgICAgICAgICAgICAgICBpZihlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICBlcnJvcihkLmVycilcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIHJldHVyblxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgcmVzcCA9IGQubXNnXG4gICAgICAgICAgICAgICAgaWYoc3VjY2Vzcykge1xuICAgICAgICAgICAgICAgICAgaWYgKHBhcnNlICE9PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgIHJlc3AgPSBKU09OLnBhcnNlKHJlc3ApXG4gICAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHt9XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBzdWNjZXNzKHJlc3AsZSlcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmVtb3ZlRXZlbnRMaXN0ZW5lcignbWVzc2FnZScsIG1zZ2NvbXBsZXRlKVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZih3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcikge1xuICAgICAgICAgICAgICBhZGRFdmVudExpc3RlbmVyKFwibWVzc2FnZVwiLCBtc2djb21wbGV0ZSwgZmFsc2UpXG4gICAgICAgICAgICAgIGVsZW0gPSBpZnJhbWVzW2lmcmFtZV0uY29udGVudFdpbmRvd1xuICAgICAgICAgICAgICBtc2cgPSBKU09OLnN0cmluZ2lmeSh7XG4gICAgICAgICAgICAgICAgbXNnOm1zZyxcbiAgICAgICAgICAgICAgICBpZDpyZXFpZFxuICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICBlbGVtLnBvc3RNZXNzYWdlKG1zZywgJyonKVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmKCFpZnJhbWVzKSBpZnJhbWVzID0ge31cbiAgICAgICAgICBpZighaWZyYW1lc1tpZnJhbWVdKSB7XG4gICAgICAgICAgICBlbGVtID0gaWZyYW1lc1tpZnJhbWVdID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaWZyYW1lJylcbiAgICAgICAgICAgIGVsZW0uc3JjID0gaWZyYW1lXG4gICAgICAgICAgICBlbGVtLmNMaXN0ZW5lcnMgPSBbXG4gICAgICAgICAgICAgIHNldG1zZ1xuICAgICAgICAgICAgXVxuICAgICAgICAgICAgZWxlbS5vbmxvYWQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgZm9yKHZhciBoIGluIGVsZW0uY0xpc3RlbmVycykge1xuICAgICAgICAgICAgICAgIGVsZW0uY0xpc3RlbmVyc1toXSgpXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgZWxlbS5jTGlzdGVuZXJzID0gbnVsbFxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxlbS5zdHlsZS52aXNpYmlsaXR5PSdoaWRkZW4nXG4gICAgICAgICAgICBlbGVtLnN0eWxlLndpZHRoID0gJzBweCdcbiAgICAgICAgICAgIGVsZW0uc3R5bGUuaGVpZ2h0ID0gJzBweCdcbiAgICAgICAgICAgIGVsZW0uc3R5bGUucG9zaXRpb24gPSAnYWJzb2x1dGUnXG4gICAgICAgICAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGVsZW0pXG4gICAgICAgICAgfSBlbHNlIGlmKGlmcmFtZXNbaWZyYW1lXS5jTGlzdGVuZXJzKSB7XG4gICAgICAgICAgICBpZnJhbWVzW2lmcmFtZV0uY0xpc3RlbmVycy5wdXNoKHNldG1zZylcbiAgICAgICAgICAgIC8vZWxlbS5jTGlzdGVuZXJzW2ldXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHNldG1zZygpXG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChkYXRhKSB7XG5cbiAgICAgICAgICBpZiAobWV0aG9kID09PSAnR0VUJykge1xuICAgICAgICAgICAgdXJsICs9ICc/JyArIGVuQ29kZShkYXRhLCAnR0VUJywgZW5jb2RlKVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXFkYXRhID0gZW5Db2RlKGRhdGEsICdQT1NUJywgZW5jb2RlKVxuICAvLyAgICAgICAgICAgY29uc29sZS5sb2coIHJlcWRhdGEgKVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSBNRVRIT0QsIFVSTCwgQVNZTkMsIFVTRVIgJiBQQVNTXG4gICAgICAgIHhoci5vcGVuKG1ldGhvZCwgdXJsLCBhc3luYywgdXNlciwgcGFzcylcbiAgICAgICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIEhFQURFUlNcbiAgICAgICAgeGhyLnNldFJlcXVlc3RIZWFkZXIoJ0NvbnRlbnQtVHlwZScsIGNvbnRlbnRUeXBlKVxuICAgICAgICBpZiAoaGVhZGVycykge1xuICAgICAgICAgIGZvciAodmFyIGYgaW4gaGVhZGVycykge1xuICAgICAgICAgICAgeGhyLnNldFJlcXVlc3RIZWFkZXIoZiwgaGVhZGVyc1tmXSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIEVWRU5UU1xuICAgICAgICBpZiAoc3VjY2Vzcykge1xuICAgICAgICAgIHhocltfYV0oXCJsb2FkXCIsIGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgIHZhciByZXNwID0gKGUudGFyZ2V0IHx8IGUuc3JjRWxlbWVudCkucmVzcG9uc2U7XG4gICAgICAgICAgICBpZiAocGFyc2UgIT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcmVzcCA9IEpTT04ucGFyc2UocmVzcClcbiAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge31cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChwYXJhbXMubSkge1xuICAgICAgICAgICAgICBwYXJhbXMuZFt1cmxzZXRdID0gcmVzcFxuICAgICAgICAgICAgICBwYXJhbXMubSgpXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBzdWNjZXNzKHJlc3AsIGUpXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSwgZmFsc2UpXG4gICAgICAgIH1cbiAgICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgICAgaWYoIWZhbGxiYWNrSW5kZXgpIHBhcmFtcy5fZmFsbGJhY2tJbmRleCA9IDBcbiAgICAgICAgICBpZihmYWxsYmFjayAmJiBmYWxsYmFja0luZGV4IT09ZmFsbGJhY2subGVuZ3RoKSB7XG4gICAgICAgICAgICBwYXJhbXMuX2ZhbGxiYWNrSW5kZXgrK1xuICAgICAgICAgICAgcGFyYW1zID0gdXRpbC5tZXJnZShwYXJhbXMsZmFsbGJhY2tJbmRleClcbiAgICAgICAgICAgIGFqYXgocGFyYW1zLCB1cmxzZXQpXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHhocltfYV0oXCJlcnJvclwiLCBlcnJvciwgZmFsc2UpXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChwcm9ncmVzcykge1xuICAgICAgICAgIHhocltfYV0oXCJwcm9ncmVzc1wiLCBwcm9ncmVzcywgZmFsc2UpXG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNoYW5nZSkge1xuICAgICAgICAgIHhoci5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBjaGFuZ2VcbiAgICAgICAgfVxuICAgICAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gTUlNRVxuICAgICAgICBpZiAobWltZSkge1xuICAgICAgICAgIHhoci5vdmVycmlkZU1pbWVUeXBlKG1pbWUpXG4gICAgICAgIH1cbiAgICAgICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIFNFTkRcblxuICAgICAgICB4aHIuc2VuZChyZXFkYXRhKVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG52YXIganNvbnBTdGFtcCA9IDBcblxuYWpheC5qc29ucCA9IGZ1bmN0aW9uKCB1cmwsIHN1Y2Nlc3MsIGVycm9yLCBjb250ZXh0LCBjYk5hbWUgKSB7XG5cbiAgaWYoICFjYk5hbWUgfHwgY2JOYW1lID09PSB0cnVlICkgY2JOYW1lID0gJ2NhbGxiYWNrJ1xuXG4gIHZhciBuYW1lID0gJ19qc29ucF8nICsganNvbnBTdGFtcCsrXG4gICAgLCBzY3JpcHQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzY3JpcHQnKVxuICBcbiAgaWYgKHVybC5tYXRjaCgvXFw/LykpIFxuICB7IFxuICAgIHVybCArPSAnJicrY2JOYW1lKyc9JytuYW1lXG4gIH1cbiAgZWxzZSBcbiAge1xuICAgIHVybCArPSAnPycrY2JOYW1lKyc9JytuYW1lXG4gIH1cbiAgXG4gIHNjcmlwdC50eXBlID0gJ3RleHQvamF2YXNjcmlwdCdcbiAgc2NyaXB0LnNyYyA9IHVybFxuICBcbiAgaWYoZXJyb3IpIHtcbiAgICBzY3JpcHQub25lcnJvciA9IGZ1bmN0aW9uKCBlICkge1xuICAgICAgZXJyb3IoIGUgKVxuICAgIH1cbiAgfVxuXG4gIHdpbmRvd1tuYW1lXSA9IGZ1bmN0aW9uKGRhdGEpe1xuICAgIHN1Y2Nlc3MuY2FsbCgoIGNvbnRleHQgfHwgd2luZG93ICksIGRhdGEpXG4gICAgZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ2hlYWQnKVswXS5yZW1vdmVDaGlsZChzY3JpcHQpXG4gICAgc2NyaXB0ID0gbnVsbFxuICAgIGRlbGV0ZSB3aW5kb3dbbmFtZV1cbiAgfVxuICBcbiAgZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ2hlYWQnKVswXS5hcHBlbmRDaGlsZChzY3JpcHQpXG5cbn1cblxudmFyIGVuQ29kZSA9IGFqYXguZW5jb2RlID0gZnVuY3Rpb24oZGF0YSwgbWV0aG9kLCBlbmNvZGUpIHtcbiAgdmFyIHJlc3VsdCA9ICcnXG5cbiAgaWYoZW5jb2RlID09PSAnanNvbicpe1xuICAgIHJlc3VsdCA9IEpTT04uc3RyaW5naWZ5KGRhdGEpXG4gIH0gZWxzZSBpZihkYXRhIGluc3RhbmNlb2YgT2JqZWN0KSB7XG4gICAgaWYgKCF1dGlsLmlzTm9kZSAmJiAod2luZG93LkZvcm1EYXRhICYmIGRhdGEgaW5zdGFuY2VvZiBGb3JtRGF0YSkgJiYgbWV0aG9kICE9PSAnR0VUJykge1xuICAgICAgcmVzdWx0ID0gZGF0YVxuICAgIH0gZWxzZSBpZiAoZGF0YSBpbnN0YW5jZW9mIEFycmF5KSB7XG4gICAgICByZXN1bHQgPSBKU09OLnN0cmluZ2lmeShkYXRhW2ZdKVxuICAgICAgaWYoZW5jb2RlID09PSAndXJpJykgcmVzdWx0ID0gZW5jb2RlVVJJQ29tcG9uZW50KHJlc3VsdClcbiAgICB9IGVsc2Uge1xuICAgICAgZm9yICh2YXIgZiBpbiBkYXRhKSB7XG4gICAgICAgIHZhciB2YWwgPSBkYXRhW2ZdXG4gICAgICAgIGlmKHZhbCBpbnN0YW5jZW9mIE9iamVjdCkgdmFsID0gSlNPTi5zdHJpbmdpZnkodmFsKVxuICAgICAgICBpZihlbmNvZGUgPT09ICd1cmknKXtcbiAgICAgICAgICBmID0gZW5jb2RlVVJJQ29tcG9uZW50KGYpXG4gICAgICAgICAgdmFsID0gZW5jb2RlVVJJQ29tcG9uZW50KHZhbClcbiAgICAgICAgfVxuICAgICAgICByZXN1bHQgKz0gZiArICc9JyArIHZhbCArICcmJ1xuICAgICAgfVxuICAgICAgcmVzdWx0ID0gcmVzdWx0LnNsaWNlKDAsIC0xKVxuXG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHJlc3VsdCA9IChlbmNvZGUgPT09ICd1cmknKSA/IGVuY29kZVVSSUNvbXBvbmVudChkYXRhKSA6IGRhdGFcbiAgfVxuICAvLyBjb25zb2xlLmxvZygnZW5jb2RlZDonLCByZXN1bHQpXG4gIHJldHVybiByZXN1bHRcbn0iLCIvKlxuICogQGxpY2Vuc2UgQ29weXJpZ2h0IChjKSAyMDEyLTIwMTQsIFZpZ291ci4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIEBhdXRob3I6IEppbSBkZSBCZWVyLCBqaW1Admlnb3VyLmlvXG4gKi9cbi8qXG4vKlxuICB1c2VyYWdlbnQgc25pZmZpbmcgaXMgbmV2ZXIgdXNlZCBmb3IgZmVhdHVyZSBkZXRlY3Rpb24sIGZvciBhIG11bHRpLXNjcmVlbiBhcHAgeW91IGRvIG5lZWQgaW5mb3JtYXRpb24gYWJvdXQgdGhlIGRldmljZSBhbHNvIHdoZW4gcnVubmluZyBpbiB0aGUgYnJvd3NlclxuICBoYXMgZmllbGRzIFYudWEucGxhdGZvcm0sIGRldmljZSwgYnJvd3NlciBhbmQgdmVyc2lvbi4gVGhpcyBpbXBsZW1lbnRhdGlvbiB3aGVuIGNvbXBpbGVkLCBpcyBvbmx5IDcwMCBieXRlc1xuKi9cbnZhciB1dGlsID0gcmVxdWlyZSgnLi4vdXRpbCcpXG4vKipcbiAqIHRlc3RcbiAqIHNlYXJjaCBmb3IgcmVnZXhwcyBpbiB0aGUgdXNlckFnZW50XG4gKiBmbiBpcyBhIG9uIHN1Y2NlcyBjYWxsYmFja1xuICogY2hlY2sgaHR0cDovL3d3dy51c2VyYWdlbnRzdHJpbmcuY29tLyB0byB0ZXN0IGZvciB1c2VyQWdlbnRzXG4gKiBAbWV0aG9kXG4gKi9cbiwgdGVzdCA9IGV4cG9ydHMudGVzdCA9IGZ1bmN0aW9uKCBfdWEsIGZuICkge1xuXG4gIGZvclxuICAoIHZhciB0ZXN0cyA9IHV0aWwuYXJnKCBhcmd1bWVudHMsIDEgKVxuICAgICAgLCBpID0gdGVzdHMubGVuZ3RoIC0gMVxuICAgICAgLCBxdWVyeSA9IHRlc3RzW2ldWzBdXG4gICAgOyBxdWVyeSAhPT0gdHJ1ZSAmJiAhbmV3IFJlZ0V4cCggcXVlcnkgKS50ZXN0KCBfdWEgKVxuICAgIDsgcXVlcnkgPSB0ZXN0c1stLWldWzBdXG4gIClcblxuICA7aWYoIGZuLnNsaWNlIHx8IGZuLmNhbGwoIHRoaXMsIHF1ZXJ5LCB0ZXN0c1tpXSApIClcbiAge1xuICAgIHRoaXNbZm5dID0gdGVzdHNbaV1bMV1cbiAgfVxuXG59XG4sIHBhcnNlID0gZXhwb3J0cy5wYXJzZSA9IGZ1bmN0aW9uKF91YSwgb2JqKSB7XG5cbiAgaWYoICFfdWEgKVxuICB7XG4gICAgb2JqID0gZXhwb3J0c1xuICAgIF91YSA9IHR5cGVvZiBuYXZpZ2F0b3IgIT09ICd1bmRlZmluZWQnXG4gICAgICAgID8gbmF2aWdhdG9yLnVzZXJBZ2VudC50b0xvd2VyQ2FzZSgpXG4gICAgICAgIDogJ25vIG5hdmlnYXRvcidcbiAgfVxuXG4gIF91YSA9IF91YS50b0xvd2VyQ2FzZSgpXG5cbiAgaWYoICFvYmogKSBvYmogPSB7fVxuXG4gIC8vIF91YSA9ICd3ZWJvczsgbGludXggLSBsYXJnZSBzY3JlZW4nXG5cbiAgdmFyIF9mZiA9ICdmaXJlZm94J1xuICAgICwgX2FuZHJvaWQgPSAnYW5kcm9pZCdcbiAgICAsIF9tb2JpbGUgPSAnLittb2JpbGUnXG4gICAgLCBfd2Via2l0ID0gJ3dlYmtpdCdcbiAgICAsIF9wcyA9ICdwbGF5c3RhdGlvbidcbiAgICAsIF94Ym94ID0gJ3hib3gnXG4gICAgLCBfbGludXggPSAnbGludXgnXG4gICAgLCBfY2FzdERldGVjdCA9ICdjcmtleSdcbiAgICAsIF9jaHJvbWVjYXN0ID0gJ2Nocm9tZWNhc3QnXG4gICAgLCBfdGFibGV0ID0gJ3RhYmxldCdcbiAgICAsIF93aW5kb3dzID0gJ3dpbmRvd3MnXG4gICAgLCBfcGhvbmUgPSAncGhvbmUnXG4gICAgLCBfaXBob25lVmVyc2lvblxuXG4gIHRlc3QuY2FsbFxuICAoIG9ialxuICAsIF91YVxuICAsIGZ1bmN0aW9uKCBxdWVyeSwgYXJyICkge1xuXG4gICAgICBvYmouYnJvd3NlciA9IGFyclsyXSB8fCBxdWVyeVxuXG4gICAgICB2YXIgX3YgPSBfdWEubWF0Y2hcbiAgICAgICggbmV3IFJlZ0V4cFxuICAgICAgICAoICcoKChbXFxcXC8gXXZlcnNpb258J1xuICAgICAgICArIGFyclswXVxuICAgICAgICArICcoPyEuK3ZlcnNpb24pKVtcXC8gXSl8IHJ2OikoWzAtOV17MSw0fVxcXFwuWzAtOV17MCwyfSknXG4gICAgICAgIClcbiAgICAgIClcblxuICAgICAgb2JqLnZlcnNpb24gPSBfdiA/IE51bWJlciggX3ZbNF0gKSA6IDBcbiAgICAgIG9iai5wcmVmaXggPSBhcnJbMV1cbiAgICAgIC8vVE9ETzogYWRkIHByZWZpeCBmb3Igb3BlcmEgdj4xMi4xNTtcbiAgICAgIC8vVE9ETzogd2luZG93cyBjaGVjayBmb3IgaWUgMTEgbWF5IGJlIHRvbyBnZW5lcmFsO1xuICAgIH1cbiAgLCBbIHRydWUsIF93ZWJraXQgXVxuICAsIFsgJ1xcXFwod2luZG93cycsICdtcycsICdpZScgXVxuICAsIFsgJ3NhZmFyaScsIF93ZWJraXQgXVxuICAsIFsgX2ZmLCAnTW96JyBdXG4gICwgWyAnb3BlcmEnLCAnTycgXVxuICAsIFsgJ21zaWUnLCAnbXMnLCAnaWUnIF1cbiAgLCBbICdjaHJvbWV8Y3Jpb3NcXC8nLCBfd2Via2l0LCAnY2hyb21lJyBdXG4gIClcblxuICAvKipcbiAgKiBwbGF0Zm9ybSBkZXRlY3Rpb25cbiAgKi9cbiAgdGVzdC5jYWxsXG4gICggb2JqXG4gICwgX3VhXG4gICwgJ3BsYXRmb3JtJ1xuICAsIFsgdHJ1ZSwgX3dpbmRvd3MgXVxuICAsIFsgX2xpbnV4LCBfbGludXggXVxuICAsIFsgJ2xnLnswLDN9bmV0Y2FzdCcsICdsZycgXSAvL1RPRE86cHJvcGFibHkgbmVlZCB0byBhZGQgbW9yZSFcbiAgLCBbIF9mZiArIF9tb2JpbGUsIF9mZiBdXG4gICwgWyAnbWFjIG9zIHgnLCAnbWFjJyBdXG4gICwgWyAnaXBob25lfGlwb2R8aXBhZCcsICdpb3MnIF1cbiAgLCBbIF94Ym94LCBfeGJveCBdXG4gICwgWyBfcHMsIF9wcyBdXG4gICwgWyBfYW5kcm9pZCwgX2FuZHJvaWQgXVxuICAsIFsgX3dpbmRvd3MsIF93aW5kb3dzIF1cbiAgLCBbIF9jYXN0RGV0ZWN0LCBfY2hyb21lY2FzdCBdXG4gICwgWyAnc21hcnQtdHY7fDtzYW1zdW5nO3NtYXJ0dHYnLCAnc2Ftc3VuZycgXSAvL1NtYXJ0VFYyMDEzXG4gIClcblxuICAvKipcbiAgKiBkZXZpY2UgZGV0ZWN0aW9uXG4gICovXG4gIHRlc3QuY2FsbFxuICAoIG9ialxuICAsIF91YVxuICAsICdkZXZpY2UnXG4gICwgWyB0cnVlLCAnZGVza3RvcCcgXVxuICAsIFsgX3dpbmRvd3MgKyAnLit0b3VjaHxpcGFkfCcgKyBfYW5kcm9pZCwgIF90YWJsZXQgXVxuICAsIFsgJ2lwaG9uZXwoJyArIF9hbmRyb2lkICsgX21vYmlsZSArICcpfCgnICsgX2ZmICsgX21vYmlsZSArICcpfCcgKyBfd2luZG93cyArICcgcGhvbmV8aWVtb2JpbGUnXG4gICAgLCBfcGhvbmVcbiAgICBdXG4gICwgWyBfeGJveCArICd8JyArIF9wcywgJ2NvbnNvbGUnIF1cbiAgLCBbICd0dnxzbWFydHR2fGdvb2dsZXR2fGFwcGxldHZ8aGJidHZ8cG92X3R2fG5ldGNhc3QudHZ8d2Vib3MuK2xhcmdlJywgJ3R2JyBdXG4gICwgWyBfY2FzdERldGVjdCwgX2Nocm9tZWNhc3QgXVxuICAsIFsgJ2FtYXpvbi1maXJlb3MnLCBfdGFibGV0IF1cbiAgKVxuXG4gIC8vVE9ETzogYW1hem9uIGZpcmV0diBhbmQgcGhvbmVcbiAgICAvLyBhbGVydCh3aW5kb3cuaW5uZXJXaWR0aCp3aW5kb3cuaW5uZXJIZWlnaHQgKyAgJyAgJysgNDE0ICogNzM2KVxuICBcbiAgLy80MTQgw5cgNzM2XG4gIHZhciBpcGhvbmU2cGx1cyA9IDQxNCAqIDczNlxuICBpZlxuICAoIG9iai5wbGF0Zm9ybSA9PT0gX2FuZHJvaWRcbiAgICAmJiAhdXRpbC5pc05vZGVcbiAgICAmJiBvYmouZGV2aWNlID09PSBfcGhvbmVcbiAgICAmJiB3aW5kb3dcbiAgICAmJiB3aW5kb3cuaW5uZXJXaWR0aCAqIHdpbmRvdy5pbm5lckhlaWdodCA+IGlwaG9uZTZwbHVzXG4gICAgLy8gJiYgfl91YS5pbmRleE9mKCdjcm9zc3dhbGsnKVxuICApXG4gIHtcbiAgICBvYmouZGV2aWNlID0gJ3RhYmxldCdcbiAgfVxuXG4gIHJldHVybiBvYmpcbn1cblxuaWYoICF1dGlsLmlzTm9kZSApIFxueyBcbiAgcGFyc2UoKVxuICAvL1RPRE86IHRoaXMgaXMgdmVyeSB1Z2x5LCB0cnkgdG8gZmluZCBhIGJldHRlciBzb2x1dGlvblxuICBpZiggd2luZG93ICYmIHdpbmRvdy5fX3VhX18gKSBcbiAge1xuICAgIGZvciggdmFyIGZpZWxkIGluIHdpbmRvdy5fX3VhX18gKVxuICAgIHtcbiAgICAgIGV4cG9ydHNbZmllbGRdID0gd2luZG93Ll9fdWFfX1tmaWVsZF1cbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBwcm9wXG4gKiByZS13cml0ZXMganMgcHJvcGVydGllcyB0byB0aGVpciBjc3MgY291bnRlcnBhcnRcbiAqIGUuZy4gd2Via2l0VHJhbnNmb3JtIC0tPiAtd2Via2l0LXRyYW5zZm9ybVxuICogbm93IGl0cyBjb21tZW50ZWQgc2luY2UgaXRzIG5vdCBuZXNzZWNhcnkgeWV0XG4gKiBAbWV0aG9kXG4gKi9cbi8vIHRoaXMucHJvcCA9IGZ1bmN0aW9uKHN0cikge1xuLy8gIHJldHVybiBzdHIucmVwbGFjZSh0aGlzLnByZWZpeCwnLScrdGhpcy5wcmVmaXgrJy0nKS50b0xvd2VyQ2FzZSgpO1xuLy8gfVxuIiwiLyohXG4gKiBAbGljZW5zZSBDb3B5cmlnaHQgKGMpIDIwMTItMjAxNCwgVmlnb3VyLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogQGF1dGhvcjogSmltIGRlIEJlZXIsIGppbUB2aWdvdXIuaW9cbiAqL1xudmFyICBkYXRhID0gcmVxdWlyZSgnLi8nKVxuICAsIGJhc2UgPSByZXF1aXJlKCcuLi9iYXNlJylcbiAgLCB1dGlsID0gcmVxdWlyZSgnLi4vdXRpbCcpXG4gICwgZmxhZ3MgPSByZXF1aXJlKCcuLi92YWx1ZS9mbGFncy9kYXRhJylcbiAgLCB2T2JqZWN0ID0gcmVxdWlyZSgnLi4vb2JqZWN0JylcblxuZXhwb3J0cy5leHRlbmQgPSB1dGlsLmV4dGVuZCggZnVuY3Rpb24oYmFzZSwgZXh0ZW5zaW9ucywgbW9kZWxibGFja2xpc3QpIHtcblxuICAgIHZhciByZW1vdmVNZXRob2QgPSBmdW5jdGlvbiggcmVzZXQsIGZpZWxkQ29ycmVjdGVkICkge1xuXG4gICAgICAvLyBpZiggcmVzZXQgKVxuICAgICAgLy8ge1xuICAgICAgLy8gICAvLyBjb25zb2xlLmxvZygnUkVTRVQgUkVNT1ZFIScuaW52ZXJzZSwgdGhpcy5fX2NoZWNrS2V5c19fLCB0aGlzIClcbiAgICAgIC8vICAgLy8gZGVidWdnZXJcbiAgICAgIC8vIH1cbiAgICAgIC8vIGVsc2Uge1xuICAgICAgLy8gICAvLyBjb25zb2xlLmxvZyggdGhpcy5fX2NoZWNrS2V5c19fLCB0aGlzLl9kIClcbiAgICAgIC8vIH1cblxuICAgICAgLy8gaWYodGhpcy5fZCAmJiB0aGlzLl9kLl9saXN0ZW5lcnMpIHtcbiAgICAgIC8vICAgY29uc29sZS5sb2coICdTVEFSVCBSRU1PVklORyBMSVNURU5FUlMnLmJsdWUuaW52ZXJzZSwgREVCVUckLmNvdW50TGlzdGVuZXJzKHRoaXMuX2QpIClcbiAgICAgIC8vIH1cblxuICAgICAgdmFyIGV4Y2x1ZGVzIFxuICAgICAgLy9pZiB0eXBlID09PSAnJHJlc2V0J1xuXG4gICAgICBpZiggdGhpcy5fZCApXG4gICAgICB7XG4gICAgICAgIC8vIGNvbnNvbGUubG9nKCcyIFJFTU9WRSEnLmludmVyc2UpXG5cbiAgICAgICAgaWYgKCB0aGlzLl9kLl9fdCApICBcbiAgICAgICAge1xuICAgICAgICAgIC8vIGNvbnNvbGUubG9nKCdyZW1vdmVMaXN0ZW5lciBGUk9NIG15c2VsZicsIHJlc2V0ID09PSB0aGlzLl9kICwgdGhpcy5fZCwgcmVzZXQpXG5cblxuICAgICAgICAgIC8vIGNvbnNvbGUubG9nKCdSRU1PVkUhJy5yZWQuaW52ZXJzZSwgdGhpcy5fZC5fbGlzdGVuZXJzLmxlbmd0aClcbiAgICAgICAgICB0aGlzLl9kLnJlbW92ZUxpc3RlbmVyKCB2b2lkIDAsIHRoaXMgKVxuICAgICAgICAgIC8vIGNvbnNvbGUubG9nKCdSRU1PVkUhJywgdGhpcy5fZC5fbGlzdGVuZXJzLmxlbmd0aClcblxuICAgICAgICAgIGlmKCAhdGhpcy5fZC5jbG91ZCApXG4gICAgICAgICAge1xuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpc1xuICAgICAgICAgICAgdGhpcy5fZC5lYWNoKFxuICAgICAgICAgICAgICBmdW5jdGlvbigga2V5ICkgeyBcbiAgICAgICAgICAgICAgICAvLyBfdGhpcy5fX2NoZWNrS2V5c19fID0gdHJ1ZVxuICAgICAgICAgICAgICAgIGlmKCByZXNldCAmJiByZXNldFtrZXldICE9PSB0aGlzICkgXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgLy8gY29uc29sZS5sb2coJ3JlbW92ZUxpc3RlbmVyIC0tLScpXG4gICAgICAgICAgICAgICAgICBpZih0aGlzLl9fdCA9PT0gNCApIHRoaXMucmVtb3ZlTGlzdGVuZXIoIHZvaWQgMCwgX3RoaXMgKSBcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiggcmVzZXQgKVxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgIGlmKCAhZXhjbHVkZXMgKSBleGNsdWRlcyA9IFtdXG4gICAgICAgICAgICAgICAgICBleGNsdWRlcy5wdXNoKCBrZXkgKVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgKVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHRoaXMuX19jaGVja0tleXNfXyA9IG51bGwvL1RPRE86IG9ubHkgcmVtb3ZlIGxpc3RlbmVycyBpZiBjaGVja2tleXMgPT09IHRydWVcblxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYoIHRoaXMuX19jaGVja0tleXNfXyApIFxuICAgICAgICB7XG4gICAgICAgICAgLy8gY29uc29sZS5sb2coJzIyMjIyIFJFTU9WRSEnLmludmVyc2UpXG5cbiAgICAgICAgICBmb3IoIHZhciBrZXkkIGluIHRoaXMuX19jaGVja0tleXNfXyApIFxuICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKCdyZW1vdmVMaXN0ZW5lciAtLS0gMicpXG5cbiAgICAgICAgICAgIGlmKCB0aGlzLl9kW3RoaXMuX19jaGVja0tleXNfX1trZXkkXV0gaW5zdGFuY2VvZiB2T2JqZWN0IClcbiAgICAgICAgICAgIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBjb25zb2xlLmxvZygncmVtb3ZlTGlzdGVuZXIgLS0tIDIyJylcblxuXG4gICAgICAgICAgICAgICBpZiggKCByZXNldCAmJiByZXNldFsgdGhpcy5fX2NoZWNrS2V5c19fW2tleSRdIF0gKSAhPT0gdGhpcy5fZFsgdGhpcy5fX2NoZWNrS2V5c19fW2tleSRdIF0gKSBcbiAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKCdyZW1vdmVMaXN0ZW5lciAtLS0nKVxuICAgICAgICAgICAgICAgICAgdGhpcy5fZFt0aGlzLl9fY2hlY2tLZXlzX19ba2V5JF1dLnJlbW92ZUxpc3RlbmVyKCB2b2lkIDAsIHRoaXMgKVxuICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgZWxzZSBpZiggcmVzZXQgKVxuICAgICAgICAgICAgICAge1xuXG4gICAgICAgICAgICAgICAgICBpZiggIWV4Y2x1ZGVzICkgZXhjbHVkZXMgPSBbXVxuICAgICAgICAgICAgICAgICAgLy8gY29uc29sZS5sb2coJ0VYQ0xVREUgUkVTRVQgUkVNT1ZFIScuaW52ZXJzZSwgdGhpcy5fX2NoZWNrS2V5c19fW2tleSRdIClcbiAgICAgICAgICAgICAgICAgIGV4Y2x1ZGVzLnB1c2goIHRoaXMuX19jaGVja0tleXNfX1trZXkkXSApXG5cbiAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdGhpcy5fX2NoZWNrS2V5c19fID0gbnVsbFxuXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gaWYodGhpcy5fZCAmJiB0aGlzLl9kLl9saXN0ZW5lcnMpIHtcbiAgICAgIC8vICAgY29uc29sZS5sb2coICdET05FIFJFTU9WSU5HIExJU1RFTkVSUycuYmx1ZS5pbnZlcnNlLCBERUJVRyQuY291bnRMaXN0ZW5lcnModGhpcy5fZCkgKVxuICAgICAgLy8gfVxuXG4gICAgICAvL3RoaW5ncyB0aGF0IGFyZSBleGNsdWRlZFxuICAgICAgcmV0dXJuIGV4Y2x1ZGVzXG5cbiAgICB9XG5cbiAgLy8gdmFyIF9ibGFja2xpc3QgPSB1dGlsLmFkZChbJ2ZsYWdzJywgJ3JlZicsICdwYXJzZScsICdwYXJzaW5nJ10sIG1vZGVsYmxhY2tsaXN0KSxcbiAgICB2YXIgX2NvbXBhcmUgPSB1dGlsLmNvbXBhcmVBcnJheXMsXG4gICAgbWV0aG9kcyA9IHtcbiAgICAgIF9kVXBkYXRlOiBmdW5jdGlvbihvYmosIHZhbCwgc3RhbXAsIGZyb20sIHJlbW92ZSwgYWRkZWQsIG9sZHZhbCwgaW5zdGFuY2VzLCBhcmd4MSwgYXJneDIgKSB7XG4gICAgICAgIC8vIGlmKHdpbmRvdy5oZXJlKSBjb25zb2xlLmxvZygnWCcsc3RhbXApXG4gICAgICAgIGlmICh0aGlzLm1vZGVsKSB7XG5cbiAgICAgICAgICAvLyRuZGF0YVxuXG4gICAgICAgICAgLy9UT0RPOiB2ZXJ5IGRpcnR5IGZpeCBnZXQgcmlkIG9mIHRoaXMhXG4gICAgICAgICAgaWYoIG9iaiA9PT0gJyRuZGF0YScgKXtcbiAgICAgICAgICAgIHZhbCA9IGZyb21cbiAgICAgICAgICAgIHN0YW1wID0gcmVtb3ZlXG4gICAgICAgICAgICBmcm9tID0gYWRkZWRcbiAgICAgICAgICAgIHJlbW92ZSA9IG9sZHZhbFxuICAgICAgICAgICAgYWRkZWQgPSBpbnN0YW5jZXNcbiAgICAgICAgICAgIG9sZHZhbCA9IGFyZ3gxXG4gICAgICAgICAgICBpbnN0YW5jZXMgPSBhcmd4MlxuICAgICAgICAgICAgLy8gY29uc29sZS5sb2coJyFAIyFAIyFAIyFAI0AhIyFAIyFAIyFAIycucmVkLmludmVyc2UpXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gdmFyIG5vbiA9IDBcbiAgICAgICAgICAvLyAgICwgY250ID0gMFxuICAgICAgICAgIC8vIGZvciggdmFyIGkgaW4gYXJndW1lbnRzICkgXG4gICAgICAgICAgLy8ge1xuICAgICAgICAgIC8vICAgY250KytcbiAgICAgICAgICAvLyAgIGlmKCFhcmd1bWVudHNbaV0pIHtcbiAgICAgICAgICAvLyAgICAgbm9uKytcbiAgICAgICAgICAvLyAgIH1cbiAgICAgICAgICAvLyAgIGNvbnNvbGUubG9nKCBhcmd1bWVudHNbaV0gKVxuICAgICAgICAgIC8vIH1cbiAgICAgICAgICAvLyBpZihub24gPT09IGNudCkge1xuICAgICAgICAgIC8vICAgYWxlcnQoJ25vIGFyZ3MnKVxuICAgICAgICAgIC8vICAgcmV0dXJuIHRydWVcbiAgICAgICAgICAvLyB9XG5cbiAgICAgICAgICBpZiAoIXRoaXMuX2QgJiYgdGhpcy5wYXJlbnQpIHtcbiAgICAgICAgICAgIHZhciBwID0gdGhpcy5wYXJlbnQ7XG4gICAgICAgICAgICB3aGlsZSAoIXRoaXMuX2QgJiYgcCkge1xuICAgICAgICAgICAgICBpZiAocC5fZCkge1xuICAgICAgICAgICAgICAgIC8vIGNvbnNvbGUuZXJyb3IoJ1NFVCBEQVRBJylcbiAgICAgICAgICAgICAgICB0aGlzLl9kU2V0KHAuX2QsIHRydWUpO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHAgPSBwLnBhcmVudDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgdCA9IHRoaXMsXG4gICAgICAgICAgICBtb2RlbCA9IHQubW9kZWwsXG4gICAgICAgICAgICBmID0gbW9kZWwuZmxhZ3MsXG5cbiAgICAgICAgICAgIC8vIGYgPSBtb2RlbCA/IG1vZGVsLmZsYWdzIDogZmFsc2UgYmUgY2FyZWZ1bGwgd2l0aCB1cGRhdGVzIGluIHZhbHVlcyB0aGF0IGhhdmUgZGF0YVxuXG4gICAgICAgICAgICBwYXRoID0gdC5fZCAmJiB0Ll9kLl9wYXRoIHx8IFtdLFxuICAgICAgICAgICAgbmFtZSA9IChmcm9tIHx8IChmcm9tID0gKHQuX2QgJiYgdC5fZC5fdXBkYXRlT3JpZ2luKSkgJiYgIShmcm9tID09PSB0Ll9kICYmIChmcm9tID0gZmFsc2UpKSkgJiYgZnJvbS51cGRhdGVQYXRoLFxuICAgICAgICAgICAgZnJvbVBhdGggPSBmcm9tICYmIGZyb20uX3BhdGgsXG4gICAgICAgICAgICBtZXRob2QgPSBmdW5jdGlvbihpLCBmaWVsZCkge1xuXG4gICAgICAgICAgICAgIHZhciBzZWxlY3QsIHBhc3MsIGZyLCBsZmllbGQ7XG4gICAgICAgICAgICAgIC8vIGlmKCBmaWVsZC5fZmxhZ1syXS5fX3QpIHtcbiAgICAgICAgICAgICAgLy9tdWx0aXBsZSBmbGFncyFcbiAgICAgICAgICAgICAgICAvLyBjb25zb2xlLmxvZygnRkxBRycuaW52ZXJzZSwgbmFtZSwgZmllbGQuX2ZsYWcpXG4gICAgICAgICAgICAgIC8vIH1cblxuICAgICAgICAgICAgICBpZighZmllbGQuX2ZsYWcuZGF0YSkge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ05PIERBVEEgRkxBRycsIG5hbWUsIGZpZWxkLl9mbGFnLCB2YWwsIG9iaiwgcmVtb3ZlLCBhZGRlZCwgb2xkdmFsKVxuICAgICAgICAgICAgICAgIHJldHVyblxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGZpZWxkID0gZmllbGQuX2ZsYWcuZGF0YVsyXTtcblxuICAgICAgICAgICAgICAgLy8gY29uc29sZS5sb2coJ0RBVEEgVVBEQVRFJy5tYWdlbnRhLmludmVyc2UsXG4gICAgICAgICAgICAgICAvLyAgICAgICdvYmo6Jywgb2JqXG4gICAgICAgICAgICAgICAvLyAgICAsICd2YWw6JywgdmFsXG4gICAgICAgICAgICAgICAvLyAgICAsICdzdGFtcDonLCBzdGFtcFxuICAgICAgICAgICAgICAgLy8gICAgLCAnZnJvbTonLCBmcm9tXG4gICAgICAgICAgICAgICAvLyAgICAsICdyZW1vdmU6JywgcmVtb3ZlXG4gICAgICAgICAgICAgICAvLyAgICAsICdhZGRlZDonLCBhZGRlZFxuICAgICAgICAgICAgICAgLy8gICAgLCAnZmllbGQ6JywgZmllbGRcbiAgICAgICAgICAgICAgIC8vICApXG4gICAgICAgICAgICAgIC8vIHZhciB0ZXN0ID0gKGk9PT0ndGV4dCcgJiYgZmllbGQgPT09ICdyZWFsLmR1cmF0aW9uJylcbiAgICAgICAgICAgICAgLy8gaWYodGVzdCkgY29uc29sZS5sb2coZmllbGQsaSlcbiAgICAgICAgICAgICAgLy8gaWYodGVzdCkgcGFzcyA9IHRydWVcblxuICAgICAgICAgICAgICBpZiAoaSA9PT0gJ2NvbGxlY3Rpb24nICYmIHQuX2NvbEZpbHRlcikgcmV0dXJuXG4gICAgICAgICAgICAgIC8vaWYgbm90IG93biBjb2xmaWx0ZXIgLS0+IGhhbmRsZSB5b3Vyc2VsZiE7XG4gICAgICAgICAgICAgIC8vIGlmIGRhdGEgaGFzIGNoYW5nZWQgY2hhbmdlIGNvbGZpbHRlciBhZG4gc2VuZCB1cGRhdGVcbiAgICAgICAgICAgICAgLy9iZSBjYXJlZnVsbCAvdyBjaGFuZ2VzITsgdG9vIGNydWRlXG5cbiAgICAgICAgICAgICAgaWYgKGZpZWxkID09PSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgLy8gY29uc29sZS5sb2coJ1BBU1MnLmludmVyc2UsbmFtZSlcbiAgICAgICAgICAgICAgICBwYXNzID0gdHJ1ZTtcbiAgICAgICAgICAgICAgfSBlbHNlIGlmIChmaWVsZC5wb3ApIHtcbiAgICAgICAgICAgICAgICAvLyBjb25zb2xlLmxvZyhuYW1lLCc/Pz8nKVxuXG4gICAgICAgICAgICAgICAgLy8gY29uc29sZS5sb2coJy0tLT4nLGZpZWxkLCBmaWVsZC5wb3ApXG5cbiAgICAgICAgICAgICAgICBmaWVsZCA9IGZpZWxkLmNvbmNhdCgpO1xuXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaiA9IGZpZWxkLmxlbmd0aCAtIDE7IGogPj0gMDsgai0tKSB7XG4gICAgICAgICAgICAgICAgICBpZiAoIWxmaWVsZCAhPT0gdm9pZCAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHNlbGVjdCA9IHV0aWwuZ2V0KHQuX2QsIGZpZWxkW2pdKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNlbGVjdCAhPT0gdm9pZCAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgbGZpZWxkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAvLyBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgZmllbGRbal0gPSBmaWVsZFtqXS5zcGxpdCgnLicpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSBlbHNlIHtcblxuICAgICAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKCdETyBETyEnLmludmVyc2UsbmFtZSwgdC5fZCAmJiB0Ll9kLl91cGRhdGVPcmlnaW4pXG5cbiAgICAgICAgICAgICAgICAvLyBjb25zb2xlLmxvZyhuYW1lLCBwYXRoLCBzZWxlY3QsIG9iaiwgdmFsLCBzdGFtcCwgZnJvbSwgcmVtb3ZlLCBhZGRlZCwgb2xkdmFsLCBpbnN0YW5jZXMpXG5cbiAgICAgICAgICAgICAgICBmaWVsZCA9IGZpZWxkLnNwbGl0KCcuJylcblxuICAgICAgICAgICAgICAgIHNlbGVjdCA9IHV0aWwuZ2V0KHQuX2QsIGZpZWxkKVxuXG4gICAgICAgICAgICAgICAgaWYoIXNlbGVjdCAmJiB0Ll9kICYmIHQuX2QuZnJvbSAmJiBmaWVsZCApIHtcbiAgICAgICAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKCdOTyBTRUxFQ1QnLnJlZC5pbnZlcnNlLCB0Ll9kIClcbiAgICAgICAgICAgICAgICAgIHNlbGVjdCA9IHV0aWwuZ2V0KHQuX2QuZnJvbSwgZmllbGQpXG4gICAgICAgICAgICAgICAgICAvLyBpZihzZWxlY3QpIHtcbiAgICAgICAgICAgICAgICAgIC8vICAgLy8gY29uc29sZS5sb2coJ0ZPVU5EIFNFTEVDVCcuZ3JlZW4uaW52ZXJzZSwgc2VsZWN0KVxuICAgICAgICAgICAgICAgICAgLy8gfVxuICAgICAgICAgICAgICAgIH0gXG5cbiAgICAgICAgICAgICAgICBpZihzZWxlY3QgJiYgZnJvbSAmJiBmcm9tLl9fdCA9PT0gNCkgbGZpZWxkID0gdHJ1ZSAvL3Rlc3QgZGl0IG9mIGhldCBhbGxlcyBzbG93IG1hYWt0XG5cbiAgICAgICAgICAgICAgICAvLyBpZih0ZXN0JiZzZWxlY3QpIGNvbnNvbGUubG9nKHNlbGVjdC5fdmFsKVxuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgaWYgKCFwYXNzICYmIGZyb20pIHtcblxuICAgICAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKCd0ZXN0aW5nLi4uLj8nLCBuYW1lLCBmcm9tLCBzZWxlY3QsIGxmaWVsZClcbiAgICAgICAgICAgICAgICAvLyBpZih0ZXN0KSBjb25zb2xlLmxvZyhuYW1lLCBzZWxlY3QsIGxmaWVsZCwgZnJvbSk7XG5cbiAgICAgICAgICAgICAgICBmciA9IHRydWU7XG4gICAgICAgICAgICAgICAgdmFyIGZyb21Gcm9tXG5cbiAgICAgICAgICAgICAgICBpZiAoIGZyb20gPT09IHNlbGVjdCB8fCAoIGZyb21Gcm9tID0gZnJvbS5mcm9tICkgPT09IHNlbGVjdCApIHtcbiAgICAgICAgICAgICAgICAgIHBhc3MgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICBpZiAodC5fZC5fZmlsdGVyICYmIHNlbGVjdCAmJiBzZWxlY3QuX2FuY2VzdG9yKGZyb20pKSB7XG4gICAgICAgICAgICAgICAgICAgIHBhc3MgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAvL2ZpZWxkIG9vayB2b29yIGFycmF5cyE7XG4gICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGxmaWVsZCkge1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKCdnb3QgbGZpZWxkISEhIScpXG5cbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgbiA9IDA7IG4gPCBmaWVsZC5sZW5ndGg7IG4rKykge1xuICAgICAgICAgICAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKCdjb21wYTIyMnJlJylcbiAgICAgICAgICAgICAgICAgICAgICBpZiAobmFtZSAmJiBfY29tcGFyZShuYW1lLCBmaWVsZFtuXSkgfHwgZmllbGRbbl1bMF0gPT09IG5hbWVbMF0gJiYgdXRpbC5nZXQodmFsLCBmaWVsZFtuXS5jb25jYXQoKS5zaGlmdCgpKSkgXG4gICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgZnIgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgIH0gXG4gICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoKF9jb21wYXJlKHBhdGguY29uY2F0KGZpZWxkW25dKSwgZnJvbVBhdGgpIHx8IF9jb21wYXJlKGZpZWxkW25dLCBmcm9tUGF0aCkpKSBcbiAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmciA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgfSBcbiAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcblxuLy8gPDw8PDw8PCBIRUFEXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBjb25zb2xlLmxvZygnSEVSRT8nLCAnXFxuXFxuXFxuJywgc2VsZWN0LmZyb20sICc/Jywgc2VsZWN0LCAndmFsOicsIHRoaXMuX3BhdGgsIHZhbCwgcGF0aCwgZnIgKVxuLy8gPT09PT09PVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gY29uc29sZS5sb2coJ0hFUkU/JywgJ1xcblxcblxcbicsIHNlbGVjdCwgJ3ZhbDonXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyAgICwgdmFsLCAnZmllbGQ6JywgZmllbGQsICdmbicsIGZpZWxkW25dLCAnbjonLCBuLCAnY2hlY2sgZmllbGQ6JywgdmFsICYmIHZhbFtmaWVsZFtuXV0sICdyZWY6JywgdmFsLmZyb20pXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBjb25zb2xlLmxvZygnY29taW5nIHRydWdoJywgc2VsZWN0ICYmIGZyb20uX3ZhbCAhPT0gbnVsbCAmJiB2YWwsIGZpZWxkW25dXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyAgICwgc2VsZWN0ICYmIGZyb20uX3ZhbCAhPT0gbnVsbCAmJiB2YWwgJiYgKCB2YWxbZmllbGRbbl1dIHx8IHZhbC5fX3QgPT09IDQgJiYgdmFsLmZyb21bZmllbGRbbl1dICkgKVxuLy8gPj4+Pj4+PiBjMTE2ZTA2OTY5MDE3ZmQ5YzFkOGQ4NTc3OGU3MTZiZjkxYjcyNzRjXG4gICAgICAgICAgICAgICAgICAgICAgICAvL1RPRE86IG5lZWQgdG8gYWRkIG1vcmUgZ2F1cmRpbmcgZm9yIHZhbC4kcGF0aCBjaGVjayBpZiB0aGlzIGlzIGNsb3VkIGFuZCByZWZcblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYoc2VsZWN0ICYmIGZyb20uX3ZhbCAhPT0gbnVsbCAmJiB2YWwgJiYgKHZhbFtmaWVsZFtuXV0gfHwgdmFsLiRwYXRoIHx8IHZhbC5fX3QgPT09IDQpICYmIChzZWxlY3QuX2FuY2VzdG9yKGZyb20pIHx8IHNlbGVjdC5mcm9tLl9hbmNlc3RvciggZnJvbUZyb20gKSAgKSkgIC8vXG4gICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKHZhbCwgZmllbGQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICBwYXNzID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKCAnLS0tJywgc2VsZWN0LCB2YWwsIGZpZWxkLCBmcm9tLCAnZnJvbVBhdGg6JyAsIGZyb21QYXRoLCBmaWVsZCwgZmllbGQgKVxuXG4gICAgICAgICAgICAgICAgICAgIGlmKHZhbD09PW51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAvLyBpZihERUJVRyQpIHQuX2QuREVCVUckbG9nKCdkYXRhL2Jhc2UgLS0tPiBFUlJPUiB2YWwgaXMgbnVsbCAgLS0tPicrdC5fZC5fcmVtb3ZlZCApXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZih2YWwgPT09IHZvaWQgMCkge1xuICAgICAgICAgICAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKCdcXG5cXG5cXG4gdW5kZWZpbmVkIHdoYXQgdG8gZG8gbm93PycucmVkLmludmVyc2UpXG4gICAgICAgICAgICAgICAgICAgICAgLy8gcGFzcyA9IHRydWVcbiAgICAgICAgICAgICAgICAgICAgICAvLyBwYXNzID0gdHJ1ZVxuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKG5hbWUgJiYgX2NvbXBhcmUobmFtZSwgZmllbGQpIHx8IGZpZWxkWzBdID09PSBuYW1lICYmIG5hbWVbMF0gJiYgdXRpbC5nZXQodmFsLCBmaWVsZC5jb25jYXQoKS5zaGlmdCgpKSkge1xuICAgICAgICAgICAgICAgICAgICAgIGZyID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoZnJvbVBhdGggJiYgcGF0aCAmJiAoX2NvbXBhcmUocGF0aC5jb25jYXQoZmllbGQpLCBmcm9tUGF0aCkgfHwgX2NvbXBhcmUoZmllbGQsIGZyb21QYXRoKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICBmciA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHNlbGVjdCAmJiAodmFsW2ZpZWxkWzBdXSkgJiYgc2VsZWN0Ll9hbmNlc3Rvcihmcm9tKSkge1xuICAgICAgICAgICAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKHZhbCwgZmllbGQpO1xuICAgICAgICAgICAgICAgICAgICAgIHBhc3MgPSB0cnVlXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiggdC5fX2NoZWNrS2V5c19fICkge1xuICAgICAgICAgICAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKCdsZXRzIGNoZWNraiB0aGUga2V5cyEnKVxuICAgICAgICAgICAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKCBmaWVsZCwgbmFtZSwgdmFsLCBwYXRoLCBzZWxlY3QsIHZhbFtmaWVsZFswXV0sIGZyb20sIHRoaXMgKVxuICAgICAgICAgICAgICAgICAgICAgIGZvciggdmFyIGtleSQgaW4gdC5fX2NoZWNrS2V5c19fICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYoIGZpZWxkID09PSB0Ll9fY2hlY2tLZXlzX19ba2V5JF0gfHwgZmllbGRbMF0gPT09IHQuX19jaGVja0tleXNfX1trZXkkXSApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gY29uc29sZS5sb2coJ21heWJlPz8hIUAjIUAnLCBpLCB0Ll9fY2hlY2tLZXlzX19ba2V5JF0pXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHBhc3MgPSB0cnVlXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gY29uc29sZS5sb2codmFsLCBmaWVsZFswXSwgZnJvbSk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIC8vIHBhc3MgPSB0cnVlO1xuICAgICAgICAgICAgICAvLyBjb25zb2xlLmxvZygnUEFTUz4+Pj4+Pj4+Pj8nLm1hZ2VudGEuaW52ZXJzZSwgcGFzcyA/ICdPSyEnLmdyZWVuLmludmVyc2UgOiAnTk8hJy5yZWQuaW52ZXJzZSAgXG4gICAgICAgICAgICAgIC8vICAgLCAndmFsOicuYmx1ZSwgdmFsXG4gICAgICAgICAgICAgIC8vICAgLCAnb2JqLl9wYXRoOicuYmx1ZSwgb2JqICYmIG9iai5fcGF0aFxuICAgICAgICAgICAgICAvLyAgICwgJ2ZpZWxkOicuYmx1ZSwgZmllbGRcbiAgICAgICAgICAgICAgLy8gICAsICdmcm9tUGF0aDonLmJsdWUsIGZyb21QYXRoXG4gICAgICAgICAgICAgIC8vICAgLCAnZnJvbTonLmJsdWUsIGZyb21cbiAgICAgICAgICAgICAgLy8gICAsICdzZWxlY3QnLmJsdWUsIHNlbGVjdFxuICAgICAgICAgICAgICAvLyAgIClcblxuICAgICAgICAgICAgICAvLyBpZighIHBhc3MgJiYgKVxuXG4gICAgICAgICAgICAgIC8vIHBhc3MgPSB0cnVlXG5cbiAgICAgICAgICAgICAgaWYgKHBhc3MgfHwgKGluc3RhbmNlcyB8fCByZW1vdmUgfHwgc2VsZWN0ICE9PSB2b2lkIDApICYmICggIWZyIHx8IHJlbW92ZSA9PT0gMSkpIHtcblxuICAgICAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKCd1cGRhdGluZyEnLmN5YW4uaW52ZXJzZSwgaSwgdmFsLCBpbnN0YW5jZXMsIHJlbW92ZSwgc2VsZWN0LCBmciwgZnJvbSlcbiAgICAgICAgICAgICAgICAvLyBkZWJ1Z2dlclxuICAgICAgICAgICAgICAgIC8vc3RhbXAgbWVlZ2V2ZW4/Pz8/XG4gICAgICAgICAgICAgICAgLy8gY29uc29sZS5sb2coICdGUk9NISEhISEnLmdyZWVuLmludmVyc2UsIGZyb20gKVxuICAgICAgICAgICAgICAgIC8vIGNvbnNvbGUubFxuICAgICAgICAgICAgICAgIHRbaV0uX3VwZGF0ZSh2YWwsIGZhbHNlLCBmcm9tLCByZW1vdmUsIGFkZGVkLCBvbGR2YWwsICFpbnN0YW5jZXMsIHQpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAgICAgICAgLy9hZGQgYWR2YW5jZWQgbW9kZWxzIChsaWtlIG9uIHdlYnNpdGUpXG4gICAgICAgICAgICAvL25vdCB0ZXN0ZWQgYW5kIHN0aWxsIHByZXR0eSBicm9rZW5cbiAgICAgICAgICAgdmFyIHBhcnNlciA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuX2QpIHtcbiAgICAgICAgICAgICAgdmFyIHQgPSB0aGlzLCBhXG4gICAgICAgICAgICAgIC8vaWYgYWRkZWQgb3IgZmlyc3QgcnVuXG4gICAgICAgICAgICAgIHQubW9kZWwudmFsIC8vc2V0IF9jYWxsZXJcbiAgICAgICAgICAgICAgLy8gaWYgKG1vZGVsLmZpZWxkKSBjb25zb2xlLmxvZygnPz8/PycsIHRoaXMuZmllbGQsIG1vZGVsLmZpZWxkKVxuXG4gICAgICAgICAgICAgIGlmIChtb2RlbC5maWVsZCAmJiBtb2RlbC5maWVsZC52YWwpIHsgXG5cbiAgICAgICAgICAgICAgICBpZih0Ll9pZ25vcmVGaWVsZEluU3Vic2NyaXB0aW9uICYmIHQuX2QgaW5zdGFuY2VvZiB2T2JqZWN0ICkge1xuICAgICAgICAgICAgICAgICAgLy8gY29uc29sZS5sb2coJ0lHTk9SRUZJRUxEJy5pbnZlcnNlLCB0Ll9kKVxuXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAvLyBjb25zb2xlLmxvZygnRklFTEQgUEFSU0lORyEgTEVUUyBHRVQgQUdBSU4hJy5jeWFuLmludmVyc2UsIG1vZGVsLmZpZWxkLnZhbCwgdC5fZCwgdGhpcy5fX2NoZWNrS2V5c19fIClcbiAgICAgICAgICAgICAgICBhID0gdXRpbC5nZXQoIHQuX2QsIG1vZGVsLmZpZWxkLnZhbCwgdHJ1ZSApXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKCdMRVRTIEdFVCBBR0FJTiEyJy5jeWFuLmludmVyc2UsIGEgKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmKCFhKSB7XG4gICAgICAgICAgICAgICAgICAvLyBjb25zb2xlLmxvZygnQkFEQkFEQkFEJy5yZWQuaW52ZXJzZSlcbiAgICAgICAgICAgICAgICAgIC8vIGEgPSB1dGlsLmdldCggdC5fZCwgbW9kZWwuZmllbGQudmFsIClcbiAgICAgICAgICAgICAgICB9IFxuICAgICAgICAgICAgICAgIGVsc2UgaWYoIHQuX2QgJiYgIXQuX2QuY2xvdWQgKSBcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAvLyBjb25zb2xlLmxvZygnTk9XIGxldHMgc2V0IGZsYWchJy5jeWFuLmludmVyc2UpXG4gICAgICAgICAgICAgICAgICB0aGlzLl9pZ25vcmVGaWVsZEluU3Vic2NyaXB0aW9uID0gdHJ1ZVxuICAgICAgICAgICAgICAgICAgLy8gZGVidWdnZXJcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYodC5fZC5jbG91ZCkge1xuICAgICAgICAgICAgICAgICAgdGhpcy5faWdub3JlRmllbGRJblN1YnNjcmlwdGlvbiA9IG51bGxcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKCBhICkgXG4gICAgICAgICAgICAgIC8vbWFrZSBpZiBub3QgYSAtLS0gZG8gd2l0aG91dCBzZWxmXG5cbiAgICAgICAgICAgICAgLy8gaWYgKG1vZGVsLmZpZWxkKSB7XG4gICAgICAgICAgICAgICAgLy8gLy8gY29uc29sZS5sb2coICdmaWVsZCBnZXR0ZXIhIScucmVkLmludmVyc2UsIG1vZGVsLmZpZWxkLnZhbFxuICAgICAgICAgICAgICAgIC8vICAsICdmaWVsZCcuYmx1ZSAsIHRoaXMuX2RbbW9kZWwuZmllbGQudmFsXVxuICAgICAgICAgICAgICAgIC8vICAgLCAgdGhpcy5fZC5fcGF0aCAmJiAgdGhpcy5fZC5fcGF0aC5qb2luKCcgLCAnKSApXG4gICAgICAgICAgICAgIC8vIH1cblxuXG4gICAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKCc/Pz8/Pz8nKVxuXG4gICAgICAgICAgICAgIGlmIChtb2RlbC5fdmFsKSBhID0gbW9kZWwuX3ZhbC5jYWxsKHQsIGEgfHwgdC5fZCkgfHwgYVxuXG5cbiAgICAgICAgICAgICAgaWYgKGEgJiYgdC5fZCAhPT0gYSkge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBjb25zb2xlLmxvZygnPz8/PzMzMzMyMjIyPz8nKVxuXG4gICAgICAgICAgICAgICAgbW9kZWwucGFyc2luZyA9IHRydWVcbiAgICAgICAgICAgICAgICBpZihtb2RlbC5maWVsZCkgbW9kZWwucGFyc2VkID0gbW9kZWwuZmllbGQudmFsXG5cblxuXG5cbiAgICAgICAgICAgICAgICAvLyBfZFNldDogZnVuY3Rpb24oIHZhbCwgZGZyb20sIG1vZGVsRmllbGQgKSB7IC8vZmllbGRcblxuICAgICAgICAgICAgICAgIC8vZGV6ZSBtb2V0IG9vayBibGlqdmVuIGNoYW5nZW4hXG4gICAgICAgICAgICAgICAgLy8gY29uc29sZS5sb2coJ1BBUlNFIE1PREVMISEhISEnLmdyZWVuLmludmVyc2UsIHRoaXMuX2Rmcm9tLCB0aGlzLl9fY2hlY2tLZXlzX18gKVxuICAgICAgICAgICAgICAgIC8vaGllciBtb2V0IGhldCBnZWJldXJlbiEhISFcblxuICAgICAgICAgICAgICAgIC8vIGlmKHRoaXMuKVxuICAgICAgICAgICAgICAgIHRoaXMuX2RTZXQoYSwgdGhpcy5fZGZyb20sIHRydWUgKVxuICAgICAgICAgICAgICAgIC8vZGl0IGlzIHBhcnNpbmcgZGFuIHdvcmQgZXIgbmlldCBvcCBnZXN1YnNjcmliZWRcbiAgICAgICAgICAgICAgICBtb2RlbC5wYXJzaW5nID0gZmFsc2VcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAvLyBjb25zb2xlLmxvZygnZW5kJylcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgcGFyc2VyLmNhbGwodClcbiAgICAgICAgICBpZiAoaW5zdGFuY2VzKSB0LmVhY2hJbnN0YW5jZShwYXJzZXIsICdtb2RlbCcpXG4gICAgICAgICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICAgICAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAgICAgICBpZiAoZiAmJiAoaW5zdGFuY2VzIHx8IHQuX2QpKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpIGluIGYpIHtcbiAgICAgICAgICAgICAgaWYgKCFmW2ldLl9fdCkge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGogPSAwLCBsID0gZltpXS5sZW5ndGg7IGogPCBsOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgIGlmIChtZXRob2QoaSwgZltpXVtqXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIG1ldGhvZChpLCBmW2ldKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgICAgICAgaWYodGhpcy5tb2RlbC5jb21wbGV0ZSkgdGhpcy5tb2RlbC5jb21wbGV0ZS5fdmFsLmNhbGwodGhpcyxkYXRhKVxuXG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBfZFNldDogZnVuY3Rpb24oIHZhbCwgZGZyb20sIG1vZGVsRmllbGQgKSB7IC8vZmllbGRcblxuXG4gICAgICAgIC8vIGlmKHZhbCkge1xuICAgICAgICAvLyAgIGNvbnNvbGUubG9nKCdfRHNldCcuY3lhbi5pbnZlcnNlLCB2YWwuX3BhdGgsIGRmcm9tKVxuICAgICAgICAvLyB9XG4gICAgICAgIC8vIGlmKHRoaXMubW9kZWwuX2ZsYWcgJiYgdGhpcy5tb2RlbC5fZmxhZy5wcm9jZXNzICYmICF0aGlzLl9fcHJvY2Vzc2luZykge1xuICAgICAgICAvLyAgIGNvbnNvbGUubG9nKCdvbzInKVxuICAgICAgICAvLyAgIHRoaXMubW9kZWwuX3VwZGF0ZSgpXG4gICAgICAgIC8vICAgcmV0dXJuXG4gICAgICAgIC8vIH1cblxuICAgICAgICBpZih0aGlzLm1vZGVsLl9mbGFnICYmIHRoaXMubW9kZWwuX2ZsYWcuZGVmZXIgICYmICF0aGlzLl9fcHJvY2Vzc2luZykge1xuICAgICAgICAgIHRoaXMuX19wRmxhZyA9IFsgdmFsLCBkZnJvbSBdXG4gICAgICAgICAgcmV0dXJuXG4gICAgICAgIH1cblxuICAgICAgICAvL2Rmcm9tIG1vZXQgbmlldCBub2cgZWVuIHN1YnNjcmliZSBkb2VuISAtLSBhbHMgaGV0IGdvZWQgaXMgaXMgem4gcGFyZW50IGFsIHN1YnNjcmliZWRcblxuICAgICAgICAvLyBpZiAodGhpcy5fZCAmJiB0aGlzLl9kLl9fdCkgdGhpcy5fZC5yZW1vdmVMaXN0ZW5lcih0cnVlLCB0aGlzKVxuICAgICAgICB2YXIgcmVzZXRcblxuICAgICAgICBpZiAodGhpcy5fZCkge1xuXG4gICAgICAgICAgLy8gaWYoIG1vZGVsRmllbGQgKSBjb25zb2xlLmxvZygnTU9ERUxGSUVMRCcueWVsbG93LmludmVyc2UsIG1vZGVsRmllbGQsICchISEhISEhISEhJy5ibHVlIClcblxuICAgICAgICAgIGlmKCB0aGlzLl9kID09PSB2YWwgKSB7XG4gICAgICAgICAgICAvLyBjb25zb2xlLmxvZygnVkFMVUUgSVMgVEhFIFNBTUUgQUJPUlQgX2RTZXQnLnJlZC5pbnZlcnNlIClcbiAgICAgICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgICAgIH1cbiAgICAgICAgICByZXNldCA9IHRydWVcbiAgICAgICAgICAvLyBjb25zb2xlLmxvZygnSU0gUkVTRVRUSU5HIF9kU2V0Jy5jeWFuLmludmVyc2UsIHRoaXMuX2QgLCAnLS0tLS0tPicuYmx1ZSAsIHZhbCApXG4gICAgICAgXG4gICAgICAgIH1cblxuICAgICAgICAvLyB2YXIgYmxhXG4gICAgICAgIC8vcmVzZXRcbiAgICAgICAgICAvL2ZpZWxkQ29ycmVjdGVkXG4gICAgICAgICAgLy8gY29uc29sZS5sb2coJ0lNIFJFU0VUVElORyBfZFNldCcuY3lhbi5pbnZlcnNlIClcbiAgICAgICAgLy8gfVxuXG4gICAgICAgIC8vIHJlbW92ZU1ldGhvZC5jYWxsKCB0aGlzICkgIFxuXG5cbiAgICAgICAgICAvL3RoaXMuX19jaGVja0tleXNfXyAmJlxuICAgICAgICAvLyBpZiggIHRoaXMubW9kZWwgJiYgdGhpcy5tb2RlbC5maWVsZCAmJiB0aGlzLm1vZGVsLmZpZWxkLnZhbCAmJiB0aGlzLl9kICkge1xuICAgICAgICAvLyAgIGNvbnNvbGUubG9nKHRoaXMuX2QsIHZhbCwgdGhpcy5tb2RlbC5maWVsZClcbiAgICAgICAgLy8gICAvL1RPRE86IHRoaXMgaXMgYSB0ZW1wZml4ISAtLSBjYW4gYWxzbyByZWZpcmUgb2Zjb3Vyc2VcbiAgICAgICAgLy8gICBpZiggdGhpcy5fZCA9PT0gdmFsWyB0aGlzLm1vZGVsLmZpZWxkLnZhbCBdICkgXG4gICAgICAgIC8vICAge1xuXG4gICAgICAgIC8vICAgICAvLyBpZih0aGlzLl9kKVxuXG4gICAgICAgIC8vICAgICAgIGlmIChkZnJvbSkgdGhpcy5fZGZyb20gPSB0cnVlXG4gICAgICAgIC8vICAgICByZXR1cm4gdGhpcy5fZFxuICAgICAgICAvLyAgIH1cbiAgICAgICAgLy8gfVxuXG5cblxuICAgICAgICB2YXIgZXhjbHVkZXMgXG5cbiAgICAgICAgZXhjbHVkZXMgPSByZW1vdmVNZXRob2QuY2FsbCggdGhpcywgdmFsICkgIFxuXG4gICAgICAgIC8vcmVtb3ZlTWV0aG9kXG4gICAgICAgIC8vIGNvbnNvbGUubG9nKCAnIUAhQCMhQCMhQCMhQCMhQCMhQCMhQCMhQCMhQCMnLCByZW1vdmVNZXRob2QgIClcblxuICAgICAgICAvLyBpZihleGNsdWRlcykge1xuICAgICAgICAvLyAgIGNvbnNvbGUubG9nKCdFWENMVURFUycuZ3JlZW4uaW52ZXJzZSwgZXhjbHVkZXMpXG4gICAgICAgIC8vIH1cblxuLy8gICAgICAgIGNvbnNvbGUubG9nKCdTRVRUSU5HIERBVEEnLCB2YWwgLCAhIWRmcm9tLCByZXNldClcbiAgICAgICAgdGhpcy5fZCA9IHZhbFxuXG4gICAgIFxuXG4gICAgICAgIGlmIChkZnJvbSkge1xuICAgICAgICAgIHRoaXMuX2Rmcm9tID0gdHJ1ZVxuICAgICAgICAgIC8vIGNvbnNvbGUubG9nKCdERlJPTScueWVsbG93LmludmVyc2UsIGRmcm9tKVxuXG4gICAgICAgICAgaWYoZGZyb20uX19jaGVja0tleXNfXykge1xuICAgICAgICAgICAgY29uc29sZS5sb2coZGZyb20uX19jaGVja0tleXNfXylcbiAgICAgICAgICB9XG5cbiAgICAgICAgfVxuXG5cbiAgICAgICAgLy8gY29uc29sZS5sb2coJyEhISEhISEhISEhISEhISEhISEhISEhISEhIScpXG4gICAgICAgIHRoaXMuX2RMaXN0ZW4oIGV4Y2x1ZGVzIClcblxuICAgICAgXG5cbiAgICAgICAgcmV0dXJuIHZhbFxuICAgICAgfSxcbiAgICAgIF9kTGlzdGVuOiBmdW5jdGlvbiggZXhjbHVkZXMgKSB7XG5cbiAgICAgICAgICAvLyBjb25zb2xlLmxvZygnSEVFRUVFRScsIHRoaXMubW9kZWwpXG5cblxuICAgICAgICAgIC8vIGNvbnNvbGUubG9nKCdEIExJU1RFTiEnLmludmVyc2UsIGV4Y2x1ZGVzKVxuXG4gICAgICAgIC8vIGlmKHRoaXMubW9kZWwuX2ZsYWcgJiYgdGhpcy5tb2RlbC5fZmxhZy5wcm9jZXNzICYmICF0aGlzLl9fcHJvY2Vzc2luZykge1xuICAgICAgICAvLyAgIGNvbnNvbGUubG9nKCdvbzInKVxuICAgICAgICAvLyAgIHRoaXMubW9kZWwuX3VwZGF0ZSgpXG4gICAgICAgIC8vICAgcmV0dXJuXG4gICAgICAgIC8vIH1cblxuICAgICAgICAvL2hpZXIgZ2FhbiB3ZSBzIGZmdGplcyB3ZXJrZW4gbWV0IGVhY2hcblxuICAgICAgICAvLyB0aGlzLl9kZnJvbSA9IHRydWU7XG4gICAgICAgIHZhciBfdGhpc1xuICAgICAgICB2YXIgZGF0YVVwZGF0ZVxuXG5cbiAgICAgICAgaWYgKHRoaXMubW9kZWwgJiYgdGhpcy5fZCAmJiB0aGlzLl9kIGluc3RhbmNlb2Ygdk9iamVjdCkgXG4gICAgICAgIHsgLy90aGlzIG1vZGVsIG1heWJlIG5vdCBuZXNzZWNhcnk/XG5cblxuXG4gICAgICAgICAgZGF0YVVwZGF0ZSA9IHRydWVcbiAgICAgICAgICAvLyBjb25zb2xlLmxvZygnLS0tLS0+Jy5jeWFuLmludmVyc2UsIHRoaXMuX2QgKVxuXG4gICAgICAgICAgLy9oaWVyIGZmIG1lZWdldmVuIGRhdCBqZSB2YW51aXQgZmllbGQgd2Vya3QgaW5jbSBtZXQgZWVuIGVhY2ggY2hlY2tcbiAgICAgICAgICAvLy0tcmVtb3ZlIGZpZWxkIHVpdCBkZSBlcXVhdGlvblxuICAgICAgICAgIHZhciBhcnIgPSBbdGhpcy5fZFVwZGF0ZSwgdGhpcyBdXG5cbiAgICAgICAgICBpZih0aGlzLm1vZGVsLmZpZWxkICYmIHRoaXMubW9kZWwuZmllbGQudmFsKSB7XG4gICAgICAgICAgICAvLyBjb25zb2xlLmxvZygnRklFTEQnLHRoaXMubW9kZWwuZmllbGQudmFsKVxuICAgICAgICAgICAgLy8gYXJyLnB1c2godGhpcy5tb2RlbC5maWVsZC52YWwpXG4gICAgICAgICAgfVxuXG5cbiAgICAgICAgICB0aGlzLl9kLmFkZExpc3RlbmVyKGFycilcblxuICAgICAgICAgIF90aGlzID0gdGhpc1xuICAgICAgICAgIFxuICAgICAgICAgIC8vaGllciBmaWx0ZXJlbiBvcCBjbG91ZERhdGEgLS0tIG9vayB3ZXJrZW4gdmFudWl0IHJlbW92ZSEhIVxuICAgICAgICAgICAgLy9uZXZlciBkbyBmb3IgY2xvdWQgZGF0YVxuICAgICAgICAgIGlmKCAhdGhpcy5fZC5jbG91ZCApXG4gICAgICAgICAge1xuICAgICAgICAgICAgdGhpcy5fZC5lYWNoKFxuICAgICAgICAgICAgICBmdW5jdGlvbigga2V5ICkgeyBcbiAgICAgICAgICAgICAgICBpZiggIWV4Y2x1ZGVzIHx8ICF1dGlsLmNoZWNrQXJyYXkoIGV4Y2x1ZGVzLCBrZXkgKSApXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgLy8gZGF0YVVwZGF0ZT10cnVlXG4gICAgICAgICAgICAgICAgICAvL2RpdCBnYWF0IG5nbyB3cm9uZyAodGhpcylcbiAgICAgICAgICAgICAgICAgIGlmKCB0aGlzLl9fdCA9PT0gNCApIHtcbiAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hZGRMaXN0ZW5lcihbIF90aGlzLl9kVXBkYXRlLCBfdGhpcywgJyRuZGF0YScsIHRoaXMgXSkgXG5cbiAgICAgICAgICAgICAgICAgICAgLy8gaWYoIXRoaXMuX2QuY2xvdWQpIHtcblxuICAgICAgICAgICAgICAgICAgICAvLyAgIHRoaXMuZWFjaCgpXG5cbiAgICAgICAgICAgICAgICAgICAgLy8gfVxuXG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAvLyAgZWxzZSBpZiggIXRoaXMuY2xvdWQgKSB7XG4gICAgICAgICAgICAgICAgICAvLyAgIHZhciBfX3RoaXMgPSB0aGlzXG4gICAgICAgICAgICAgICAgICAvLyAgIHRoaXMuZWFjaChmdW5jdGlvbihrZXkkKSB7XG4gICAgICAgICAgICAgICAgICAvLyAgICAgaWYoIHRoaXMuX190ID09PSA0ICkge1xuICAgICAgICAgICAgICAgICAgLy8gICAgICAgY29uc29sZS5sb2coJ2dvIGdvIGdvIScsIGtleSQpXG4gICAgICAgICAgICAgICAgICAvLyAgICAgICB0aGlzLmFkZExpc3RlbmVyKFsgX3RoaXMuX2RVcGRhdGUsIF90aGlzLCAnJG5kYXRhJywgWyB0aGlzICwgX190aGlzIF0gIF0pIFxuICAgICAgICAgICAgICAgICAgLy8gICAgIH1cbiAgICAgICAgICAgICAgICAgIC8vICAgfSlcbiAgICAgICAgICAgICAgICAgIC8vIH1cbiAgICAgICAgICAgICAgICB9IFxuICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgLy8gY29uc29sZS5sb2coJ1NFVCBDSEVDSyBLRVlTJy5pbnZlcnNlLCBrZXkgKVxuICAgICAgICAgICAgICAgIC8vIGRlYnVnZ2VyXG4gICAgICAgICAgICAgICAgX3RoaXMuX19jaGVja0tleXNfXyA9IHRydWVcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgKVxuICAgICAgICAgIH1cbiAgICAgICAgICAvL2V2ZW50dWVlbCAudmFsIGdlYnJ1aWtlbiB2b29yIFZhbHVlcyAqYXdlc2p1bWUhXG4gICAgICAgICAgLy9ldmVudHVlZWwgaGllciBkaW5nZW4gYWRkZW4gYWFuIG1vZGVsXG5cbiAgICAgICAgfSBcbiAgICAgICAgZWxzZSBpZiggdGhpcy5tb2RlbCAmJiB0aGlzLl9kICYmIHR5cGVvZiB0aGlzLl9kID09PSAnb2JqZWN0JyApIFxuICAgICAgICB7XG4gICAgICAgICAgZm9yKCB2YXIga2V5IGluIHRoaXMuX2QgKSBcbiAgICAgICAgICB7XG4gICAgICAgICAgICAvLyBjb25zb2xlLmxvZyggJyE/Pz8/Pz8/Pz8/Pz8/Pz8/Pz8/Pz8/Jy5yZWQuaW52ZXJzZSApXG4gICAgICAgICAgICBpZighdGhpcy5fX2NoZWNrS2V5c19fIHx8IHRoaXMuX19jaGVja0tleXNfXz09PXRydWUpXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIHRoaXMuX19jaGVja0tleXNfXyA9IFtdIC8vVE9ETzogcmVtb3ZlIGxpc3RlbmVycyBoZXJlXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiggdGhpcy5fZFtrZXldIGluc3RhbmNlb2Ygdk9iamVjdCApXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIHRoaXMuX19jaGVja0tleXNfXy5wdXNoKCBrZXkgKSBcbiAgICAgICAgICAgICAgaWYoICFleGNsdWRlcyB8fCAhdXRpbC5jaGVja0FycmF5KCBleGNsdWRlcywga2V5ICkgKSBcbiAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIC8vIGRhdGFVcGRhdGUgPSB0cnVlXG4gICAgICAgICAgICAgICAgLy8gY29uc29sZS5sb2coJ0xFVFogQUREIElUIE5PVyBMSVNURU5FUiBMSVNURU5FUiEhISEnKVxuICAgICAgICAgICAgICAgIHRoaXMuX2Rba2V5XS5hZGRMaXN0ZW5lcihbIHRoaXMuX2RVcGRhdGUsIHRoaXMsICckbmRhdGEnLCBrZXkgXSlcbiAgICAgICAgICAgICAgICAvLyBjb25zb2xlLmxvZyh0aGlzLl9fY2hlY2tLZXlzX18pXG4gICAgICAgICAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgICAgICAgICAvLyBjb25zb2xlLmxvZygnSU0gRVhDTFVERScucmVkLmludmVyc2UsIGtleSlcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gdHJ1ZS8vZGF0YVVwZGF0ZVxuXG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICB1cGRhdGVEYXRhOiBmdW5jdGlvbihpbnN0YW5jZXMpIHtcblxuICAgICAgICBpZih0aGlzLm1vZGVsLl9mbGFnICYmIHRoaXMubW9kZWwuX2ZsYWcuZGVmZXIgJiYgIXRoaXMuX19wcm9jZXNzaW5nKSB7XG4gICAgICAgICAgLy8gY29uc29sZS5sb2coJ29vMicpXG4gICAgICAgICAgLy8gY29uc29sZS5sb2coJ0RFRkVSRUQgREFUQSBCRSBDQVJFRlVMTCcucmVkLmludmVyc2UgKVxuICAgICAgICAgIHRoaXMuX19wRmxhZ1UgPSBbIGluc3RhbmNlcyBdXG4gICAgICAgICAgdGhpcy5tb2RlbC5fdXBkYXRlKClcbiAgICAgICAgICByZXR1cm5cbiAgICAgICAgfVxuICAgICAgICAvLyBjb25zb2xlLmxvZygnIURPSVQgdXBkYXRlRGF0YScuY3lhbi5pbnZlcnNlKVxuXG4gICAgICAgIHRoaXMuX2RVcGRhdGUodGhpcy5fZCwgdm9pZCAwLCBmYWxzZSwgZmFsc2UsIGZhbHNlLCBmYWxzZSwgZmFsc2UsIGluc3RhbmNlcylcbiAgICAgIH1cbiAgICB9LFxuICAgIGV4dGVuZCA9IGZ1bmN0aW9uKGkpIHtcbiAgICAgIGJhc2UuZXh0ZW5kKHtcbiAgICAgICAgbmFtZTogaSxcbiAgICAgICAgdHlwZTogZmFsc2UsXG4gICAgICAgIHZhbHVlOiAoZXh0ZW5zaW9ucyAmJiBleHRlbnNpb25zW2ldKSA/IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIG1ldGhvZHNbaV0uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgICBleHRlbnNpb25zW2ldLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgIH0gOiBtZXRob2RzW2ldXG4gICAgICB9KTtcbiAgICB9O1xuICBmb3IgKHZhciBpIGluIG1ldGhvZHMpIHtcbiAgICBleHRlbmQoaSlcbiAgfVxuICBiYXNlLmV4dGVuZCh7XG4gICAgbmFtZTogJ21vZGVsJyxcbiAgICBzZXQ6IGZ1bmN0aW9uKHZhbCkge1xuXG4gICAgICBpZih0aGlzLl9fcEZsYWcgfHwgdGhpcy5fX3BGbGFnVSkge1xuICAgICAgICAvKlxuICAgICAgICBUT0RPOiB0ZXN0IGRlZmVyIGJldHRlciEhIVxuICAgICAgICB0aGlzLl9fcEZsYWcgPSBbIHZhbCBdXG4gICAgICAgIHRoaXMuX19wRmxhZ1UgPSBbIHRydWUgXVxuICAgICAgICAqL1xuICAgICAgICB0aGlzLl9fcHJvY2Vzc2luZyA9IHRydWVcbiAgICAgICAgdGhpcy5tb2RlbC5wYXJzaW5nID0gZmFsc2VcbiAgICAgICAgaWYodGhpcy5fX3BGbGFnKSB7XG4gICAgICAgICAgLy8gY29uc29sZS5sb2coJ1AgRkxBRyEhISEhIGJhc2UuZGF0YSBiZSBjYXJlZnVsbCEhISEnLmludmVyc2UucmVkKVxuICAgICAgICAgIHRoaXMuX2RTZXQuYXBwbHkodGhpcyx0aGlzLl9fcEZsYWcpXG4gICAgICAgIH1cbiAgICAgICAgLy9zdWJzY3JpYmUgaGVsZW1hYWwgZnVja2VkIG1ldCBmaWVsZCBlcmJpalxuICAgICAgICBpZih0aGlzLl9fcEZsYWdVKSB7XG4gICAgICAgICAgdGhpcy51cGRhdGVEYXRhLmFwcGx5KHRoaXMsdGhpcy5fX3BGbGFnVSlcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9fcEZsYWdVID0gbnVsbFxuICAgICAgICB0aGlzLl9fcEZsYWcgPSBudWxsXG4gICAgICAgIHRoaXMuX19wcm9jZXNzaW5nID0gbnVsbFxuICAgICAgfVxuXG4gICAgICBpZih2YWwuZmllbGQgJiYgdmFsLmZpZWxkLnZhbCAhPT0gdmFsLnBhcnNlZCkge1xuXG4gICAgICAgIC8vIGNvbnNvbGUubG9nKCAnRklFTEQgVVBEQVRFIScucmVkLmludmVyc2UsIHZhbC5maWVsZC52YWwgKVxuXG4gICAgICAgIHZhciBhID0gdmFsLnBhcnNlZCAmJiB2YWwucGFyc2VkLnNwbGl0KCcuJylcbiAgICAgICAgICAsIHBhcmVudFxuICAgICAgICB2YWwucGFyc2VkID0gbnVsbFxuICAgICAgICBpZih0aGlzLl9kKSB7XG4gICAgICAgICAgcGFyZW50ID0gdGhpcy5fZFxuICAgICAgICAgIGlmKCBhICkgXG4gICAgICAgICAge1xuICAgICAgICAgICAgZm9yKHZhciBpID0gYS5sZW5ndGgtMTsgaSA+PTAgOyBpLS0pIHtcbiAgICAgICAgICAgICAgcGFyZW50ID0gcGFyZW50Ll9wYXJlbnRcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmKHBhcmVudCkge1xuICAgICAgICAgICAgICAvLyBjb25zb2xlLmxvZyggJ0ZJRUxEIC0tLSBQQVJFTlQgQkUgQ0FSRUZVTEwhJy5yZWQuaW52ZXJzZSApXG4gICAgICAgICAgICAgIC8vcGFyZW50P1xuICAgICAgICAgICAgICB0aGlzLl9kU2V0KCBwYXJlbnQsIHRoaXMuX2Rmcm9tLCB2YWwgKVxuICAgICAgICAgICAgICB0aGlzLnVwZGF0ZURhdGEodHJ1ZSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IFxuICAgICAgICAgIGVsc2UgXG4gICAgICAgICAge1xuICAgICAgICAgICAgLy8gY29uc29sZS5sb2coICdGSUVMRCBCRSBDQVJFRlVMTCEnLnJlZC5pbnZlcnNlLCB2YWwuZmllbGQudmFsIClcbiAgICAgICAgICAgIHRoaXMudXBkYXRlRGF0YSh0cnVlKVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB2YWwucGFyc2VkID0gbnVsbFxuICAgICAgfVxuICAgIH0sXG4gICAgcmVtb3ZlOiBmdW5jdGlvbigpIHtcbiAgICAgIC8vIGNvbnNvbGUuY2xlYXIoKVxuICAgICAgLy8gY29uc29sZS5sb2coJy0tLS0tLS0tLVJFTU9WRSEhISEhISEhIScuY3lhbi5pbnZlcnNlLCB0aGlzLl9fY2hlY2tLZXlzX18gKVxuXG4gICAgICAvL2NvbnNvbGUubG9nKCdQIEZMQUchISEhISBiYXNlLmRhdGEgYmUgY2FyZWZ1bGwhISEhJy5pbnZlcnNlLnJlZClcblxuICAgICAgcmVtb3ZlTWV0aG9kLmNhbGwoIHRoaXMgKVxuICAgIH1cbiAgICAvLyBwYXJlbnQ6IGZ1bmN0aW9uKHBhcmVudCkge1xuICAgIC8vICAgaWYoIHBhcmVudC5kYXRhICYmICghcGFyZW50LnBhcmVudCB8fCBwYXJlbnQucGFyZW50LmRhdGEhPT1wYXJlbnQuZGF0YSkgKSB7XG5cbiAgICAvLyAgICAgY29uc29sZS5lcnJvcignV1RGPycpXG5cbiAgICAvLyAgICAgdGhpcy5kYXRhID0gcGFyZW50LmRhdGFcbiAgICAvLyAgIH1cbiAgICAvLyB9XG4gIH0sIHtcbiAgICBuYW1lOiAnZGF0YScsXG4gICAgdHlwZTogZmFsc2UsXG4gICAgc2V0OiBmdW5jdGlvbih2YWwpIHtcbiAgICAgICAgLy8gY29uc29sZS5sb2coJz8nLHZhbClcbiAgICAgIGlmKCB0aGlzLl9kID09PSB2YWwgKSByZXR1cm5cblxuICAgICAgLy8gaWYoIXRoaXMubW9kZWwpIHRoaXMubW9kZWwgPSB7fSAvL2RpdCBtZXQgaGV0IG5vb2l0IHNldHRlbiB2YW4gZm1vZGVsIHNjaGVlbCBvcCBzaG93IGFsIDMvOSBzdWJzY3JpcHRpb25zXG4gICAgICAvL251IG5vZyBzaGFyZWQgc3VicyBtYWtlbiAtLSAnc2hvd3MnIChvb2sgbWV0ZWVuIHByb2Nlc3MpIGVuIGRhbiB3b3JkIHRoZXQgYWxzIGhldCBnb2VkIGlzIG5vZyBlZW4gc3R1ayBtaW5kZXJcbiAgICBcbiAgICAgIC8vIHRoaXMubW9kZWwgPSB7fSAvL3BhcyBvcCBtZXQgZGV6ZVxuICAgICAgLy8gY29uc29sZS5sb2coJz8yJylcblxuICAgICAgaWYoIHRoaXMubW9kZWwuX2ZsYWcgJiYgdGhpcy5tb2RlbC5fZmxhZy5kZWZlciApIHtcbiAgICAgICAgdGhpcy5fX3BGbGFnID0gWyB2YWwgXVxuICAgICAgICB0aGlzLl9fcEZsYWdVID0gWyB0cnVlIF1cbiAgICAgICAgLy8gY29uc29sZS5sb2coJyFAIyFAIyFAIyBPT09PJy5yZWQpXG4gICAgICAgIHJldHVyblxuICAgICAgfVxuXG4gICAgICAvLyBjb25zb2xlLmVycm9yKCchISEhIU1PREVMIC0tIGRpdCBtb2V0IHpvdmVlbCBtb2dlbGlqayBnZXJlZHVjZWQnLCB0aGlzLm1vZGVsKVxuXG4gICAgICB0aGlzLm1vZGVsLnBhcnNpbmcgPSBmYWxzZVxuICAgICAgdGhpcy5fZFNldCh2YWwpIFxuICAgICAgdGhpcy51cGRhdGVEYXRhKHRydWUpXG4gICAgICAvLyB9XG5cbiAgICAgIC8vc3Vic2NyaWJlIGhlbGVtYWFsIGZ1Y2tlZCBtZXQgZmllbGQgZXJiaWpcblxuICAgIH0sXG4gICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLl9kXG4gICAgfVxuICB9KVxufSkiLCIvKiFcbiAqIEBsaWNlbnNlIENvcHlyaWdodCAoYykgMjAxMi0yMDE0LCBWaWdvdXIuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBAYXV0aG9yOiBNYXJjdXMgQmVzamVzLCBtYXJjdXNAdmlnb3VyLmlvXG4gKi9cbnZhciBkYXRhID0gcmVxdWlyZSgnLi8nKSxcbiAgY250ID0gMCxcbiAgaGFuZGxlVGVzdCA9IG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24odGVzdCwgc3Vic09iaikge1xuICAgIC8vIGNvbnNvbGUuZXJyb3IoJ2hhbmRsZVRlc3QhJywgdGVzdClcbiAgICBpZiAodGVzdCBpbnN0YW5jZW9mIE9iamVjdCkge1xuICAgICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyh0ZXN0KTtcbiAgICAgIGlmIChrZXlzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICB2YXIga2V5ID0ga2V5c1swXVxuICAgICAgICAgICwgdmFsY2hlY2sgPSBoYW5kbGVGaWVsZChrZXksIHRlc3Rba2V5XSwgc3Vic09iailcbiAgICAgICAgICBcbiAgICAgICAgcmV0dXJuIHN1YnNPYmouX2NoZWNrID0gZnVuY3Rpb24oZG9jKXtcbiAgICAgICAgICAvLyBjb25zb2xlLmxvZygnVEVTVElORycsIHRlc3QsIGRvYyAmJiBkb2MucmF3KVxuICAgICAgICAgIC8vIGNvbnNvbGUubG9nKCdjaGVja2luZyBmb3Iga2V5Jywga2V5KVxuICAgICAgICAgIHZhciB2YWwgPSBnZXRWYWx1ZShkb2MpXG4gICAgICAgICAgcmV0dXJuIHZhbGNoZWNrKHZhbClcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIGxpc3QgPSBbXSxcbiAgICAgICAgICBrZXk7XG4gICAgICAgIGZvciAodmFyIGsgPSAwLCBsID0ga2V5cy5sZW5ndGg7IGsgPCBsOyBrKyspIHtcbiAgICAgICAgICBrZXkgPSBrZXlzW2tdO1xuICAgICAgICAgIGxpc3QucHVzaChoYW5kbGVGaWVsZChrZXksIHRlc3Rba2V5XSwgc3Vic09iaikpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzdWJzT2JqLl9jaGVjayA9IG1ha2VBTkQobGlzdCk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBzdWJzT2JqLl9jaGVjayA9IGZ1bmN0aW9uKGRvYykge1xuICAgICAgICByZXR1cm4gZ2V0VmFsdWUoZG9jKSA9PT0gdGVzdDtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuZnVuY3Rpb24gaGFuZGxlRmllbGQoa2V5LCB2YWx1ZSwgc3Vic09iaikge1xuICAvLyBjb25zb2xlLndhcm4oJ2hhbmRsZUZpZWxkIFsnLCBrZXksICddIHZhbHVlJywgdmFsdWUpXG4gIHZhciBjaGVjaztcbiAgc3dpdGNoIChrZXkpIHtcbiAgICBjYXNlICckbm90JzpcbiAgICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIE9iamVjdCkge1xuICAgICAgICB2YXIgZm9sbG93ID0gaGFuZGxlVGVzdCh2YWx1ZSwgc3Vic09iaik7XG4gICAgICAgIGNoZWNrID0gZnVuY3Rpb24oZG9jKSB7XG4gICAgICAgICAgcmV0dXJuIGZvbGxvdyhkb2MpID09PSBmYWxzZTtcbiAgICAgICAgfTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNoZWNrID0gZnVuY3Rpb24oZG9jKSB7XG4gICAgICAgICAgcmV0dXJuIGRvYyAhPT0gdmFsdWU7XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICBjYXNlICckbmUnOlxuICAgICAgY2hlY2sgPSBmdW5jdGlvbihkb2MpIHtcbiAgICAgICAgcmV0dXJuIGRvYyAhPT0gdmFsdWU7XG4gICAgICB9O1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnJGFuZCc6XG4gICAgICB2YXIgbGlzdCA9IG1ha2VMaXN0KHZhbHVlLCBzdWJzT2JqKTtcbiAgICAgIGNoZWNrID0gbWFrZUFORChsaXN0KTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJyRuYW5kJzpcbiAgICAgIHZhciBsaXN0ID0gbWFrZUxpc3QodmFsdWUsIHN1YnNPYmopO1xuICAgICAgY2hlY2sgPSBmdW5jdGlvbihkb2MpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBsaXN0Lmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgIGlmIChsaXN0W2ldKGRvYykgPT09IGZhbHNlKSByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9O1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnJG9yJzpcbiAgICAgIHZhciBsaXN0ID0gbWFrZUxpc3QodmFsdWUsIHN1YnNPYmopO1xuICAgICAgY2hlY2sgPSBmdW5jdGlvbihkb2MpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBsaXN0Lmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgIGlmIChsaXN0W2ldKGRvYykpIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH07XG4gICAgICBicmVhaztcbiAgICBjYXNlICckbm9yJzpcbiAgICAgIHZhciBsaXN0ID0gbWFrZUxpc3QodmFsdWUsIHN1YnNPYmopO1xuICAgICAgY2hlY2sgPSBmdW5jdGlvbihkb2MpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBsaXN0Lmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgIGlmIChsaXN0W2ldKGRvYykpIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH07XG4gICAgICBicmVhaztcbiAgICBjYXNlICckZXZlcnknOlxuICAgICAgc3Vic09iai5zZXQoJyQnLCB7fSk7XG4gICAgICAvLyBzdWJzT2JqLiQgPSB7XG4gICAgICAvLyAgIF91cDogc3Vic09ialxuICAgICAgLy8gfTtcbiAgICAgIHZhciBmb2xsb3cgPSBoYW5kbGVUZXN0KHZhbHVlLCBzdWJzT2JqLiQpO1xuICAgICAgY2hlY2sgPSBmdW5jdGlvbihkb2MpIHtcbiAgICAgICAgaWYgKGRvYyAmJiBkb2MuX190IDwgMykge1xuICAgICAgICAgIHZhciByZXN1bHQgPSB0cnVlO1xuICAgICAgICAgIGRvYy5lYWNoKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgaWYgKCFmb2xsb3codGhpcykpIHJldHVybiAhKHJlc3VsdCA9IGZhbHNlKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJyRuZXZlcnknOlxuICAgICAgc3Vic09iai5zZXQoJyQnLCB7fSk7XG4gICAgICAvLyBzdWJzT2JqLiQgPSB7XG4gICAgICAvLyAgIF91cDogc3Vic09ialxuICAgICAgLy8gfTtcbiAgICAgIHZhciBmb2xsb3cgPSBoYW5kbGVUZXN0KHZhbHVlLCBzdWJzT2JqLiQpO1xuICAgICAgY2hlY2sgPSBmdW5jdGlvbihkb2MpIHtcbiAgICAgICAgaWYgKGRvYyAmJiBkb2MuX190IDwgMykge1xuICAgICAgICAgIHZhciByZXN1bHQgPSBmYWxzZTtcbiAgICAgICAgICBkb2MuZWFjaChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGlmICghZm9sbG93KHRoaXMpKSByZXR1cm4gcmVzdWx0ID0gdHJ1ZTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnJCc6XG4gICAgY2FzZSAnJHNvbWUnOlxuICAgICAgc3Vic09iai5zZXQoJyQnLCB7fSk7XG4gICAgICAvLyBzdWJzT2JqLiQgPSB7XG4gICAgICAvLyAgIF91cDogc3Vic09ialxuICAgICAgLy8gfTtcbiAgICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIE9iamVjdCkge1xuICAgICAgICB2YXIgZm9sbG93ID0gaGFuZGxlVGVzdCh2YWx1ZSwgc3Vic09iai4kKTtcbiAgICAgICAgY2hlY2sgPSBmdW5jdGlvbihkb2MpIHtcbiAgICAgICAgICBpZiAoZG9jICYmIGRvYy5fX3QgPCAzKSB7XG4gICAgICAgICAgICB2YXIgZm91bmQ7XG4gICAgICAgICAgICBkb2MuZWFjaChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgaWYgKGZvbGxvdyh0aGlzKSkgcmV0dXJuIGZvdW5kID0gdHJ1ZTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIGZvdW5kIHx8IGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjaGVjayA9IGZ1bmN0aW9uKGRvYykge1xuICAgICAgICAgIGlmIChkb2MgJiYgZG9jLl9fdCA8IDMpIHtcbiAgICAgICAgICAgIHZhciBmb3VuZDtcbiAgICAgICAgICAgIGRvYy5lYWNoKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICBpZiAodGhpcyA9PT0gdmFsdWUpIHJldHVybiBmb3VuZCA9IHRydWU7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBmb3VuZCB8fCBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9O1xuICAgICAgICBzdWJzT2JqLiQuX2NoZWNrID0gZnVuY3Rpb24oZG9jKSB7XG4gICAgICAgICAgcmV0dXJuIGRvYyA9PT0gdmFsdWU7XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICBjYXNlICckbnNvbWUnOlxuICAgICAgc3Vic09iai5zZXQoJyQnLCB7fSk7XG4gICAgICAvLyBzdWJzT2JqLiQgPSB7XG4gICAgICAvLyAgIF91cDogc3Vic09ialxuICAgICAgLy8gfTtcbiAgICAgIHZhciBmb2xsb3cgPSBoYW5kbGVUZXN0KHZhbHVlLCBzdWJzT2JqLiQpO1xuICAgICAgY2hlY2sgPSBmdW5jdGlvbihkb2MpIHtcbiAgICAgICAgaWYgKGRvYyAmJiBkb2MuX190IDwgMykge1xuICAgICAgICAgIHZhciByZXN1bHQgPSB0cnVlO1xuICAgICAgICAgIGRvYy5lYWNoKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgaWYgKGZvbGxvdyh0aGlzKSkgcmV0dXJuICEocmVzdWx0ID0gZmFsc2UpO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICBicmVhaztcbiAgICBjYXNlICckbHQnOlxuICAgICAgY2hlY2sgPSBmdW5jdGlvbihkb2MpIHtcbiAgICAgICAgLy8gY29uc29sZS5sb2coJ2J1cmsgbHQnLCBkb2MsIHZhbHVlKVxuICAgICAgICByZXR1cm4gZG9jIDwgdmFsdWU7XG4gICAgICB9O1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnJGx0ZSc6XG4gICAgICBjaGVjayA9IGZ1bmN0aW9uKGRvYykge1xuICAgICAgICByZXR1cm4gZG9jIDw9IHZhbHVlO1xuICAgICAgfTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJyRndCc6XG4gICAgICBjaGVjayA9IGZ1bmN0aW9uKGRvYykge1xuICAgICAgICByZXR1cm4gZG9jID4gdmFsdWU7XG4gICAgICB9O1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnJGd0ZSc6XG4gICAgICBjaGVjayA9IGZ1bmN0aW9uKGRvYykge1xuICAgICAgICByZXR1cm4gZG9jID49IHZhbHVlO1xuICAgICAgfTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJyRjb250YWlucyc6XG4gICAgICB2YXIgcmVnZXggPSBuZXcgUmVnRXhwKHZhbHVlLCAnaScpO1xuICAgICAgY2hlY2sgPSBmdW5jdGlvbihkb2MpIHtcbiAgICAgICAgcmV0dXJuIHJlZ2V4LnRlc3QoZG9jKTtcbiAgICAgIH07XG4gICAgICBicmVhaztcbiAgICBjYXNlICckbmNvbnRhaW5zJzpcbiAgICAgIHZhciByZWdleCA9IG5ldyBSZWdFeHAodmFsdWUsICdpJyk7XG4gICAgICBjaGVjayA9IGZ1bmN0aW9uKGRvYykge1xuICAgICAgICByZXR1cm4gIXJlZ2V4LnRlc3QoZG9jKTtcbiAgICAgIH07XG4gICAgICBicmVhaztcbiAgICBjYXNlICckY29udGFpbnNhbGwnOlxuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnJG5jb250YWluc2FsbCc6XG4gICAgICBicmVhaztcbiAgICBjYXNlICckaGFzJzpcbiAgICAgIGNoZWNrID0gZnVuY3Rpb24oZG9jKSB7XG4gICAgICAgIHJldHVybiBkb2MgJiYgZG9jW3ZhbHVlXSAhPT0gdm9pZCAwO1xuICAgICAgfTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJyRuaGFzJzpcbiAgICAgIGNoZWNrID0gZnVuY3Rpb24oZG9jKSB7XG4gICAgICAgIHJldHVybiAhZG9jIHx8IGRvY1t2YWx1ZV0gPT09IHZvaWQgMDtcbiAgICAgIH07XG4gICAgICBicmVhaztcbiAgICBjYXNlICckZXhpc3RzJzpcbiAgICAgIGNoZWNrID0gZnVuY3Rpb24oZG9jKSB7XG4gICAgICAgIHJldHVybiAoZG9jICE9PSB2b2lkIDAgJiYgZG9jICE9PSBudWxsKSA9PT0gdmFsdWU7XG4gICAgICB9O1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnJGluJzpcbiAgICAgIGNoZWNrID0gZnVuY3Rpb24oZG9jKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gdmFsdWUubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgaWYgKGRvYyA9PT0gdmFsdWVbaV0pIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH07XG4gICAgICBicmVhaztcbiAgICBjYXNlICckbmluJzpcbiAgICAgIGNoZWNrID0gZnVuY3Rpb24oZG9jKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gdmFsdWUubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgaWYgKGRvYyA9PT0gdmFsdWVbaV0pIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH07XG4gICAgICBicmVhaztcbiAgICBjYXNlICckcmVnZXgnOlxuICAgICAgY2hlY2sgPSBmdW5jdGlvbihkb2MpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlLnRlc3QoZG9jKTtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBPYmplY3QpIHtcbiAgICAgICAgdmFyIGRzdWJzT2JqID0gc3Vic09ialtrZXldO1xuXG4gICAgICAgIGlmIChkc3Vic09iaikge1xuICAgICAgICAgIC8vIGNvbnNvbGUubG9nKCdhbHJlYWR5IG1hZGUgdGhhdCBkc3Vic09iaiB3aXRoIGtleScsIGtleSk7XG4gICAgICAgICAgLy8gZHN1YnNPYmouX3VwID0gc3Vic09ialxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHN1YnNPYmouc2V0KGtleSwge30pO1xuICAgICAgICAgIGRzdWJzT2JqID0gc3Vic09ialtrZXldO1xuICAgICAgICB9XG4gICAgICAgIHZhciBmb2xsb3cgPSBoYW5kbGVUZXN0KHZhbHVlLCBkc3Vic09iaik7XG5cbiAgICAgICAgY2hlY2sgPSBmdW5jdGlvbihkb2MpIHtcbiAgICAgICAgICAvLyBjb25zb2xlLmxvZygnVEVTVElORzogY2hlY2sgT0JKRUNUJywgZG9jICYmIGRvYy5yYXcgfHwgZG9jLCAnZm9yIGZpZWxkJywga2V5KVxuICAgICAgICAgIGRvYyA9IGdldEZpZWxkKGRvYywga2V5KVxuXG4gICAgICAgICAgLy8gY29uc29sZS5sb2coJ3d1cHMnLCBkb2MgJiYgZG9jLnJhdyB8fCBkb2MpXG4gICAgICAgICAgcmV0dXJuIGZvbGxvdyhkb2MpO1xuICAgICAgICB9O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY2hlY2sgPSBmdW5jdGlvbihkb2MpIHtcbiAgICAgICAgICBkb2MgPSBnZXRGaWVsZChkb2MsIGtleSlcbiAgICAgICAgICBcbiAgICAgICAgICAvLyBkb2MgPSBnZXRWYWx1ZShkb2MpXG4gICAgICAgICAgLy8gY29uc29sZS5sb2coJ1RFU1RJTkc6IGNoZWNrIFZBTFVFJywgZG9jICYmIGRvYy5yYXcgfHwgZG9jLCB2YWx1ZSwgZG9jID09PSB2YWx1ZSlcbiAgICAgICAgICByZXR1cm4gZG9jID09PSB2YWx1ZTtcbiAgICAgICAgfTtcbiAgICAgICAgc3Vic09iai5zZXQoa2V5LCB7fSk7XG4gICAgICAgIHN1YnNPYmpba2V5XS5fY2hlY2sgPSBjaGVja1xuICAgICAgICAvLyBzdWJzT2JqW2tleV0gPSB7XG4gICAgICAgIC8vICAgX3VwOiBzdWJzT2JqLFxuICAgICAgICAvLyAgIF9jaGVjazogZnVuY3Rpb24oZG9jKSB7XG4gICAgICAgIC8vICAgICByZXR1cm4gZG9jID09PSB2YWx1ZTtcbiAgICAgICAgLy8gICB9XG4gICAgICAgIC8vIH07XG4gICAgICB9XG5cbiAgfVxuICByZXR1cm4gc3Vic09iaiA/IHN1YnNPYmouX2NoZWNrID0gY2hlY2sgOiBjaGVjaztcbn1cblxuZnVuY3Rpb24gbWFrZUxpc3QoYXJyLCBzdWJzT2JqKSB7XG4gIHZhciBsaXN0ID0gW107XG4gIGZvciAodmFyIGkgPSAwLCBsID0gYXJyLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIGxpc3QucHVzaChoYW5kbGVUZXN0KGFycltpXSwgc3Vic09iaikpO1xuICB9XG4gIHJldHVybiBsaXN0O1xufVxuXG5mdW5jdGlvbiBtYWtlQU5EKGxpc3QsIHN1YnNPYmopIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKGRvYykge1xuICAgIHZhciB2YWwgPSBnZXRWYWx1ZShkb2MpO1xuICAgIGZvciAodmFyIGkgPSAwLCBsID0gbGlzdC5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIGlmIChsaXN0W2ldKHZhbCkgPT09IGZhbHNlKSByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9O1xufVxuXG5mdW5jdGlvbiBnZXRWYWx1ZSh0aGluZyl7XG4gIHZhciB2YWwgPSB0aGluZyAmJiB0aGluZy5mcm9tICYmIHRoaW5nLmZyb20udmFsXG4gIHJldHVybiB2YWwgIT09IHZvaWQgMCA/IHZhbCA6IHRoaW5nXG4gIFxufVxuZnVuY3Rpb24gZ2V0RmllbGQodGhpbmcsIGZpZWxkKXtcbiAgLy8gY29uc29sZS5lcnJvcignZ2V0RmllbGQgZmllbGQnLCBmaWVsZCwgJ2Zyb20nLCB0aGluZyAmJiB0aGluZy5yYXcgfHwgdGhpbmcpXG4gIHRoaW5nID0gZ2V0VmFsdWUodGhpbmcpXG4gIHJldHVybiB0aGluZyA/IGdldFZhbHVlKHRoaW5nW2ZpZWxkXSkgOiB2b2lkIDBcbn0iLCIvKiFcbiAqIEBsaWNlbnNlIENvcHlyaWdodCAoYykgMjAxMi0yMDE0LCBWaWdvdXIuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBAYXV0aG9yOiBKaW0gZGUgQmVlciwgamltQHZpZ291ci5pb1xuICovXG52YXIgViA9IHJlcXVpcmUoJy4uLycpLFxuICBvYmplY3QgPSByZXF1aXJlKCcuLi9vYmplY3QnKSxcbiAgdXRpbCA9IHJlcXVpcmUoJy4uL3V0aWwnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzID0gVi5EYXRhID0gb2JqZWN0Lm5ldygpO1xuZXhwb3J0cy5wcm90b3R5cGUuX2JsYWNrbGlzdC5wdXNoKCdfX3N1YicsJ19fYmxvY2snKTtcbnV0aWwuZGVmaW5lKGV4cG9ydHMsICdfaG9vaycsIGZ1bmN0aW9uKHZhbCwgb2JqKSB7XG4gIGlmIChvYmouc3Vic2NyaXB0aW9uKSB7XG4gICAgdGhpcy5fX3N1YiA9IG9iai5zdWJzY3JpcHRpb247XG4gICAgZGVsZXRlIG9iai5zdWJzY3JpcHRpb247XG4gIH1cbiAgaWYob2JqLmJsb2NrKSB7XG4gICAgdGhpcy5fX2Jsb2NrID0gdHJ1ZVxuICAgIGRlbGV0ZSBvYmouYmxvY2tcbiAgfVxufSk7XG5cbiIsIi8qIVxuICogQGxpY2Vuc2UgQ29weXJpZ2h0IChjKSAyMDEyLTIwMTQsIFZpZ291ci4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIEBhdXRob3I6IE1hcmN1cyBCZXNqZXMsIG1hcmN1c0B2aWdvdXIuaW9cbiAqL1xuXG52YXIgY29uZGl0aW9ucyA9IHJlcXVpcmUoJy4vY29uZGl0aW9ucycpXG4gICwgdXRpbEhhc2ggPSByZXF1aXJlKCcuLi91dGlsL2hhc2gnKVxuICAsIFZPYmplY3QgPSByZXF1aXJlKCcuLi9vYmplY3QnKVxuICAsIHV0aWwgPSByZXF1aXJlKCcuLi91dGlsJylcblxuLyoqXG4gKiBTZWxlY3Rpb25cbiAqIENsYXNzIGV4dGVudGlvbiBmb3Igc2VsZWN0aW9uIC8gZmlsdGVyaW5nIGZ1bmN0aW9uYWxpdHlcbiAqIEBDbGFzc1xuICovXG5cbmV4cG9ydHMuU3Vic09iaiA9IFZPYmplY3QubmV3KClcbmV4cG9ydHMuU3Vic09iai5wcm90b3R5cGUuX2JsYWNrbGlzdC5wdXNoKCAnX3Jvb3QnXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICwgJ19jaGVjaydcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLCAnX3NvcnQnXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICwgJ191aWQnXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIClcblxuZXhwb3J0cy5leHRlbmQgPSB1dGlsLmV4dGVuZChmdW5jdGlvbihiYXNlKXtcblxuICBiYXNlLnByb3RvdHlwZS5fYmxhY2tsaXN0LnB1c2goICdfZmlsdGVyJ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLCAnX3VpZCdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICwgJ19oYXNoJ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLCAnX2luZGV4Q2FjaGUnXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAsICdfc3Vic2NudCdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIClcblxuICB2YXIgX3VwZGF0ZSA9IGJhc2UucHJvdG90eXBlLl91cGRhdGVcbiAgICAsIF9ob29rID0gYmFzZS5wcm90b3R5cGUuX2hvb2tcbiAgICAsIF9yZW1vdmUgPSBiYXNlLnByb3RvdHlwZS5yZW1vdmVcblxuICB1dGlsLmRlZmluZSggYmFzZVxuICAgICwgJ3JlbW92ZScsIGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgbFxuICAgICAgICBpZih0aGlzLl9maWx0ZXIgJiYgKGwgPSB0aGlzLmxlbmd0aCkpe1xuICAgICAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCBsOyBpKyspXG4gICAgICAgICAgICBkZWxldGUgdGhpc1tpXVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBfcmVtb3ZlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cylcbiAgICAgIH1cbiAgICAsICdmaWx0ZXInLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuX2ZpbHRlclxuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uKHZhbCkge1xuICAgICAgICAgIC8vIGNvbnNvbGUubG9nKCduZXcgZmlsdGVyIFxcbiBmcm9tIC0tLT4nLCB0aGlzLl9maWx0ZXIsICdcXG4gdG8gLS0tLT4nXG4gICAgICAgICAgLy8gICAgICAgICAgICAsIHZhbFxuICAgICAgICAgIC8vICAgICAgICAgICAgKVxuICAgICAgICAgIHRoaXMuX2ZpbHRlciA9IHZhbCAvL21vZXQgb29rIHdlcmtlbiBhbHMgZGF0YSBub2cgZ2VlbiBzZWxlY3Rpb24gaXNcbiAgICAgICAgICB0aGlzLl9idWlsZCh1bmRlZmluZWQsIHRydWUpXG4gICAgICAgICAgX3VwZGF0ZS5jYWxsKCB0aGlzLCB2b2lkIDAsIHRoaXMuc3RhbXAoKSwgdm9pZCAwLCBmYWxzZVxuICAgICAgICAgICAgICAgICAgICAgICwgZmFsc2UsIHZvaWQgMFxuICAgICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgfVxuICAgICAgfVxuICAgICwgJ19ob29rJywgZnVuY3Rpb24odmFsLCBmaWx0ZXIpIHtcbiAgICAgICAgaWYgKF9ob29rKSB7XG4gICAgICAgICAgX2hvb2suY2FsbCh0aGlzLCB2YWwsIGZpbHRlcilcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXV0aWwuZW1wdHkoZmlsdGVyKSAmJiB2YWwpIHtcbiAgICAgICAgICB2YXIgc2VsZWN0aW9uID0gdGhpc1xuICAgICAgICAgIHNlbGVjdGlvbi5fc3Vic2NudCA9IDBcbiAgICAgICAgICBzZWxlY3Rpb24uX2ZpbHRlciA9IGZpbHRlclxuXG4gICAgICAgICAgc2VsZWN0aW9uLl9oYXNoID0gdXRpbEhhc2godmFsLl9wYXRoICsgSlNPTi5zdHJpbmdpZnkoXG4gICAgICAgICAgICBbIGZpbHRlci5jb25kaXRpb25cbiAgICAgICAgICAgICwgZmlsdGVyLnJhbmdlXG4gICAgICAgICAgICAsIGZpbHRlci5zb3J0XG4gICAgICAgICAgICBdKVxuICAgICAgICAgIClcbiAgICAgICAgICAvLyFvbmx5IG5lc3NlY2FyeSBzZXJ2ZXJzaWRlIVxuICAgICAgICAgIGlmICghc2VsZWN0aW9uLl91aWQpIHNlbGVjdGlvbi5fdWlkID0gc2VsZWN0aW9uLl9oYXNoXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgLCAnX2J1aWxkJywgZnVuY3Rpb24odmFsLCBub3VwZGF0ZSkge1xuICAgICAgICB2YXIgc2VsZWN0aW9uID0gdGhpc1xuICAgICAgICBcbiAgICAgICAgaWYgKCF2YWwpIHZhbCA9IHNlbGVjdGlvbi5fdmFsXG4gICAgICAgIGlmKCF2YWwpIHJldHVyblxuICAgICAgICBpZiAoc2VsZWN0aW9uLmxlbmd0aCkgc2VsZWN0aW9uLl9jbGVhcigpIFxuXG4gICAgICAgIHZhciBsaXN0ID0gW11cbiAgICAgICAgICAsIGl0ZW1zSGFuZGxlciA9IHRoaXMuX2l0ZW1zSGFuZGxlclxuICAgICAgICAgICwgZmlsdGVyID0gc2VsZWN0aW9uLl9maWx0ZXJcbiAgICAgICAgICAsIHN1YnNPYmogPSBmaWx0ZXIuc3Vic09iaiB8fCBuZXcgZXhwb3J0cy5TdWJzT2JqKHt9LCBzZWxlY3Rpb24pXG4gICAgICAgICAgLCBzdGFtcCA9IHRoaXMuc3RhbXAoKVxuICAgICAgICAgICwgc29ydCwgaXRlbVxuXG4gICAgICAgIGlmICh2YWwuX190ID09PSA0ICYmICF2YWwuX2ZpbHRlcikge1xuICAgICAgICAgIHZhbCA9IHZhbC5mcm9tO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGZpbHRlci5zb3J0KSB7XG4gICAgICAgICAgaWYgKHR5cGVvZiBmaWx0ZXIuc29ydCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIGZpbHRlci5zb3J0ID0ge1xuICAgICAgICAgICAgICBmaWVsZDogZmlsdGVyLnNvcnRcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgc29ydCA9IGZpbHRlci5zb3J0XG4gICAgICAgICAgaWYgKCFzb3J0LmZuKSB7XG4gICAgICAgICAgICBpZiAoIXNvcnQudHlwZSkgc29ydC50eXBlID0gJ3N0cmluZydcbiAgICAgICAgICAgIHNvcnQuZm4gPSBzb3J0TWFrZXJzW3NvcnQudHlwZV0oc29ydClcbiAgICAgICAgICB9XG4gICAgICAgICAgc3Vic09iai5wYXRoKHNvcnQuZmllbGQuc3BsaXQoJy4nKSwge30pLnNldCgnX3NvcnQnLCB0cnVlKVxuICAgICAgICB9XG4gICAgICAgIC8vIGNvbnNvbGUubG9nKCdidWlsZGluZz8hJylcbiAgICAgICAgaWYgKGZpbHRlci5jb25kaXRpb24pIHtcbiAgICAgICAgICAvLyBjb25zb2xlLmxvZygnZm91bmQgY29uZGl0aW9uJywgZmlsdGVyLmNvbmRpdGlvbilcbiAgICAgICAgICB2YXIgcGNudCA9IDBcbiAgICAgICAgICAgICwgcmNudCA9IDBcbiAgICAgICAgICB2YXIgY2hlY2sgPSBmaWx0ZXIuY2hlY2sgXG4gICAgICAgICAgICAgICAgIHx8ICggZmlsdGVyLmNoZWNrID0gY29uZGl0aW9ucyggZmlsdGVyLmNvbmRpdGlvblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAsIHN1YnNPYmpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgZmlsdGVyLnN1YnNPYmogPSBzdWJzT2JqXG4gICAgICAgICAgdmFsLmVhY2goZnVuY3Rpb24oZikge1xuICAgICAgICAgICAgaXRlbSA9IHRoaXNcbiAgICAgICAgICAgIGlmIChpdGVtc0hhbmRsZXIpIGl0ZW1zSGFuZGxlcihpdGVtLCBzdWJzT2JqLCBzZWxlY3Rpb24pXG4gICAgICAgICAgICBpZiAoY2hlY2soaXRlbSkpIHtcbiAgICAgICAgICAgICAgcGNudCsrXG4gICAgICAgICAgICAgIGxpc3QucHVzaChpdGVtKVxuICAgICAgICAgICAgfSBlbHNlIGlmIChzZWxlY3Rpb24uX2hhcyhpdGVtKSAhPT0gdm9pZCAwKSB7XG4gICAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKCctLS0tLS0tLSA+IHJlbW92ZWQgZnJvbSBzZWxlY3Rpb24gYnkgY29uZGl0aW9uOidcbiAgICAgICAgICAgICAgLy8gICAgICAgICAgICAgLCBpdGVtLnJhd1xuICAgICAgICAgICAgICAvLyAgICAgICAgICAgICApXG4gICAgICAgICAgICAgIHVuc3RvcmVJbmRleChpdGVtLCBzZWxlY3Rpb24pXG4gICAgICAgICAgICAgIGlmKCFub3VwZGF0ZSl7XG4gICAgICAgICAgICAgICAgX3VwZGF0ZS5jYWxsKHNlbGVjdGlvbiwgaXRlbSwgc3RhbXAsIHNlbGVjdGlvbiwgaXRlbSwgZmFsc2UsIG51bGwpXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmNudCsrXG4gICAgICAgICAgICB9IGVsc2UgeyBcbiAgICAgICAgICAgICAgcmNudCsrXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSlcbiAgICAgICAgICAvLyBjb25zb2xlLmxvZygncmFuIGNvbmRpdGlvbjogcGFzc2VkOicsIHBjbnQsICdyZWplY3RzOicsIHJjbnQpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFsLmVhY2goZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBpZiAoaXRlbXNIYW5kbGVyKSBpdGVtc0hhbmRsZXIodGhpcywgc3Vic09iaiwgc2VsZWN0aW9uKVxuICAgICAgICAgICAgbGlzdC5wdXNoKHRoaXMpXG4gICAgICAgICAgfSlcbiAgICAgICAgfVxuXG4gICAgICAgIGZpbHRlci5zdWJzT2JqID0gc3Vic09ialxuXG4gICAgICAgIGlmIChzb3J0ICYmIGxpc3QubGVuZ3RoID4gMSkge1xuICAgICAgICAgIGxpc3Quc29ydChmaWx0ZXIuc29ydC5mbilcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBpLCBpdGVtXG5cbiAgICAgICAgdmFyIHJhbmdlID0gZmlsdGVyLnJhbmdlXG4gICAgICAgIGlmIChyYW5nZSkge1xuICAgICAgICAgIGlmICghKHJhbmdlIGluc3RhbmNlb2YgQXJyYXkpKSB7XG4gICAgICAgICAgICByYW5nZSA9IGZpbHRlci5yYW5nZSA9IFswLCBmaWx0ZXIucmFuZ2VdXG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChsaXN0Lmxlbmd0aCkge1xuICAgICAgICAgICAgdmFyIG5ld2xpc3QgPSBsaXN0LnNwbGljZShyYW5nZVswXSwgcmFuZ2VbMV0pXG4gICAgICAgICAgICBmb3IgKGkgPSBsaXN0Lmxlbmd0aDsgaXRlbSA9IGxpc3RbLS1pXTspIHtcbiAgICAgICAgICAgICAgaWYoc2VsZWN0aW9uLl9oYXMoaXRlbSkgIT09IHZvaWQgMCl7XG4gICAgICAgICAgICAgICAgdW5zdG9yZUluZGV4KGl0ZW0sIHNlbGVjdGlvbilcbiAgICAgICAgICAgICAgICAvLyBpZighbm91cGRhdGUpe1xuICAgICAgICAgICAgICAgIC8vICAgX3VwZGF0ZS5jYWxsKHNlbGVjdGlvbiwgaXRlbSwgc3RhbXAsIHNlbGVjdGlvbiwgaXRlbSwgZmFsc2VcbiAgICAgICAgICAgICAgICAvLyAgICAgICAgICAgICAgICwgbnVsbFxuICAgICAgICAgICAgICAgIC8vICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgIC8vIH1cbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGlzdCA9IG5ld2xpc3RcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKHZhciBpID0gbGlzdC5sZW5ndGgsIGl0ZW07IGl0ZW0gPSBsaXN0Wy0taV07KSB7XG4gICAgICAgICAgc2VsZWN0aW9uW2ldID0gaXRlbVxuICAgICAgICAgIHZhciBpc25ldyA9IHNlbGVjdGlvbi5faGFzKGl0ZW0pID09PSB2b2lkIDBcbiAgICAgICAgICBzdG9yZUluZGV4KGl0ZW0sIHNlbGVjdGlvbiwgaSlcbiAgICAgICAgICAvLyBpZiAoaXNuZXcpIHtcbiAgICAgICAgICAvLyAgIGlmKCFub3VwZGF0ZSl7XG4gICAgICAgICAgLy8gICAgIGNvbnNvbGUubG9nKCdkb2luZyB1cGRhdGUgd2lja2VkcycpXG4gICAgICAgICAgLy8gICAgIF91cGRhdGUuY2FsbChzZWxlY3Rpb24sIGl0ZW0sIHN0YW1wLCBzZWxlY3Rpb24sIGZhbHNlLCBpdGVtLCBudWxsKSAgXG4gICAgICAgICAgLy8gICB9XG4gICAgICAgICAgLy8gfVxuICAgICAgICB9XG4gICAgICAgIHNlbGVjdGlvbi5sZW5ndGggPSBsaXN0Lmxlbmd0aFxuICAgICAgfVxuICAgICwgJ191cGRhdGUnLCBmdW5jdGlvbih2YWwsIHN0YW1wLCBmcm9tLCByZW1vdmUsIGFkZGVkLCBvbGR2YWwpIHtcblxuICAgICAgICBpZiAodGhpcy5fZmlsdGVyKSB7XG4gICAgICAgICAgIC8vIGlmKHdpbmRvdy5oZXJlKSBjb25zb2xlLmxvZygnaHVwcyBfdXBkYXRlIG9uIHNlbGVjdGlvbiEnKVxuXG4gICAgICAgICAgdmFyIHNlbGVjdGlvbiA9IHRoaXNcbiAgICAgICAgICAgICwgdXBhdGggPSBzZWxlY3Rpb24udXBkYXRlUGF0aFxuXG4gICAgICAgICAgaWYgKHVwYXRoWzBdICE9PSB2b2lkIDApIHtcbiAgICAgICAgICAgIHZhciBzaG9ydHBhdGggPSB1cGF0aC5sZW5ndGggPT09IDFcbiAgICAgICAgICAgICAgLCBpdGVtcmVtb3ZlID0gc2hvcnRwYXRoICYmIHJlbW92ZVxuICAgICAgICAgICAgICAsIGl0ZW0gPSBpdGVtcmVtb3ZlID8gc2VsZWN0aW9uLl9sZnJvbSA6IHNlbGVjdGlvbi52YWxbdXBhdGhbMF1dXG4gICAgICAgICAgICAgICwgcmVsZXZhbnRcblxuICAgICAgICAgICAgaWYgKHNlbGVjdGlvbi5fdmFsLl9maWx0ZXIpIHtcbiAgICAgICAgICAgICAgaWYgKHNlbGVjdGlvbi5fdmFsLl9oYXMoaXRlbSkgPT09IHZvaWQgMCkge1xuICAgICAgICAgICAgICAgIGlmIChzZWxlY3Rpb24uX2hhcyhpdGVtKSAhPT0gdm9pZCAwKSB7XG4gICAgICAgICAgICAgICAgICBzZWxlY3Rpb24uX2NoZWNrSXRlbShpdGVtLCBmYWxzZSwgdmFsLCBzdGFtcClcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBoaW50ID0gaXRlbXJlbW92ZSA/IGZhbHNlIDogKHNob3J0cGF0aCAmJiBhZGRlZCkgPyB2b2lkIDAgOiB1cGF0aFxuXG4gICAgICAgICAgICBpZiAoc2VsZWN0aW9uLl9jaGVja0l0ZW0oaXRlbSwgaGludCwgdmFsLCBzdGFtcCkgPT09IHRydWUpIHtcbiAgICAgICAgICAgICAgX3VwZGF0ZS5hcHBseShzZWxlY3Rpb24sIGFyZ3VtZW50cylcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gY29uc29sZS5sb2coJ2hpdCBvbiBzZWxlY3Rpb24gaXRzZWxmPyEnKVxuICAgICAgICAgICAgaWYgKCFmcm9tKSB7XG4gICAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKCdcXG4+Pj4+Pj4gaGl0IG9uIHNlbGVjdGlvbiBpdHNlbGYgKFYuRGF0YSknKVxuICAgICAgICAgICAgICBpZiAocmVtb3ZlKSB7XG4gICAgICAgICAgICAgICAgaWYgKHNlbGVjdGlvbi5sZW5ndGgpIHNlbGVjdGlvbi5fY2xlYXIoKSAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgIH1lbHNle1xuICAgICAgICAgICAgICAgIHNlbGVjdGlvbi5fYnVpbGQoKVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBfdXBkYXRlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cylcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgIC8vIGlmKHdpbmRvdy5oZXJlKSBjb25zb2xlLmxvZygnaHVwcyBfdXBkYXRlIG9uIHNlbGVjdGlvbiEnLHRoaXMpXG4gICAgICAgICAgIC8vIGNvbnNvbGUubG9nKCdTRUxFQ1QnLCB0aGlzLCBhcmd1bWVudHMsIHRoaXMuX3BhdGgpXG4gICAgICAgICAgX3VwZGF0ZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAsICdfaGFzJywgZnVuY3Rpb24oaXRlbSkge1xuICAgICAgICB2YXIgaW5kZXhDYWNoZSA9IGl0ZW0uX2luZGV4Q2FjaGVcbiAgICAgICAgICAsIHVpZCA9IHRoaXMuX3VpZFxuICAgICAgICAgICwgaWNcblxuICAgICAgICBpZiAoaW5kZXhDYWNoZSAmJiB1aWQgJiYgKGljID0gaW5kZXhDYWNoZVt1aWRdKSkge1xuICAgICAgICAgIHJldHVybiBpY1swXVxuICAgICAgICB9XG4gICAgICB9XG4gICAgLCAnX2NsZWFyJywgZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBzZWxmID0gdGhpc1xuICAgICAgICBzZWxmLmVhY2goZnVuY3Rpb24oZikge1xuICAgICAgICAgIHNlbGZbZl0gPSB2b2lkIDBcbiAgICAgICAgICBkZWxldGUgc2VsZltmXVxuICAgICAgICB9KVxuICAgICAgICBzZWxmLmxlbmd0aCA9IDBcbiAgICAgIH1cbiAgICAsICdfY2hlY2tJdGVtJywgZnVuY3Rpb24oaXRlbSwgaGludCwgdmFsLCBzdGFtcCkge1xuICAgICAgICBpZighaXRlbSkgeyByZXR1cm4gfVxuICAgICAgICAvLyBjb25zb2xlLmxvZygnX2NoZWNrSXRlbSEnLCBpdGVtLnJhdywgaGludClcbiAgICAgICAgdmFyIHNlbGVjdGlvbiA9IHRoaXNcbiAgICAgICAgICAsIGZyb20gPSBpdGVtXG4gICAgICAgICAgLCBmaWx0ZXIgPSBzZWxlY3Rpb24uX2ZpbHRlclxuICAgICAgICAgICwgc29ydCA9IGZpbHRlci5zb3J0XG4gICAgICAgICAgLCByYW5nZSA9IGZpbHRlci5yYW5nZVxuICAgICAgICAgICwgcmFuZ2VkID0gcmFuZ2UgJiYgISggIHJhbmdlWzBdID09PSAwIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICYmIHJhbmdlWzFdID49IHNlbGVjdGlvbi5fdmFsLmxlbmd0aCBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8fCBzZWxlY3Rpb24ubGVuZ3RoIDwgcmFuZ2VbMV0gLSByYW5nZVswXVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAsIHJlbW92ZWQgPSBoaW50ID09PSBmYWxzZSB8fCBpdGVtLl9yZW1vdmVkXG4gICAgICAgICAgLCBhZGRlZCwgaW5kZXgsIGlzaW5cbiAgICAgICAgICAsIHJlc3VsdCA9IGlzaW4gPSAoaW5kZXggPSBzZWxlY3Rpb24uX2hhcyhpdGVtKSkgIT09IHZvaWQgMFxuXG4gICAgICAgIHZhciBjaGVjayA9IGZpbHRlci5jaGVja1xuICAgICAgICAgICwgcGFzcyA9IHJlbW92ZWQgXG4gICAgICAgICAgICAgICAgICAgPyBmYWxzZSBcbiAgICAgICAgICAgICAgICAgICA6ICghcmFuZ2VkICYmIGhpbnQgPT09IDEpIFxuICAgICAgICAgICAgICAgICAgICAgPyBpc2luIFxuICAgICAgICAgICAgICAgICAgICAgOiAhY2hlY2sgfHwgY2hlY2soaXRlbSlcblxuICAgICAgICAvLyBjb25zb2xlLmxvZygnPT09PT09PT09PT09PT09PSBjaGVja2l0ZW0gaW4nLCBzZWxlY3Rpb24uX3BhdGgpICAgICAgICAgICAgIFxuICAgICAgICAvLyBjb25zb2xlLmxvZygnaXNpbicsIGlzaW4sICdwYXNzJywgcGFzcywgJ3Jlc3VsdCcsIHJlc3VsdClcbiAgICAgICAgLy8gY29uc29sZS5sb2coJy0tLS0tLS0tLS0gY2hlY2tlZCBpdGVtJywgcGFzcylcbiAgICAgICAgLy8gY29uc29sZS5sb2coJ3JlbW92ZWQ/JywgcmVtb3ZlZClcbiAgICAgICAgLy8gY29uc29sZS5sb2coJ3JhbmdlZD8gKHBhc3MgPT0gYWxyZWFkeSBpbiknLCAoIXJhbmdlZCAmJiBoaW50ID09PSAxKSwgaXNpbilcbiAgICAgICAgLy8gY29uc29sZS5sb2coJ29rIHRpbWUgZm9yIGNoZWNraW5nJywgY2hlY2spXG4gICAgICAgIC8vIGNvbnNvbGUubG9nKCdjb25kaXRpb25zJywgZmlsdGVyLmNvbmRpdGlvbilcbiAgICAgICAgLy8gY29uc29sZS5sb2coJ2NoZWNrPycsIGNoZWNrICYmIGNoZWNrKGl0ZW0pKVxuICAgICAgICAvLyBjb25zb2xlLmxvZygnLS0tLS0tLS0tLScpXG4gICAgICAgIFxuICAgICAgICBpZiAoaXNpbiAhPT0gcGFzcykge1xuICAgICAgICAgIGlmIChpc2luKSB7XG4gICAgICAgICAgICByZXN1bHQgPSAxXG4gICAgICAgICAgICB1bnN0b3JlSW5kZXgoaXRlbSwgc2VsZWN0aW9uKVxuICAgICAgICAgICAgcmVtb3ZlZCA9IGl0ZW1cbiAgICAgICAgICAgIHZhciBtYXJrXG4gICAgICAgICAgICB3aGlsZSAobWFyayA9IHNlbGVjdGlvblsrK2luZGV4XSkge1xuICAgICAgICAgICAgICBzZWxlY3Rpb25baW5kZXggLSAxXSA9IG1hcmtcbiAgICAgICAgICAgICAgc3RvcmVJbmRleChtYXJrLCBzZWxlY3Rpb24sIGluZGV4IC0gMSlcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIGVuZCA9IGluZGV4IC0gMVxuICAgICAgICAgICAgc2VsZWN0aW9uW2VuZF0gPSBudWxsXG4gICAgICAgICAgICBkZWxldGUgc2VsZWN0aW9uW2VuZF1cblxuICAgICAgICAgICAgdmFyIHJlcGxhY2VtZW50XG4gICAgICAgICAgICBpZiAocmFuZ2VkKSB7XG4gICAgICAgICAgICAgIGlmIChzb3J0KSB7XG4gICAgICAgICAgICAgICAgc2VsZWN0aW9uLl92YWwuZWFjaChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgIGlmICggIHNlbGVjdGlvbi5faGFzKHRoaXMpID09PSB2b2lkIDAgXG4gICAgICAgICAgICAgICAgICAgICAmJiAoIXNlbGVjdGlvbltlbmRdIHx8IHNvcnQuZm4odGhpcywgc2VsZWN0aW9uW2VuZF0pIDwgMCkgXG4gICAgICAgICAgICAgICAgICAgICAmJiAoIWNoZWNrIHx8IGNoZWNrKHRoaXMpKVxuICAgICAgICAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlcGxhY2VtZW50ID0gc2VsZWN0aW9uW2VuZF0gPSB0aGlzXG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBzZWxlY3Rpb24uX3ZhbC5lYWNoKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgaWYgKCBzZWxlY3Rpb24uX2hhcyh0aGlzKSA9PT0gdm9pZCAwIFxuICAgICAgICAgICAgICAgICAgICAgJiYgKCFjaGVjayB8fCBjaGVjayh0aGlzKSlcbiAgICAgICAgICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVwbGFjZW1lbnQgPSBzZWxlY3Rpb25bZW5kXSA9IHRoaXNcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIXJlcGxhY2VtZW50KSB7XG4gICAgICAgICAgICAgIHNlbGVjdGlvbi5sZW5ndGgtLVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgc3RvcmVJbmRleChyZXBsYWNlbWVudCwgc2VsZWN0aW9uLCBpbmRleCAtIDEpXG4gICAgICAgICAgICAgIGFkZGVkID0gcmVwbGFjZW1lbnRcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIG5ld2luZGV4XG4gICAgICAgICAgICBpZiAoc29ydCkge1xuICAgICAgICAgICAgICB2YXIgc29ydGZuID0gc29ydC5mblxuICAgICAgICAgICAgICBpZiAoc2VsZWN0aW9uLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHNlbGVjdGlvbi5lYWNoKGZ1bmN0aW9uKGYpIHtcbiAgICAgICAgICAgICAgICAgIGlmIChzb3J0Zm4oaXRlbSwgdGhpcykgPCAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXdpbmRleCA9IGZcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmIChuZXdpbmRleCAhPT0gdm9pZCAwKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gMVxuICAgICAgICAgICAgICAgIG5ld2luZGV4ID0gTnVtYmVyKG5ld2luZGV4KVxuICAgICAgICAgICAgICAgIHN0b3JlSW5kZXgoaXRlbSwgc2VsZWN0aW9uLCBuZXdpbmRleClcbiAgICAgICAgICAgICAgICBhZGRlZCA9IGl0ZW1cbiAgICAgICAgICAgICAgICBpZiAocmFuZ2VkKSB7XG4gICAgICAgICAgICAgICAgICByZW1vdmVkID0gc2VsZWN0aW9uW3NlbGVjdGlvbi5sZW5ndGggLSAxXVxuICAgICAgICAgICAgICAgICAgdW5zdG9yZUluZGV4KHJlbW92ZWQsIHNlbGVjdGlvbilcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgdGhpcy5sZW5ndGgrK1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgaW5kZXggPSBzZWxlY3Rpb24ubGVuZ3RoIC0gMlxuICAgICAgICAgICAgICAgIHdoaWxlIChpbmRleCA+PSBuZXdpbmRleCkge1xuICAgICAgICAgICAgICAgICAgc3RvcmVJbmRleChzZWxlY3Rpb25baW5kZXhdLCBzZWxlY3Rpb24sIGluZGV4ICsgMSlcbiAgICAgICAgICAgICAgICAgIHNlbGVjdGlvbltpbmRleCArIDFdID0gc2VsZWN0aW9uW2luZGV4LS1dXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHNlbGVjdGlvbltuZXdpbmRleF0gPSBpdGVtXG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAoIXJhbmdlZCkge1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IDFcbiAgICAgICAgICAgICAgICBuZXdpbmRleCA9IHNlbGVjdGlvbi5sZW5ndGgrK1xuICAgICAgICAgICAgICAgIHNlbGVjdGlvbltuZXdpbmRleF0gPSBpdGVtXG4gICAgICAgICAgICAgICAgc3RvcmVJbmRleChpdGVtLCBzZWxlY3Rpb24sIG5ld2luZGV4KVxuICAgICAgICAgICAgICAgIGFkZGVkID0gaXRlbVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKCFyYW5nZWQpIHtcbiAgICAgICAgICAgICAgcmVzdWx0ID0gMVxuICAgICAgICAgICAgICBuZXdpbmRleCA9IHNlbGVjdGlvbi5sZW5ndGgrK1xuICAgICAgICAgICAgICBzZWxlY3Rpb25bbmV3aW5kZXhdID0gaXRlbVxuICAgICAgICAgICAgICBzdG9yZUluZGV4KGl0ZW0sIHNlbGVjdGlvbiwgbmV3aW5kZXgpXG4gICAgICAgICAgICAgIGFkZGVkID0gaXRlbVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChpc2luICYmIHNvcnQpIHtcbiAgICAgICAgICAvLyBjb25zb2xlLmxvZygnaXNpbiArIHNvcnQhIHJlc29ydD8nKVxuICAgICAgICAgIGlmIChoaW50Lmxlbmd0aCAmJiBzb3J0LmZpZWxkKSB7XG4gICAgICAgICAgICBpZiAofnNvcnQuZmllbGQuaW5kZXhPZignLicpKSB7XG4gICAgICAgICAgICAgIHZhciBzb3J0cGF0aCA9IHNvcnQuZmllbGQuc3BsaXQoJy4nKVxuICAgICAgICAgICAgICBpZiAoIXV0aWwuY29tcGFyZUFycmF5cyhoaW50LnNsaWNlKDEpLCBzb3J0cGF0aCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGlmIChoaW50WzFdICE9PSBzb3J0LmZpZWxkKSByZXR1cm4gcmVzdWx0XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIG5ld2luZGV4XG4gICAgICAgICAgc2VsZWN0aW9uLmVhY2goZnVuY3Rpb24oZikge1xuICAgICAgICAgICAgaWYgKGYgIT0gaW5kZXgpIHtcbiAgICAgICAgICAgICAgdmFyIHMgPSBzb3J0LmZuKGl0ZW0sIHRoaXMpXG4gICAgICAgICAgICAgIGlmIChzID09PSAtMSkge1xuICAgICAgICAgICAgICAgIGlmIChmID09IGluZGV4ICsgMSkgcmV0dXJuIHRydWVcbiAgICAgICAgICAgICAgICBuZXdpbmRleCA9IGYgPCBpbmRleCA/IGYgOiBmIC0gMVxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlXG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAoZiA+PSBpbmRleCArIDEgJiYgcyA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlXG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAoZiA+IGluZGV4KSB7XG4gICAgICAgICAgICAgICAgbmV3aW5kZXggPSBmXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgICAvLyBjb25zb2xlLmxvZygnbmV3aW5kZXgnLCBuZXdpbmRleClcbiAgICAgICAgICBpZiAobmV3aW5kZXggIT09IHZvaWQgMCkge1xuICAgICAgICAgICAgcmVzdWx0ID0gMVxuICAgICAgICAgICAgdmFyIHRtcFxuICAgICAgICAgICAgaWYgKGluZGV4ID4gbmV3aW5kZXgpIHtcbiAgICAgICAgICAgICAgd2hpbGUgKGluZGV4ID4gbmV3aW5kZXgpIHtcbiAgICAgICAgICAgICAgICB0bXAgPSBzZWxlY3Rpb25baW5kZXhdID0gc2VsZWN0aW9uWy0taW5kZXhdXG4gICAgICAgICAgICAgICAgaWYgKHRtcCkgc3RvcmVJbmRleCh0bXAsIHNlbGVjdGlvbiwgaW5kZXggKyAxKVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB3aGlsZSAoaW5kZXggPCBuZXdpbmRleCkge1xuICAgICAgICAgICAgICAgIHRtcCA9IHNlbGVjdGlvbltpbmRleF0gPSBzZWxlY3Rpb25bKytpbmRleF1cbiAgICAgICAgICAgICAgICBpZiAodG1wKSBzdG9yZUluZGV4KHRtcCwgc2VsZWN0aW9uLCBpbmRleCAtIDEpXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNlbGVjdGlvbltuZXdpbmRleF0gPSBpdGVtXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIGVuZCA9IHNlbGVjdGlvbi5sZW5ndGggLSAxXG5cbiAgICAgICAgICBpZiAoICByYW5nZWQgXG4gICAgICAgICAgICAgJiYgKG5ld2luZGV4ID09IGVuZCB8fCBuZXdpbmRleCA9PT0gdm9pZCAwIFxuICAgICAgICAgICAgICYmIGluZGV4ID09IGVuZClcbiAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgIHZhciByZXBsYWNlZFxuICAgICAgICAgICAgc2VsZWN0aW9uLl92YWwuZWFjaChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgaWYgKCAgc2VsZWN0aW9uLl9oYXModGhpcykgPT09IHZvaWQgMCBcbiAgICAgICAgICAgICAgICAgJiYgc29ydC5mbih0aGlzLCBpdGVtKSA9PT0gLTEgXG4gICAgICAgICAgICAgICAgICYmICghY2hlY2sgfHwgY2hlY2sodGhpcykpXG4gICAgICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgIGlmICghcmVwbGFjZWQpIHJlcGxhY2VkID0gaXRlbVxuICAgICAgICAgICAgICAgIHNlbGVjdGlvbltlbmRdID0gaXRlbSA9IHRoaXNcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIHN0b3JlSW5kZXgoaXRlbSwgc2VsZWN0aW9uLCBlbmQpXG4gICAgICAgICAgICBpZiAocmVwbGFjZWQpIHtcbiAgICAgICAgICAgICAgdW5zdG9yZUluZGV4KHJlcGxhY2VkLCBzZWxlY3Rpb24pXG4gICAgICAgICAgICAgIHJlbW92ZWQgPSByZXBsYWNlZFxuICAgICAgICAgICAgICBhZGRlZCA9IGl0ZW1cbiAgICAgICAgICAgICAgcmVzdWx0ID0gMVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSBpZiAobmV3aW5kZXggIT09IHZvaWQgMCkge1xuICAgICAgICAgICAgc3RvcmVJbmRleChpdGVtLCBzZWxlY3Rpb24sIE51bWJlcihuZXdpbmRleCkpXG4gICAgICAgICAgfVxuXG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlc3VsdCA9PT0gMSkge1xuICAgICAgICAgIC8vIGNvbnNvbGUubG9nKCd1cGRhdGUgZnJvbSBfY2hlY2tJdGVtIScpXG4gICAgICAgICAgc2VsZWN0aW9uLl9fdXBkYXRlKHZhbCwgc3RhbXAsIGZyb20sIHJlbW92ZWQsIGFkZGVkKVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHRcbiAgICAgIH1cbiAgICApXG5cbn0pXG5cbnZhciBzdG9yZUluZGV4ID0gZXhwb3J0cy5zdG9yZUluZGV4ID0gZnVuY3Rpb24oaXRlbSwgc2VsZWN0aW9uLCBpbmRleCkge1xuICAvLyBjb25zb2xlLmxvZygnc3RvcmVJbmRleCEgaXRlbScsIGl0ZW0uX25hbWUsICdAJywgaW5kZXgpXG4gIHZhciBpbmRleENhY2hlID0gaXRlbS5faW5kZXhDYWNoZVxuICAgICwgaWNcbiAgaWYgKGluZGV4Q2FjaGUpIHtcbiAgICBpYyA9IGluZGV4Q2FjaGVbc2VsZWN0aW9uLl91aWRdXG4gICAgaWYgKGljKSB7XG4gICAgICBpY1sxXSA9IGljWzBdXG4gICAgICBpY1swXSA9IGluZGV4XG4gICAgfSBlbHNlIHtcbiAgICAgIGluZGV4Q2FjaGVbc2VsZWN0aW9uLl91aWRdID0gW2luZGV4XVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBpdGVtLl9pbmRleENhY2hlID0ge31cbiAgICBpdGVtLl9pbmRleENhY2hlW3NlbGVjdGlvbi5fdWlkXSA9IFtpbmRleF1cbiAgfVxufVxuXG52YXIgdW5zdG9yZUluZGV4ID0gZXhwb3J0cy51bnN0b3JlSW5kZXggPSBmdW5jdGlvbihpdGVtLCBzZWxlY3Rpb24pIHtcbiAgdmFyIGluZGV4Q2FjaGUgPSBpdGVtLl9pbmRleENhY2hlXG4gIGlmIChpbmRleENhY2hlKSB7XG4gICAgdmFyIGljID0gaW5kZXhDYWNoZVtzZWxlY3Rpb24uX3VpZF1cbiAgICBpY1sxXSA9IGljWzBdXG4gICAgaWNbMF0gPSB2b2lkIDBcbiAgfVxufVxuXG52YXIgc29ydE1ha2VycyA9IHtcbiAgbnVtYmVyOiBmdW5jdGlvbihzb3J0KSB7XG4gICAgdmFyIGZpZWxkID0gc29ydC5maWVsZFxuICAgIHJldHVybiBmdW5jdGlvbihhLCBiKSB7XG4gICAgICB2YXIgdmEgPSBhW2ZpZWxkXSAmJiBhW2ZpZWxkXS52YWxcbiAgICAgICAgLCB2YiA9IGJbZmllbGRdICYmIGJbZmllbGRdLnZhbFxuICAgICAgaWYgKHZhID09PSB2b2lkIDAgfHwgdmIgPT09IHZvaWQgMCkge1xuICAgICAgICByZXR1cm4gdmEgPT09IHZiIFxuICAgICAgICAgICAgICAgPyAwIFxuICAgICAgICAgICAgICAgOiB2YSA9PT0gdm9pZCAwIFxuICAgICAgICAgICAgICAgICA/IDEgXG4gICAgICAgICAgICAgICAgIDogLTFcbiAgICAgIH1cbiAgICAgIHJldHVybiBzb3J0Lm9yZGVyIFxuICAgICAgICAgICAgID8gKHZhIC0gdmIpICogLTEgXG4gICAgICAgICAgICAgOiB2YSAtIHZiXG4gICAgfVxuICB9LFxuICBzdHJpbmc6IGZ1bmN0aW9uKHNvcnQpIHtcbiAgICB2YXIgZmllbGQgPSBzb3J0LmZpZWxkXG4gICAgaWYgKH5maWVsZC5pbmRleE9mKCcuJykpIHtcbiAgICAgIHZhciBwYXRoID0gZmllbGQuc3BsaXQoJy4nKVxuICAgICAgcmV0dXJuIGZ1bmN0aW9uKGEsIGIpIHtcbiAgICAgICAgYSA9IGdldERvdEZpZWxkVmFsKGEsIHBhdGgpXG4gICAgICAgIGIgPSBnZXREb3RGaWVsZFZhbChiLCBwYXRoKVxuICAgICAgICBpZiAoYSA9PT0gdm9pZCAwIHx8IGIgPT09IHZvaWQgMCkge1xuICAgICAgICAgIHJldHVybiBhID09PSBiIFxuICAgICAgICAgICAgICAgICA/IDAgXG4gICAgICAgICAgICAgICAgIDogYSA9PT0gdm9pZCAwIFxuICAgICAgICAgICAgICAgICAgID8gMSBcbiAgICAgICAgICAgICAgICAgICA6IC0xXG4gICAgICAgIH1cbiAgICAgICAgdmFyIHJlID0gYSA+IGIgXG4gICAgICAgICAgICAgICAgID8gMSBcbiAgICAgICAgICAgICAgICAgOiBhID09PSBiIFxuICAgICAgICAgICAgICAgICAgID8gMCBcbiAgICAgICAgICAgICAgICAgICA6IC0xXG4gICAgICAgIHJldHVybiBzb3J0Lm9yZGVyID8gcmUgKiAtMSA6IHJlXG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbihhLCBiKSB7XG4gICAgICAgIGEgPSBnZXRGaWVsZFZhbChhLCBmaWVsZClcbiAgICAgICAgYiA9IGdldEZpZWxkVmFsKGIsIGZpZWxkKVxuICAgICAgICB2YXIgd2Vha0EgPSBhID09PSB2b2lkIDAgfHwgYSA9PT0gbnVsbFxuICAgICAgICAgICwgd2Vha0IgPSBiID09PSB2b2lkIDAgfHwgYiA9PT0gbnVsbFxuICAgICAgICBpZiAod2Vha0EgfHwgd2Vha0IpIHtcbiAgICAgICAgICByZXR1cm4gYSA9PT0gYiA/IDAgOiB3ZWFrQSA/IDEgOiAtMVxuICAgICAgICB9XG4gICAgICAgIHZhciByZSA9IGEgPiBiIFxuICAgICAgICAgICAgICAgICA/IDEgXG4gICAgICAgICAgICAgICAgIDogYSA9PT0gYiBcbiAgICAgICAgICAgICAgICAgICA/IDAgXG4gICAgICAgICAgICAgICAgICAgOiAtMVxuICAgICAgICByZXR1cm4gc29ydC5vcmRlciA/IHJlICogLTEgOiByZVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBnZXRGaWVsZFZhbChvYmosIGZpZWxkKSB7XG4gIHZhciB2ID0gb2JqLnZhbFxuICByZXR1cm4gdiAmJiB2W2ZpZWxkXSAmJiB2W2ZpZWxkXS52YWxcbn1cblxuZnVuY3Rpb24gZ2V0RG90RmllbGRWYWwob2JqLCBmaWVsZCkge1xuICB2YXIgdiA9IG9iai5wYXRoKGZpZWxkKVxuICByZXR1cm4gdiAmJiB2LnZhbFxufVxuXG5mdW5jdGlvbiBwdXRTb3J0KHBhdGgpIHtcbiAgdmFyIG9iaiA9IHBhcnQgPSB7fVxuICBmb3IgKHZhciBpID0gMCwgbCA9IHBhdGgubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgcGFydCA9IHBhcnRbcGF0aFtpXV0gPSB7XG4gICAgICBfdXA6IHBhcnRcbiAgICB9XG4gIH1cbiAgcGFydC5fc29ydCA9IHRydWVcbiAgcmV0dXJuIG9ialxufVxuIiwiLy9WIG9ubHkgdXNlZCBhcyBhIHJlZmVyZW5jZSBub3cuLi5cbiIsIi8qIVxuICogQGxpY2Vuc2UgQ29weXJpZ2h0IChjKSAyMDEyLTIwMTQsIFZpZ291ci4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIEBhdXRob3I6IEppbSBkZSBCZWVyLCBqaW1Admlnb3VyLmlvXG4gKi9cbnZhciB1dGlsID0gcmVxdWlyZSgnLi4vdXRpbCcpLFxuICBvYmplY3QgPSByZXF1aXJlKCcuLycpO1xuXG51dGlsLmRlZmluZShvYmplY3QsXG4gIC8qKlxuICAgKiBWLk9iamVjdCdzIGVxdWl2YWxlbnQgdG8gQXJyYXkucHVzaCgpXG4gICAqIEBtZXRob2QgcHVzaFxuICAgKiBAcGFyYW0gIHtBcmd1bWVudHN9ICBUaGUgaXRlbShzKSB0byBhZGQgdG8gdGhlIGFycmF5XG4gICAqIEByZXR1cm4ge051bWJlcn0gICAgIFRoZSBuZXcgbGVuZ3RoIG9mIHRoZSBhcnJheVxuICAgKi9cbiAgJ3B1c2gnLCBmdW5jdGlvbigpIHtcbiAgICBpZiAodGhpcy5fX3QgPT09IDEpIHtcbiAgICAgIGlmICh0aGlzLmxlbmd0aCA9PT0gdm9pZCAwKSB7XG4gICAgICAgIHRoaXMubGVuZ3RoID0gMDtcbiAgICAgIH1cbiAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICB0aGlzLl9wdXNoKGFyZ3VtZW50c1tpXSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy5sZW5ndGg7XG4gICAgfVxuICB9LFxuICAnX3B1c2gnLCBmdW5jdGlvbih2YWwsIHZvYmosIHN0YW1wLCBub3VwZGF0ZSwgZnJvbSkge1xuICAgIC8vYW1lLCB2YWwsIHZvYmosIHN0YW1wLCBub3VwZGF0ZSwgZnJvbVxuICAgIHRoaXMubGVuZ3RoKys7XG4gICAgdGhpcy5zZXQoKHRoaXMubGVuZ3RoIC0gMSksIHZhbCwgdm9iaiwgc3RhbXAsIG5vdXBkYXRlLCBmcm9tKTtcbiAgICByZXR1cm4gdGhpc1t0aGlzLmxlbmd0aCAtIDFdO1xuICB9LFxuICAvKipcbiAgICogVi5PYmplY3QncyBlcXVpdmFsZW50IHRvIEFycmF5LnBvcCgpXG4gICAqIEBtZXRob2QgcG9wXG4gICAqIEByZXR1cm4geyp9ICBUaGUgcmVtb3ZlZCBhcnJheSBpdGVtXG4gICAqL1xuICAncG9wJywgZnVuY3Rpb24oKSB7XG4gICAgaWYgKHRoaXMuX190ID09PSAxKSB7XG4gICAgICB2YXIgbCA9IHRoaXMubGVuZ3RoXG4gICAgICBpZihsICE9PSAwKXtcbiAgICAgICAgdCA9IHRoaXNbbCAtIDFdO1xuICAgICAgICB0aGlzLmxlbmd0aC0tO1xuICAgICAgICB0LnJlbW92ZSgpO1xuICAgICAgfVxuICAgICAgLy8gcmV0dXJuIHQ7IC8vcHJldHR5IHdlaXJkIHNpbmNlIHRoaXMgb2JqZWN0IGFsd2F5cyBoYXMgdmFsdWUgbnVsbDtcbiAgICB9XG4gIH0sXG4gIC8qKlxuICAgKiBWLk9iamVjdCdzIGVxdWl2YWxlbnQgdG8gQXJyYXkuc3BsaWNlKClcbiAgICogQG1ldGhvZCBzcGxpY2VcbiAgICogQHBhcmFtICB7TnVtYmVyfSAgICBpbmRleCAgIEFuIGludGVnZXIgdGhhdCBzcGVjaWZpZXMgYXQgd2hhdCBwb3NpdGlvbiB0byBhZGQvcmVtb3ZlIGl0ZW1zLCBVc2UgbmVnYXRpdmUgdmFsdWVzIHRvIHNwZWNpZnkgdGhlIHBvc2l0aW9uIGZyb20gdGhlIGVuZCBvZiB0aGUgYXJyYXlcbiAgICogQHBhcmFtICB7TnVtYmVyfSAgICBob3dtYW55IFRoZSBudW1iZXIgb2YgaXRlbXMgdG8gYmUgcmVtb3ZlZC4gSWYgc2V0IHRvIDAsIG5vIGl0ZW1zIHdpbGwgYmUgcmVtb3ZlZFxuICAgKiBAcGFyYW0gIHtBcmd1bWVudHN9ICAgICAgICAgVGhlIG5ldyBpdGVtKHMpIHRvIGJlIGFkZGVkIHRvIHRoZSBhcnJheVxuICAgKiBAcmV0dXJuIHtBcnJheX0gICAgICAgICAgICAgQSBuZXcgYXJyYXkgY29udGFpbmluZyB0aGUgcmVtb3ZlZCBpdGVtcywgaWYgYW55XG4gICAqL1xuICAnc3BsaWNlJywgZnVuY3Rpb24oaW5kZXgsIGhvd21hbnkpIHsgLy9jYW4gYmVjb21lIHNob3J0ZXI7XG4gICAgaWYgKGluZGV4ID4gLTEgJiYgdGhpcy5fX3QgPT09IDEpIHsgLy9ob3cgbWFueSBhbmQgLWkgYXJlIGlnbm9yZWRcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gdGhpcy5sZW5ndGgsIHNoaWZ0OyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIGlmIChzaGlmdCkge1xuICAgICAgICAgIGlmIChpID09PSBsIC0gMSkge1xuICAgICAgICAgICAgLy8gdGhpcy5sZW5ndGgtLTtcbiAgICAgICAgICAgIHRoaXNbaV0gPSBudWxsO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzW2ldID0gdGhpc1tpICsgMV07XG4gICAgICAgICAgICB0aGlzW2ldLl9uYW1lID0gaTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKGkgPT09IGluZGV4KSB7XG4gICAgICAgICAgICBpZiAoaSA9PT0gbCAtIDEpIHtcbiAgICAgICAgICAgICAgdGhpcy5wb3AoKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHNoaWZ0ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgdGhpcy5sZW5ndGgtLTtcbiAgICAgICAgICAgICAgdGhpc1tpXS5yZW1vdmUoKTtcbiAgICAgICAgICAgICAgdGhpc1tpXSA9IHRoaXNbaSArIDFdO1xuICAgICAgICAgICAgICB0aGlzW2ldLl9uYW1lID0gaTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0sXG4gIC8qKlxuICAgKiBBZGRzIHZhbHVlIHRvIGFycmF5IGlmIGl0IGlzIG5vdCBjb250YWluZWQgaW4gYXJyYXksIGV4ZWN1dGVzIGhhbmRsZXIgb24gZW5jb3VudGVyaW5nIHZhbCBpbiBhcnJheVxuICAgKiBAbWV0aG9kIGluY2x1ZGVcbiAgICogQHBhcmFtICB7Kn0gICAgICAgICB2YWwgICAgICAgVmFsdWUgdG8gYWRkXG4gICAqIEBwYXJhbSAge0Z1bmN0aW9ufSAgW2hhbmRsZXJdIEZ1bmN0aW9uIHRvIGV4ZWN1dGUgb24gZW5jb3VudGVyaW5nIHZhbCBpbiBhcnJheVxuICAgKiBAcmV0dXJuIHtCb29sZWFufSAgICAgICAgICAgICBUcnVlL2ZhbHNlXG4gICAqL1xuICAnaW5jbHVkZScsIGZ1bmN0aW9uKHZhbCwgaGFuZGxlciwgYXJyKSB7XG4gICAgcmV0dXJuIHV0aWwuaW5jbHVkZSh0aGlzLCB2YWwsIGhhbmRsZXIsIGFycik7XG4gIH0sXG4gICdjb25jYXQnLCBmdW5jdGlvbih2YWwpIHsgXG5cbiAgICAvLyBpZighdmFsKSB7XG4gICAgLy8gICByZXR1cm5cbiAgICAvLyB9XG4gICAgXG4gICAgdmFyIGFyciA9IHRoaXNcbiAgICB2YXIgbGwgPSBhcnIubGVuZ3RoO1xuICAgIGZvciAodmFyIGkgPSAwLCBsID0gdmFsLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgYXJyLl9wdXNoKHZhbFtpXSwgZmFsc2UsIGZhbHNlLCB0cnVlKTtcbiAgICB9XG4gICAgYXJyLl91cGRhdGUodmFsKTtcbiAgICByZXR1cm4gYXJyO1xuICB9LFxuICAnbW92ZUl0ZW0nLCBmdW5jdGlvbihmcm9tLCB0bykgeyB2YXIgYXJyID0gdGhpc1xuICAgIGlmKHRvID09PSB2b2lkIDApIHRvID0gYXJyLmxlbmd0aCAtIDFcbiAgICBpZihmcm9tID09PSB0bykgcmV0dXJuXG4gICAgdmFyIG1vdmVyID0gYXJyW2Zyb21dXG4gICAgaWYoIW1vdmVyKSByZXR1cm5cbiAgICB2YXIgc3RlcCA9IGZyb20gPCB0byA/IDEgOiAtMVxuICAgIGRvIHtcbiAgICAgIGFycltmcm9tXSA9IG51bGxcbiAgICAgIGFyci5zZXQoZnJvbSwgYXJyW2Zyb20gKyBzdGVwXSwgdHJ1ZSlcbiAgICAgIGZyb20gKz0gc3RlcFxuICAgIH0gd2hpbGUoZnJvbSAhPT0gdG8pXG4gICAgYXJyW3RvXSA9IG51bGxcbiAgICBhcnIuc2V0KHRvLCBtb3ZlciwgdHJ1ZSlcbiAgfVxuKVxuIiwiLyohXG4gKiBAbGljZW5zZSBDb3B5cmlnaHQgKGMpIDIwMTItMjAxNCwgVmlnb3VyLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogQGF1dGhvcjogSmltIGRlIEJlZXIsIGppbUB2aWdvdXIuaW9cbiAqL1xudmFyIHV0aWwgPSByZXF1aXJlKCcuLi91dGlsJylcblxuLyoqXG4gKiBGbGFncyBhcmUgc3BlY2lhbCBwcm9wZXJ0aWVzIHdoZXJlIGEgZnVuY3Rpb24gaXMgY2FsbGVkXG4gKiBkaWZmZXJlbnQgZnJvbSBvcGVyYXRvcnMgc2luY2UgZmxhZ3MgbWF5IGhhdmUgbm90aGluZyB0byBkbyB3aXRoIHZhbHVlIGNhbGN1bGF0aW9uXG4gKiBleHRlbmRzIGRlZmF1bHQgc2V0IGZyb20gVi5PYmplY3RcbiAqIEBwcm9wZXJ0eVxuICovXG4vKipcbiAqIEFkZHMgbmV3IGZsYWdzIHRvIFYuT2JqZWN0XG4gKiBAbWV0aG9kIGV4dGVuZFxuICogQHBhcmFtICB7T2JqZWN0fSAgIG9iamVjdCBWLk9iamVjdCB0byBleHRlbmQgZmxhZ3MgdG9cbiAqIEBwYXJhbSAge0Z1bmN0aW9ufSBbc2V0XSAgW2Rlc2NyaXB0aW9uXVxuICogQHJldHVybiB7W3R5cGVdfSAgICAgICAgICBbZGVzY3JpcHRpb25dXG4gKi9cbmV4cG9ydHMuZXh0ZW5kID0gdXRpbC5leHRlbmQoZnVuY3Rpb24ob2JqZWN0LCBzZXQpIHtcbiAgXG4gIC8vbXVsdGlwbGUgZmxhZ3MgXG4gIFxuICAvLyBhYnN0cmFjdCBmbGFncyBhcnJheSBhd2F5IVxuICAvLyBcbiAgLy8gZmxhZ3Mgb2JqZWN0IC0tPiBmaWVsZFxuICAvLyBcbiAgLy8gY2hlY2sgL3cgY2FzZXNcbiAgLy8gY2hlY2sgL3cgcGFyZW50XG4gIC8vIGZsYWc0IGlzIGR5bmFtaWMgaGFzIHN0YWNrIGFzIG9wdGlvblxuICBcbiAgdmFyIF9wcm90byA9IG9iamVjdC5wcm90b3R5cGVcbiAgICAsIF9jb252ZXJ0ID0gX3Byb3RvLmNvbnZlcnRcbiAgICAsIF9zZXQgPSBfcHJvdG8uX3NldFxuICAgICwgX3JlbW92ZSA9IF9wcm90by5fcmVtb3ZlXG4gICAgLCBfY2hlY2sgPSBmdW5jdGlvbihuYW1lKSB7XG4gICAgICB2YXIgZjtcbiAgICAgIGZvciAodmFyIGkgaW4gb2JqZWN0LmZsYWdzLmR5bmFtaWMpIHtcbiAgICAgICAgZiA9IG9iamVjdC5mbGFncy5keW5hbWljW2ldKG5hbWUpXG4gICAgICAgIGlmKGYpIGJyZWFrXG4gICAgICB9XG4gICAgICByZXR1cm4gZlxuICAgIH1cbiAgICAsIGNoZWNrSWZGbGFnT3ZlcndyaXRlID0gZnVuY3Rpb24odmFsKSB7XG4gICAgICBmb3IodmFyIGkgaW4gdmFsKSB7XG4gICAgICAgIGlmKG9iamVjdC5mbGFnc1tpXSB8fCBfY2hlY2soaSkpIHJldHVybiB0cnVlXG4gICAgICB9XG4gICAgfVxuXG4gIGlmICghc2V0KSBzZXQgPSBfcHJvdG8uc2V0XG5cbiAgX3Byb3RvLl9ibGFja2xpc3QucHVzaCgnX2ZsYWcnKTtcbiAgdXRpbC5kZWZpbmUob2JqZWN0LFxuICAgIC8qKlxuICAgICAqIFtkZXNjcmlwdGlvbl1cbiAgICAgKiBAbWV0aG9kIGNvbnZlcnRcbiAgICAgKiBAcGFyYW0gIHtbdHlwZV19IHZhbCBbZGVzY3JpcHRpb25dXG4gICAgICogQHJldHVybiB7W3R5cGVdfSAgICAgW2Rlc2NyaXB0aW9uXVxuICAgICAqL1xuICAgICdjb252ZXJ0JywgZnVuY3Rpb24odmFsKSB7XG5cbiAgICAgIC8vaGllciBvb2sgd2VlciBmb3JcbiAgICAgIHZhciBvYmogPSBfY29udmVydC5jYWxsKHRoaXMsIHZhbCk7XG5cbiAgICAgIC8vIGNvbnNvbGUubG9nKCdJIFNIT1VMRCBCRSBDT05WRVJUSU5HIScsIHZhbCwgb2JqLCB0aGlzLl9mbGFnKVxuXG5cblxuXG5cbiAgICAgIGlmICh0aGlzLl9mbGFnICYmICghdmFsIHx8ICF1dGlsLmlzT2JqKHZhbCkgfHwgdmFsLnZhbCB8fCBjaGVja0lmRmxhZ092ZXJ3cml0ZSh2YWwpICkpIHtcblxuICAgICAgICAvLyBjb25zb2xlLmxvZygnSSBTSE9VTEQgQkUgQ09OVkVSVElORyEgc3RlcCAyJylcblxuICAgICAgICAvL2ZmIHVzZVZhbCBnZWJydWlrZW5cblxuICAgICAgICBmb3IodmFyIGkgaW4gdGhpcy5fZmxhZykge1xuICAgICAgICAgIHZhciBmbGFnID0gdGhpcy5fZmxhZ1tpXVxuICAgICAgICAgIGlmICghZmxhZ1s0XSB8fCAhZmxhZ1s0XS5zdGFjaykge1xuXG4gICAgICAgICAgICAvLyBjb25zb2xlLmxvZygnQ09OVkVSVCBORUVEUyBGSVgnLnJlZC5ib2xkLmludmVyc2UpXG5cbiAgICAgICAgICAgIGlmIChvYmogPT09IGZsYWdbMV0pIHtcbiAgICAgICAgICAgICAgLy8gY29uc29sZS5sb2coJzIgQ09OVkVSVCBORUVEUyBGSVgnLnJlZC5ib2xkLmludmVyc2UpXG4gICAgICAgICAgICAgIG9iaiA9IHt9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG9iai52YWwgPT09IGZsYWdbMV0pIHtcbiAgICAgICAgICAgICAgLy8gY29uc29sZS5sb2coJzMgQ09OVkVSVCBORUVEUyBGSVgnLnJlZC5ib2xkLmludmVyc2UpXG4gICAgICAgICAgICAgIGRlbGV0ZSBvYmoudmFsO1xuICAgICAgICAgICAgfVxuXG5cbiAgICAgICAgICAgIG9ialtmbGFnWzBdXSA9IGZsYWdbMl1cbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvL3N0aWxsIGhhdmUgdG8gdGFrZSBjYXJlIG9mIHRoaXMgc2l0dWF0aW9uXG4gICAgICAgICAgICAvLyBjb25zb2xlLmVycm9yKCd0cnlpbmcgY29udmVydCBhIHN0YWNrLWR5bmFtaWMgZmxhZycsIGZsYWcpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGNvbnNvbGUubG9nKCdDT05WRVJURUQgLS0tLT4nLG9iailcblxuICAgICAgfVxuICAgICAgcmV0dXJuIG9iajtcbiAgICB9LFxuICAgIC8qKlxuICAgICAgQHByb3BlcnR5IF9fZmxhZ3NfX1xuICAgICovXG4gICAgJ19fZmxhZ3NfXycsIHt9LFxuICAgIC8qKlxuICAgICAqIFtkZXNjcmlwdGlvbl1cbiAgICAgKiBAbWV0aG9kIHJlbW92ZVxuICAgICAqIEBwYXJhbSAge1t0eXBlXX0gZnJvbSAgIFtkZXNjcmlwdGlvbl1cbiAgICAgKiBAcGFyYW0gIHtbdHlwZV19IHVwZGF0ZSBbZGVzY3JpcHRpb25dXG4gICAgICogQHBhcmFtICB7W3R5cGVdfSBzdGFtcCAgW2Rlc2NyaXB0aW9uXVxuICAgICAqIEByZXR1cm4ge1t0eXBlXX0gICAgICAgIFtkZXNjcmlwdGlvbl1cbiAgICAgKi9cbiAgICAnX3JlbW92ZScsIGZ1bmN0aW9uKGZyb20sIHVwZGF0ZSwgc3RhbXApIHtcblxuICAgICAgaWYodGhpcy5fZmxhZykge1xuICAgICAgICBmb3IodmFyIGkgaW4gdGhpcy5fZmxhZykge1xuICAgICAgICAgIC8vIGNvbnNvbGUubG9nKGksIHRoaXMuX2ZsYWcpXG4gICAgICAgICAgdmFyIGZsYWcgPSB0aGlzLl9mbGFnW2ldXG4gICAgICAgICAgLy9mb3IgXG4gICAgICAgICAgLy8gY29uc29sZS5sb2coJ19yZW1vdmUnKVxuICAgICAgICAgIGlmIChmbGFnKSB7XG4gICAgICAgICAgICAvL2RpdCBtb2V0IHdlbCBmZiBsdWtrZW5cbiAgICAgICAgICAgIGlmIChvYmplY3QuZmxhZ3NbZmxhZ1swXV0pIHtcbiAgICAgICAgICAgICAgb2JqZWN0LmZsYWdzW2ZsYWdbMF1dLnJlbW92ZSAmJiBvYmplY3QuZmxhZ3NbZmxhZ1swXV0ucmVtb3ZlLmNhbGwodGhpcywgZmxhZyk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBmbGFnWzRdLnJlbW92ZS5jYWxsKHRoaXMsIGZsYWcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9mbGFnID0gbnVsbFxuICAgICAgfVxuXG4gICAgICBfcmVtb3ZlLmNhbGwodGhpcywgZnJvbSwgdXBkYXRlLCBzdGFtcCk7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBbZGVzY3JpcHRpb25dXG4gICAgICogQG1ldGhvZCBfc2V0XG4gICAgICogQHBhcmFtICB7W3R5cGVdfSB2YWwgICAgICBbZGVzY3JpcHRpb25dXG4gICAgICogQHBhcmFtICB7W3R5cGVdfSBzdGFtcCAgICBbZGVzY3JpcHRpb25dXG4gICAgICogQHBhcmFtICB7W3R5cGVdfSBmcm9tICAgICBbZGVzY3JpcHRpb25dXG4gICAgICogQHBhcmFtICB7W3R5cGVdfSByZW1vdmUgICBbZGVzY3JpcHRpb25dXG4gICAgICogQHBhcmFtICB7W3R5cGVdfSBub3VwZGF0ZSBbZGVzY3JpcHRpb25dXG4gICAgICogQHJldHVybiB7W3R5cGVdfSAgICAgICAgICBbZGVzY3JpcHRpb25dXG4gICAgICovXG4gICAgJ19zZXQnLCBmdW5jdGlvbih2YWwsIHN0YW1wLCBmcm9tLCByZW1vdmUsIG5vdXBkYXRlKSB7XG4gICAgICAvLyBjb25zb2xlLmxvZygnbWFrZSBfc2V0Jyx0aGlzLl9uYW1lLHZhbCk7XG4gICAgICBfc2V0LmNhbGwodGhpcywgdmFsLCBzdGFtcCwgZnJvbSwgcmVtb3ZlLCBub3VwZGF0ZSlcblxuICAgICAgLy9mbGFnIG1vZXQgZHVzIG9vayBtZWVyIGVlbiBjb3BpZWQgdmFsdWUgd29yZGVuXG5cbiAgICAgIC8vIGNvbnNvbGUubG9nKCdfc2V0JywgdGhpcy5fZmxhZywgdmFsKVxuXG5cbiAgICAgIGlmKHRoaXMuX2ZsYWcpIHtcblxuICAgICAgICAvLyBjb25zb2xlLmxvZygnb3ZlcndyaXRlPj8tLS0tJywgdGhpcy5fZmxhZywgdmFsKVxuXG4gICAgICAgIGZvcih2YXIgaSBpbiB0aGlzLl9mbGFnKSB7XG4gICAgICAgICAgdmFyIGZsYWcgPSB0aGlzLl9mbGFnW2ldXG4gICAgICAgICAgaWYgKGZsYWcpIHtcbiAgICAgICAgICAgIHZhciBzZXRGbCA9IG9iamVjdC5mbGFnc1tmbGFnWzBdXSB8fCBmbGFnWzRdXG4gICAgICAgICAgICAvL3doYXQgdG8gZG8gd2l0aCByZXNldD9cbiAgICAgICAgICAgIC8vY2hhbmdlIGZpeGVuIGJpaiBjYXNlcz9cbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy8gY29uc29sZS5sb2coJzIgb3ZlcndyaXRlPj8tLS0tJywgZmxhZywgdGhpcy5fdmFsLCB0aGlzLl92YWwgIT09IGZsYWdbMV0pXG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGlmICh0aGlzLl92YWwgIT09IGZsYWdbMV0gJiYgc2V0RmwudXNlVmFsKSB7XG5cbiAgICAgICAgICAgICAgLy8gbnUgZmYgaGllciBvb2sgbm9nIVxuXG4gICAgICAgICAgICAgIGlmIChvYmplY3QuZmxhZ3NbZmxhZ1swXV0pIHtcblxuICAgICAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKCdyZW1vdmUgZmxhZyBub3JtYWwnLGZsYWcsIGZsYWdbNF0sIGksIHRoaXMpXG5cbiAgICAgICAgICAgICAgICBvYmplY3QuZmxhZ3NbZmxhZ1swXV0ucmVtb3ZlICYmIG9iamVjdC5mbGFnc1tmbGFnWzBdXS5yZW1vdmUuY2FsbCh0aGlzLCBmbGFnKVxuICAgICAgICAgICAgICAgIC8vaWYgdGhpcyBlbXB0eVxuICAgICAgICAgICAgICAgIC8vIGRlbGV0ZSB0aGlzLl9mbGFnO1xuICAgICAgICAgICAgICAgIGRlbGV0ZSB0aGlzLl9mbGFnW2ldXG4gICAgICAgICAgICAgICAgaWYodXRpbC5lbXB0eSh0aGlzLl9mbGFnKSkge1xuICAgICAgICAgICAgICAgICAgZGVsZXRlIHRoaXMuX2ZsYWdcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gdGhpcy5fdXBkYXRlKClcbiAgICAgICAgICAgICAgfSBlbHNlIGlmICghZmxhZ1s1XSkge1xuICAgICAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKCdyZW1vdmUgZmxhZyAvdyBmbGFnWzRdIGFuZCBub3QgZmxhZ1s1XScsZmxhZywgZmxhZ1s0XSwgaSlcbiAgICAgICAgICAgICAgICBmbGFnWzRdLnJlbW92ZS5jYWxsKHRoaXMsIGZsYWcpO1xuICAgICAgICAgICAgICAgIC8vIGlmKHRoaXMuKVxuICAgICAgICAgICAgICAgIC8vZGVsZXRlIHRoaXMuX2ZsYWc7XG4gICAgICAgICAgICAgICAgZGVsZXRlIHRoaXMuX2ZsYWdbaV1cbiAgICAgICAgICAgICAgICBpZih1dGlsLmVtcHR5KHRoaXMuX2ZsYWcpKSB7XG4gICAgICAgICAgICAgICAgICBkZWxldGUgdGhpcy5fZmxhZ1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmIChvYmplY3QuZmxhZ3NbZmxhZ1swXV0gJiYgb2JqZWN0LmZsYWdzW2ZsYWdbMF1dLnJlc2V0ICYmIGZsYWdbM10gIT09IHRoaXMpIHtcbiAgICAgICAgICAgICAgLy8gY29uc29sZS5lcnJvcignUkVTRVRUSU5HIC0tIGluZ25vcmUgL3cgYSBjbGVhciEnLGZsYWdbMF0pIFxuICAgICAgICAgICAgICBvYmplY3QuZmxhZ3NbZmxhZ1swXV0uc2V0LmNhbGwodGhpcywgZmxhZ1syXSwgc3RhbXAsIHRydWUsIHRoaXMuX25hbWUpXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICB9LFxuICAgIC8qKlxuICAgICAqIFtkZXNjcmlwdGlvbl1cbiAgICAgKiBAbWV0aG9kIHNldFxuICAgICAqIEBwYXJhbSAge1t0eXBlXX0gbmFtZSAgICAgW2Rlc2NyaXB0aW9uXVxuICAgICAqIEBwYXJhbSAge1t0eXBlXX0gdmFsICAgICAgW2Rlc2NyaXB0aW9uXVxuICAgICAqIEBwYXJhbSAge1t0eXBlXX0gdm9iaiAgICAgW2Rlc2NyaXB0aW9uXVxuICAgICAqIEBwYXJhbSAge1t0eXBlXX0gc3RhbXAgICAgW2Rlc2NyaXB0aW9uXVxuICAgICAqIEBwYXJhbSAge1t0eXBlXX0gbm91cGRhdGUgW2Rlc2NyaXB0aW9uXVxuICAgICAqIEByZXR1cm4ge1t0eXBlXX0gICAgICAgICAgW2Rlc2NyaXB0aW9uXVxuICAgICAqL1xuICAgICdzZXQnLCBmdW5jdGlvbihuYW1lLCB2YWwsIHZvYmosIHN0YW1wLCBub3VwZGF0ZSkge1xuICAgICAgdmFyIGZsID0gb2JqZWN0LmZsYWdzW25hbWVdIHx8IF9jaGVjayhuYW1lKVxuICAgICAgICAsIHJcbiAgICAgICAgLCBzYW1lXG5cbiAgICAgICAgLy8gY29uc29sZS5sb2cobmFtZSwgdmFsLCB2b2JqKVxuXG4gICAgICBpZiAoZmwpIHtcblxuICAgICAgICAvLyBjb25zb2xlLmxvZygnc2V0Pj8tLS0tJywgbmFtZSwgdmFsLCB0aGlzLl9mbGFnKVxuICAgICAgIFxuICAgICAgaWYodmFsPT09ZmFsc2UpIHtcbiAgICAgICAgICAvL3N0YWNrIC0tIGFsbGUgZmxhZ3MgbmFtZSBwcm92aWRlbiFcbiAgICAgICAgICB2YXIgaSA9IGZsLnN0YWNrfHxuYW1lIFxuICAgICAgICAgICAgLCBmbGFnID0gdGhpcy5fZmxhZyAmJiB0aGlzLl9mbGFnW2ldXG4gICAgICAgICAgaWYoZmxhZyAmJiBmbC5yZW1vdmUpIHtcbiAgICAgICAgICAgIHZhciBkID0gZmwucmVtb3ZlLmNhbGwodGhpcywgZmxhZywgbmFtZSlcbiAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKCdSRU1PVkUgRkxBRyBGUk9NIEZBTFNFJy5pbnZlcnNlLCBmbCwgbmFtZSwgdmFsLCBzdGFtcCwgdGhpcylcbiAgICAgICAgICAgIGlmKCFkKSB7XG4gICAgICAgICAgICAgIGRlbGV0ZSB0aGlzLl9mbGFnW2ldXG4gICAgICAgICAgICAgIGlmKHV0aWwuZW1wdHkodGhpcy5fZmxhZykpIHtcbiAgICAgICAgICAgICAgICAvLyBjb25zb2xlLmxvZygnZmxhZyBpcyBlbXB0eSwgZGVsZXRlJylcbiAgICAgICAgICAgICAgICBkZWxldGUgdGhpcy5fZmxhZ1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBcbiAgICAgICAgICByID0gdHJ1ZVxuICAgICAgICAgIC8vIGlmKHRoaXMuX2ZsYWcpXG4gICAgICB9IGVsc2Uge1xuICAgICAgIGlmKHRoaXMuX2ZsYWcpIHtcbiAgICAgICAgICAvL2NoZWNrIGlmIG5lZWQgdG8gcmVtb3ZlISAtLSBvbmx5IGluIGNhc2VcbiAgICAgICAgICBmb3IodmFyIGkgaW4gdGhpcy5fZmxhZykge1xuICAgICAgICAgICAgdmFyIGZsYWcgPSB0aGlzLl9mbGFnW2ldXG4gICAgICAgICAgICBpZiAoZmxhZyAmJiBmbC5yZW1vdmUpIHtcblxuICAgICAgICAgICAgICBpZighZmwuc3RhY2sgJiYgbmFtZSA9PT0gZmxhZ1swXSkge1xuICAgICAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKCctLS0+JyxmbGFnWzBdKVxuICAgICAgICAgICAgICAgIGlmKHZhbCE9PWZsYWdbMl0pIHtcbiAgICAgICAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKCdyZW1vdmUgZmxhZyEgLS0tPiBvdmVyd3JpdGUgYnlteXNlbGYgLS0tPicsIGZsYWdbMF0sICBzZXRGbCwgJ2J5OicgLG5hbWUsIGZsLCB2YWwsIGZsYWdbMl0pXG4gICAgICAgICAgICAgICAgICBmbC5yZW1vdmUuY2FsbCh0aGlzLCBmbGFnKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgc2FtZSA9IHRydWVcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgfSBlbHNlIGlmICghZmwuc3RhY2sgfHwgZmwuc3RhY2sgIT09IGZsYWdbMF0pIHtcblxuICAgICAgICAgICAgICAgIC8vdGhpcy5fZmxhZ1xuXG4gICAgICAgICAgICAgICAgLy9pZiB2YWw6dHJ1ZSBcbiAgICAgICAgICAgICAgICAvL2dvIGNoZWNrIGlmIHlvdSBuZWVkIHRvIHJlbW92ZSBtb2Zvc1xuXG4gICAgICAgICAgICAgICAgdmFyIHNldEZsID0gb2JqZWN0LmZsYWdzW2ZsYWdbMF1dIHx8IGZsYWdbNF1cblxuICAgICAgICAgICAgICAgIGlmKHNldEZsLnVzZVZhbCAmJiBmbC51c2VWYWwpIHtcblxuICAgICAgICAgICAgICAgICAgLy8gY29uc29sZS5sb2coJ3JlbW92ZSBmbGFnISAtLSBjbGVhcmx5IGhhcyBzb21lIHVzZVZhbCcsIGZsYWdbMF0sICBzZXRGbCwgJ2J5OicgLG5hbWUsIGZsKVxuXG4gICAgICAgICAgICAgICAgICBzZXRGbC5yZW1vdmUuY2FsbCh0aGlzLCBmbGFnKTtcbiAgICAgICAgICAgICAgICAgIGRlbGV0ZSB0aGlzLl9mbGFnW2ldXG4gICAgICAgICAgICAgICAgICBpZih1dGlsLmVtcHR5KHRoaXMuX2ZsYWcpKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKCdmbGFnIGlzIGVtcHR5LCBkZWxldGUnKVxuICAgICAgICAgICAgICAgICAgICBkZWxldGUgdGhpcy5fZmxhZ1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuXG4gICAgICAgICAgICAgICAgLy8gY29uc29sZS5sb2coJ3JlbW92ZSBmbGFnIScsIGZsYWcsIGZsYWdbMF0sIGZsYWdbNF0sICBvYmplY3QuZmxhZ3NbZmxhZ1swXV0gICwgZmwsIG5hbWUpIC8vY2hlY2sgaWYgaXQgbmVlZHMgdG8gYmUgcmVtb3ZlZFxuICAgICAgICAgICAgICAgIC8vIHZhciBmbCBcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAvL2ZsID0gb2JqZWN0LmZsYWdzW25hbWVdIHx8IF9jaGVjayhuYW1lKVxuICAgICAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAgICAgLy9oaWVyIGlldHMgbWVlIGRvZW4gd2VlciB6b2VrZW4gbmFhciBmbGFnIHNldFxuXG5cbiAgICAgICAgICAgICAgICAvL2RvIHRoZSBzcGVjaWFsIGNoZWNrIGlmIHZhbHVlIGlzIHRpZ2h0IHRvIGZsYWcgY2hlY2sgKGZvciBib3RoISBmbC52YWx1ZSlcblxuICAgICAgICAgICAgICAgIC8vIGZsLnJlbW92ZS5jYWxsKHRoaXMsIGZsYWcpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgIGlmKCFzYW1lKSB7XG4gICAgICAgICAgLy8gY29uc29sZS5sb2coJ1NFVCBGTEFHJy5pbnZlcnNlLCBuYW1lLCB2YWwsIHN0YW1wLCB0aGlzKVxuICAgICAgICAgIGZsLnNldC5jYWxsKHRoaXMsIHZhbCwgc3RhbXAsIGZhbHNlLCBuYW1lKTtcbiAgICAgICAgICByID0gdHJ1ZSAvL25pZXQgYWx0aWpkIHdhYXIgb2Zjb3Vyc2UhXG4gICAgICAgICAgLy8gY29uc29sZS5sb2coJy0tLS0tLS0tLScpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gY29uc29sZS5sb2coJ0ZMQUcgSVMgU0FNRScucmVkLmludmVyc2UsIG5hbWUsIHZhbCwgc3RhbXAsIHRoaXMpXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgICAgdGhpc1tuYW1lXSAmJiB0aGlzW25hbWVdLnJlbW92ZShmYWxzZSwgZmFsc2UsIGZhbHNlLCBmYWxzZSwgZmFsc2UsIHRydWUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgciA9IHNldC5jYWxsKHRoaXMsIG5hbWUsIHZhbCwgdm9iaiwgc3RhbXAsIG5vdXBkYXRlKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByO1xuICAgIH0pO1xuICBvYmplY3QuZmxhZ3MgPSBfcHJvdG8uX19mbGFnc19fO1xuICB1dGlsLmRlZmluZShvYmplY3QuZmxhZ3MsICdkeW5hbWljJywge30pO1xufSkiLCIvKiFcbiAqIEBsaWNlbnNlIENvcHlyaWdodCAoYykgMjAxMi0yMDE0LCBWaWdvdXIuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBAYXV0aG9yOiBKaW0gZGUgQmVlciwgamltQHZpZ291ci5pb1xuICovXG52YXIgdXRpbCA9IHJlcXVpcmUoJy4uL3V0aWwnKVxuICAsIHZpZ291ciA9IHJlcXVpcmUoJy4uLycpXG4gICwgaW5qZWN0ID0gcmVxdWlyZSgnLi4vdXRpbC9pbmplY3QnKVxuLyoqXG4gKiBWLk9iamVjdHMgYXJlIHVzZWQgaW5zdGVhZCBvZiBub3JtYWwgb2JqZWN0cyBpbiB2aWdvdXIgbGlzdGVuZXJzIGFyZSBhdXRvbWF0aWNhbGx5IGFkZGVkIGFuZCByZW1vdmVkXG4gKiB0eXBlOiBfX3QgOiAxID0gYXJyYXkgLCAyID0gb2JqZWN0ICwgMyA9IGhhcyBmaWVsZCAoY2FuIG5ldmVyIGJlIGFuIGFycmF5KSAsIDQgPSBmaWVsZCByZWYgdG8gb3RoZXIgVi5PYmplY3RcbiAqIG5vdGUgeW91IGNhbiBtYWtlIGFuIG9iamVjdCBvdXQgb2YgYSBmaWVsZCBvciBmaWVsZCByZWYgdGhlIHR5cGUgd2lsbCBiZSAzIG9yIDQgdGhvdWdoIVxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0gIHsqfSAgICAgIFt2YWxdICAgIFZhbHVlXG4gKiBAcGFyYW0gIHtPYmplY3R9IFtwYXJlbnRdIFBhcmVudG9iamVjdFxuICovXG52YXIgb2JqZWN0ID0gbW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzID0gdmlnb3VyLk9iamVjdCA9IGZ1bmN0aW9uKHZhbCwgaG9vaywgcGFyZW50KSB7XG4gIGlmIChwYXJlbnQpIHRoaXMuX3BhcmVudCA9IHBhcmVudFxuICBpZiAoaG9vayAmJiB0aGlzLl9ob29rKSB0aGlzLl9ob29rKHZhbCwgaG9vaylcbiAgaWYgKHZhbCAhPT0gdm9pZCAwKSB0aGlzLnZhbCA9IHZhbFxufVxub2JqZWN0LmluamVjdCA9IGluamVjdFxuLyoqXG4gKiBVc2VkIHRvIHNldCAudmFsXG4gKiBAbWV0aG9kIF9zZXRcbiAqIEBwYXJhbSAgeyp9ICAgICAgICAgICAgICB2YWwgICAgICAgICAgICAgICAgICBbZGVzY3JpcHRpb25dXG4gKiBAcGFyYW0gIHtOdW1iZXJ9ICAgICAgICAgW3N0YW1wID0gbmV3IHN0YW1wXSAgW2Rlc2NyaXB0aW9uXVxuICogQHBhcmFtICB7T2JqZWN0fEJvb2xlYW59IFtmcm9tXSAgICAgICAgICAgICAgIFtkZXNjcmlwdGlvbl1cbiAqIEBwYXJhbSAge0Jvb2xlYW59ICAgICAgICBbbm91cGRhdGVdICAgICAgICAgICBXaGVuIHRydWUsIG5vIHVwZGF0ZXNcbiAqIEBwYXJhbSAge0Jvb2xlYW59ICAgICAgICBbYWRkXSAgICAgICAgICAgICAgICBXaGVuIHRydWUsIHRoaXMgaXMgYW4gYWRkXG4gKi9cbnZhciBfc2V0ID0gZnVuY3Rpb24odmFsLCBzdGFtcCwgZnJvbSwgbm91cGRhdGUsIGFkZCkge1xuXG4gIGlmKHZhbD09PW51bGwpIHtcbiAgICBpZiAoIXN0YW1wKSBzdGFtcCA9IHRoaXMuc3RhbXAoKVxuICAgIHRoaXMucmVtb3ZlKGZhbHNlLCBmYWxzZSwgZmFsc2UsIGZyb20sIHN0YW1wLCBub3VwZGF0ZSlcbiAgfVxuXG4gIGlmICghdGhpcy5fX3QgfHwgdGhpcy5fX3QgPCAzIHx8ICggdmFsICE9PSB0aGlzLl92YWwgfHwgdGhpcy5faWdub3JlVmFsdWUgKSApIHtcblxuICAgIC8vIGNvbnNvbGUuZXJyb3IodGhpcylcbiAgICBpZighdGhpcy5zdGFtcCkge1xuICAgICAgLy9tb2V0IGFsbGVtYWFsIGV2ZW50IGVtaXR0ZXJzIHdvcmRlbiAob24oJ2Vycm9yJykpXG4gICAgICAvL3RoaXMuX3VwZGF0ZSgnZXJyb3InKSBlbiBhbmRlcnMgVi5kZWJ1Zy5lcnJvci5fdXBkYXRlKCAnb2JqZWN0JyApXG4gICAgICBjb25zb2xlLmVycm9yKCAnRVJST1IgaW4gdmlnb3VyLWpzL29iamVjdCwgIE9CSkVDVCBubyAuc3RhbXAnLCB0aGlzIClcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGlmICghc3RhbXApIHN0YW1wID0gdGhpcy5zdGFtcCgpXG5cbiAgICB2YXIgb2xkdmFsID0gdGhpcy5fdmFsXG4gICAgICAsIG5lc3RlZHZhbFxuICAgICAgLCBub3NldFxuICAgICAgLCBpc1NldFxuICAgICAgLCBpc0FycmF5XG4gICAgICAsIHZhbElzU2V0XG5cbiAgICBpZiAodGhpcy5fY2hhbmdldm9iaiBcbiAgICAgICYmICgodGhpcy5fX3QgPCA0ICYmIHZhbCBpbnN0YW5jZW9mIG9iamVjdCkgXG4gICAgICB8fCB0aGlzLl9fdCA9PT0gNCAmJiAoKCF0aGlzLl9taXhlZHx8dGhpcy5fbWl4ZWQ9PT00KSB8fCB2YWwgaW5zdGFuY2VvZiBBcnJheSBcbiAgICAgICAgfHwgKHZhbCBpbnN0YW5jZW9mIE9iamVjdCBcbiAgICAgICAgICAmJiAodmFsIGluc3RhbmNlb2Ygb2JqZWN0IHx8IHZhbC52YWwpKSkpKSB7IC8vdHJ5IHRvIG1ha2UgdGhpcyBzaG9ydGVyXG4gICAgICAgICB0aGlzLl9jaGFuZ2V2b2JqKHZhbCwgc3RhbXApXG4gICAgICAgICBpZih0aGlzLl9taXhlZD09PTQpIHRoaXMuX3ZhbCA9IG51bGxcbiAgICB9XG5cbiAgICBpZiAodmlnb3VyLkJhc2UgJiYgKHZhbCBpbnN0YW5jZW9mIHZpZ291ci5CYXNlKSkge1xuICAgICAgdGhpcy5yZW1vdmUodHJ1ZSwgdHJ1ZSwgZmFsc2UsIGZhbHNlLCBzdGFtcClcbiAgICAgIHRoaXMuX190ID0gNVxuICAgICAgdGhpcy5fdmFsID0gdmFsXG4gICAgfSBlbHNlIGlmICh2YWwgaW5zdGFuY2VvZiBvYmplY3QpIHtcbiAgICAgIGlmICgodGhpcy5fX3QgPCAzICYmICF0aGlzLl9taXhlZCkgfHwgdGhpcy5fX3QgPT09IDEpIHtcbiAgICAgICAgdGhpcy5yZW1vdmUodHJ1ZSwgdHJ1ZSwgZmFsc2UsIHZvaWQgMCwgc3RhbXApIC8vY2hlY2sgaWYgMm5kIHBhcmFtIHRydWUgaXMgYWJzb2x1dGVseSBuZXNzZWNhcnkgKGVsc2UgaXQgd2lsbCBiZSByZW1vdmVkKVxuICAgICAgfVxuICAgICAgdGhpcy5fdmFsID0gdmFsXG4gICAgICB0aGlzLl9fdCA9IDRcbiAgICAgIGlmICh0aGlzLl9zZXR2b2JqKSB0aGlzLl9zZXR2b2JqKHZhbClcbiAgICB9IGVsc2Uge1xuXG4gICAgICBpZiAodmFsIGluc3RhbmNlb2YgT2JqZWN0ICYmIHR5cGVvZiB2YWwgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgaWYgKHZhbCBpbnN0YW5jZW9mIEFycmF5KSB7XG4gICAgICAgICAgdGhpcy5fdmFsID0gdm9pZCAwXG4gICAgICAgICAgdGhpcy5fX3QgPSAxXG4gICAgICAgICAgdGhpcy5sZW5ndGggPSB2YWwubGVuZ3RoXG4gICAgICAgICAgbm9zZXQgPSB0aGlzLnJlbW92ZSh0cnVlLCB0cnVlLCB2YWwsIGZhbHNlLCBzdGFtcClcbiAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbCA9IHRoaXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuc2V0KGksIHZhbFtpXSwgZmFsc2UsIHN0YW1wLCBub3VwZGF0ZSwgdHJ1ZSkgJiYgbm9zZXQgIT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgIG5vc2V0ID0gdHJ1ZVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgbm9zZXQgPSBmYWxzZVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcblxuICAgICAgICAgIC8vbm9ybWFsIG9iamVjdFxuXG4gICAgICAgICAgaWYgKHZhbC5jbGVhcikge1xuICAgICAgICAgICAgbm9zZXQgPSB0aGlzLnJlbW92ZSh0cnVlLCB0cnVlLCBmYWxzZSwgZmFsc2UsIHN0YW1wKVxuICAgICAgICAgICAgZGVsZXRlIHZhbC5jbGVhclxuICAgICAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgICAgIGlmICh0aGlzLl9fdCA9PT0gMSkge1xuICAgICAgICAgICAgICBpZiAodGhpcy5fbWl4ZWQgIT09IDEgJiYgdGhpcy5fbWl4ZWQhPT00KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5yZW1vdmUodHJ1ZSwgdHJ1ZSwgZmFsc2UsIGZhbHNlLCBzdGFtcCkgLy9vbW1pdGluZyBzdGFtcCBjYW4gYmUgYSBwcm9ibGVtXG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaXNBcnJheSA9IHRydWVcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmICghdGhpcy5fbWVyZ2UgJiYgKCF0aGlzLl9taXhlZCB8fCB0aGlzLl9fdCA9PT0gMikpIHtcbiAgICAgICAgICAgICAgbm9zZXQgPSB0aGlzLnJlbW92ZSh0cnVlLCB0cnVlLCB2YWwsIGZhbHNlLCBzdGFtcClcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHZhbC52YWwgJiYgdXRpbC5pc09iaih2YWwudmFsKSkge1xuICAgICAgICAgICAgdmFsSXNTZXQgPSB0cnVlXG4gICAgICAgICAgICBfc2V0LmNhbGwodGhpcywgbmV3IHRoaXMuX2NsYXNzKHZhbC52YWwsIGZhbHNlLCB0aGlzKSwgc3RhbXAsIGZyb20sIHRydWUpXG4gICAgICAgICAgICB0aGlzLl92YWwuX2NvbnRhaW5lZCA9IHRydWVcbiAgICAgICAgICB9IGVsc2UgaWYgKCF0aGlzLl9taXhlZCkge1xuICAgICAgICAgICAgdGhpcy5fdmFsID0gdm9pZCAwIC8vdGhpcyBtZXNzZXMgdXAgcHJvcGVydHkgdXBkYXRlcyEhICh5b3VyaSlcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoIWlzQXJyYXkpIHRoaXMuX190ID0gMlxuXG4gICAgICAgICAgZm9yICh2YXIgaiBpbiB2YWwpIHtcbiAgICAgICAgICAgIGlmICghdXRpbC5jaGVja0FycmF5KHRoaXMuX2JsYWNrbGlzdCwgaikpIHtcbiAgICAgICAgICAgICAgaWYgKGogPT09ICd2YWwnKSB7XG4gICAgICAgICAgICAgICAgaWYoIXZhbElzU2V0KSBpc1NldCA9IF9zZXQuY2FsbCh0aGlzLCB2YWwudmFsLCBzdGFtcCwgZnJvbSwgdHJ1ZSlcbiAgICAgICAgICAgICAgICBuZXN0ZWR2YWwgPSB0cnVlO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vZG8gbm90IGFsd2F5cyBpZ25vcmUgdXBkYXRlcyBhdCB0aGlzIHBvaW50XG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLnNldChqLCB2YWxbal0sIGZhbHNlLCBzdGFtcCwgbm91cGRhdGUsIHRydWUpICYmIG5vc2V0ICE9PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgICAgbm9zZXQgPSB0cnVlXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIG5vc2V0ID0gZmFsc2UgLy90aGlzIGlzIHRoZSBwbGFjZSB3aGVyZSBzZXQgaXMgcGFzc2VkXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmICgodGhpcy5fX3QgPCAzICYmICF0aGlzLl9taXhlZCkgfHwgdGhpcy5fX3QgPT09IDEpIHtcbiAgICAgICAgICB0aGlzLnJlbW92ZSh0cnVlLCB0cnVlLCBmYWxzZSwgZmFsc2UsIHN0YW1wKVxuICAgICAgICAgIGlmICh0aGlzLl9fdCA9PT0gMSkgZGVsZXRlIHRoaXMubGVuZ3RoXG4gICAgICAgIH1cbiAgICAgICAgaWYgKHZhbCA9PT0gdGhpcy5fdmFsICYmICF0aGlzLl9pZ25vcmVWYWx1ZSApIHtcbiAgICAgICAgICAvL21heWJlIHVzZSBzdGFtcCBmb3IgaWdub3JlVmFsdWUgYXMgd2VsbD9cbiAgICAgICAgICBpZiAobm9zZXQgIT09IGZhbHNlKSB7XG4gICAgICAgICAgICB0aGlzLl9fdCA9IDNcbiAgICAgICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLl92YWwgPSB2YWxcbiAgICAgICAgICB0aGlzLl9fdCA9IDNcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBpZiAobmVzdGVkdmFsKSB7XG5cbiAgICAgIGlmICh0aGlzLl9zZXQgJiYgKGlzU2V0ICE9PSBmYWxzZSB8fCBub3NldCA9PT0gZmFsc2UpKSB7XG4gICAgICAgIHRoaXMuX3NldCh2YWwsIHN0YW1wLCBmcm9tLCBmYWxzZSwgbm91cGRhdGUsIGFkZCwgb2xkdmFsKVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAodGhpcy5fc2V0KSB7XG4gICAgICBpZiAoIW5vc2V0KSB7XG4gICAgICAgIHRoaXMuX3NldCh2YWwsIHN0YW1wLCBmcm9tLCBmYWxzZSwgbm91cGRhdGUsIGFkZCwgb2xkdmFsKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxufSxcbi8qKlxuICogc3RhbXBcbiAqIHBhaW50IHRoZSBzZXQgb3JpZ2luXG4gKiBAbWV0aG9kXG4gKi9cbl9zdGFtcCA9IDAsXG5fcGFyYW1zID0gZnVuY3Rpb24ocGFyYW1zLCBsaXN0KSB7XG4gIGZvciAodmFyIGkgPSBsaXN0Lmxlbmd0aCAtIDEsIHA7IGkgPj0gMDsgaS0tKSB7XG4gICAgaWYgKHBhcmFtcyAmJiBwYXJhbXNbbGlzdFtpXV0hPT12b2lkIDApIHtcbiAgICAgIHAgPSAnXycgKyBsaXN0W2ldXG4gICAgICB1dGlsLmRlZmluZSh0aGlzLCBwLCBwYXJhbXNbbGlzdFtpXV0pXG4gICAgfVxuICB9XG59XG4vKipcbiogR2VuZXJhdGVzIHVuaXF1ZSBzdGFtcFxuKiBAbWV0aG9kIHN0YW1wXG4qIEByZXR1cm4ge051bWJlcn0gUmV0dXJucyBzdGFtcFxuKi9cbmV4cG9ydHMuc3RhbXAgPSBmdW5jdGlvbigpIHtcbi8vaWYgc3RhbXAgPiB4IHJlc2V0ID9cbnJldHVybiBfc3RhbXArK1xufVxuXG5leHBvcnRzLnNldCA9IF9zZXRcblxuLy8gb2JqZWN0VXRpbHMuZXh0ZW5kKGV4cG9ydHMpOyAgXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgY29uc3RydWN0b3IgYmFzZWQgb24gYSBWLk9iamVjdFxuICogUGFyYW1zIGNhbiBiZSBwYXNzZWRcbiAqIE1peGVkIGNyZWF0ZXMgbWl4ZWQgdHlwZXMgZm9yIHRoZSBuZXcgY2xhc3MgaS5lIGhhdmluZyBhIHN0cmluZyBhbmQgcHJvcGVydGllc1xuICogQG1ldGhvZCBuZXdcbiAqIEBwYXJhbSAge09iamVjdH0gcGFyYW1zIFBhcmFtZXRlcnNvYmplY3RcbiAqIEByZXR1cm4ge09iamVjdH0gICAgICAgIFJldHVybnMgVi5PYmplY3RcbiAqL1xuXG5cbm9iamVjdC5uZXcgPSBmdW5jdGlvbihwYXJhbXMsIGNvbnN0cnVjdG9yKSB7XG4gIHZhciB2T2JqID0gZnVuY3Rpb24odmFsLCBob29rLCBwYXJlbnQpIHtcbiAgICAgIGlmIChwYXJlbnQpIHRoaXMuX3BhcmVudCA9IHBhcmVudFxuICAgICAgaWYgKGNvbnN0cnVjdG9yKSBjb25zdHJ1Y3Rvci5hcHBseSh0aGlzLGFyZ3VtZW50cykgIFxuICAgICAgaWYgKGhvb2sgJiYgdGhpcy5faG9vaykgdGhpcy5faG9vayh2YWwsIGhvb2spXG4gICAgICBpZiAodGhpcy5fb25Db25zdHJ1Y3QpIHRoaXMuX29uQ29uc3RydWN0KHZhbCwgaG9vaylcbiAgICAgIGlmICh2YWwgIT09IHZvaWQgMCkgdGhpcy52YWwgPSB2YWxcbiAgICAgIC8vIGNvbnNvbGUubG9nKGNvbnN0cnVjdG9yKVxuICAgIH0sXG4gICAgcHJvdG8gPSB2T2JqLnByb3RvdHlwZSA9IG5ldyB0aGlzKClcbiAgdk9iai5uZXcgPSBvYmplY3QubmV3XG4gIHZPYmouaW5qZWN0ID0gaW5qZWN0IC8vbm90IGhhbmRlbGVkIHdlbGwgeWV0XG4gIHV0aWwuZGVmaW5lKHZPYmosICdfYmxhY2tsaXN0JywgcHJvdG8uX2JsYWNrbGlzdC5jb25jYXQoKSlcbiAgX3BhcmFtcy5jYWxsKHZPYmosIHBhcmFtcywgWydtaXhlZCcsICdtZXJnZSddKVxuICB1dGlsLmRlZmluZSh2T2JqLCAnX2NsYXNzJywgdk9iailcbiAgcmV0dXJuIHZPYmpcbn1cblxudXRpbC5kZWZpbmUob2JqZWN0LFxuLyoqXG4gKiBJdGVtcyBpbiB0aGUgYmxhY2tsaXN0IHNraXBwZWQgaW4gZWFjaCBmdW5jdGlvblxuICogQG1ldGhvZCBfYmxhY2tsaXN0XG4gKi9cbidfYmxhY2tsaXN0JywgWydfJywgJ19fJywgJ19fdCcsICdfdmFsJywgJ2xlbmd0aCcsICdfbmFtZScsICdfcGFyZW50JywgJ19jb250YWluZWQnLCAnX3JlbW92ZWQnLCdleHRlbnNpb25zJywgJ19fY2FjaGVkUGF0aCcsICdfaWdub3JlVmFsdWUnLCAnX2luZGV4Q2FjaGUnXSxcbi8qKlxuICogUmVwbGFjZXMgZGVmYXVsdCBjb25zdHJ1Y3RvciBwcm9wZXJ0eSAsbmVjZXNzYXJ5IGZvciBjbGFzc2VzIG1hZGUgd2l0aCBWLk9iamVjdC5uZXdcbiAqIEBjb25zdHJ1Y3RvciBfY2xhc3NcbiAqL1xuJ19jbGFzcycsIG9iamVjdCxcbi8qKlxuICogU3RhbXAgaXMgYSBtZXRob2Qgb2YgVk9iamVjdCBzbyB0aGF0IGl0IGNhbiBiZSBleHRlbmRlZCBpbiBzdWJjbGFzc2VzXG4gKiBAcmV0dXJuIHsqfSBhIHVuaXF1ZSBpZGVudGlmaWVyIGZvciBhIG11dGF0aW9uXG4gKi9cbidzdGFtcCcsIG9iamVjdC5zdGFtcCxcbi8qKlxuICogVXNlZCB0byBnZXQgLnZhbCB3aGljaCByZXR1cm5zIGZpZWxkIHZhbHVlcyBpLmUuIGEgc3RyaW5nXG4gKiBAbWV0aG9kIF9nZXRcbiAqIEByZXR1cm4geyp9IFJldHVybnMgdmFsdWVcbiAqL1xuJ19nZXQnLCBmdW5jdGlvbigpIHtcbiAgdmFyIHNlbGYgPSB0aGlzXG4gICAgLCB0eXBlID0gc2VsZi5fX3RcbiAgICAsIHZhbFxuXG4gIGlmICh0eXBlIDwgMykge1xuICAgIHJldHVybiBzZWxmXG4gIH0gZWxzZSB7XG4gICAgdmFsID0gc2VsZi5fdmFsXG4gICAgcmV0dXJuICh0eXBlICE9PSA0KSA/IHZhbCA6IHZhbCAmJiB2YWwuX2dldCgpXG4gIH1cbn0sXG4vKipcbiAqIFVzZWQgdG8gZ2V0IC52YWwgd2hpY2ggcmV0dXJucyBmaWVsZCB2YWx1ZXMgaS5lLiBhIHN0cmluZ1xuICogU2V0IGNyZWF0ZXMgaW5zdGFuY2VzIG9mIHRoZSBfY2xhc3MgZm9yIG5lc3RlZCBwcm9wZXJ0aWVzXG4gKiBAcHJvcGVydHlcbiAqL1xuJ3ZhbCcsIHtcbiAgc2V0OiBfc2V0LFxuICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLl9nZXQoKVxuICB9XG59LFxuLyoqXG4gKiBBZGQgYSBwcm9wZXJ0eSB0byBhIG9iamVjdFxuICogQG1ldGhvZCBzZXRcbiAqIEBwYXJhbSAge1N0cmluZ30gIG5hbWUgICAgICAgICAgICAgICAgW2Rlc2NyaXB0aW9uXVxuICogQHBhcmFtICB7Kn0gICAgICAgdmFsICAgICAgICAgICAgICAgICBbZGVzY3JpcHRpb25dXG4gKiBAcGFyYW0gIHtCb29sZWFufSBbdm9ial0gICAgICAgICAgICAgIFtkZXNjcmlwdGlvbl1cbiAqIEBwYXJhbSAge051bWJlcn0gIFtzdGFtcCA9IG5ldyBzdGFtcF0gW2Rlc2NyaXB0aW9uXVxuICogQHBhcmFtICB7Qm9vbGVhbn0gW25vdXBkYXRlXSAgICAgICAgICBbZGVzY3JpcHRpb25dXG4gKiBAcmV0dXJuIHtCb29sZWFufSAgICAgICAgICAgICAgICAgICAgIFtkZXNjcmlwdGlvbl1cbiAqL1xuJ3NldCcsIGZ1bmN0aW9uKCBuYW1lLCB2YWwsIHZvYmosIHN0YW1wLCBub3VwZGF0ZSwgZnJvbSApIHtcblxuICAvL2Z1bmN0aW9uKCBuYW1lLCB2YWwsIHZvYmosIHN0YW1wLCBub3VwZGF0ZSwgZnJvbSApIFxuXG4gIC8vIGNvbnNvbGUubG9nKG5hbWUsIHN0YW1wKVxuXG4gIGZyb20gPSBmcm9tICYmIHRoaXNcbiAgaWYgKCF2b2JqICYmICh0aGlzW25hbWVdIGluc3RhbmNlb2Ygb2JqZWN0KSkge1xuICAgIGlmIChfc2V0LmNhbGwodGhpc1tuYW1lXSwgdmFsLCBzdGFtcCwgZnJvbSwgbm91cGRhdGUpID09PSBmYWxzZSAmJiBzdGFtcCkge1xuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGlmICh2b2JqKSB7XG4gICAgICBpZih0aGlzW25hbWVdKSB0aGlzW25hbWVdLnJlbW92ZSgpXG4gICAgICB0aGlzW25hbWVdID0gdmFsXG4gICAgICB0aGlzW25hbWVdLl9uYW1lID0gbmFtZVxuICAgICAgdGhpc1tuYW1lXS5fcGFyZW50ID0gdGhpc1xuICAgICAgaWYoIW5vdXBkYXRlKSB2YWwuX3VwZGF0ZSh2YWwsIHN0YW1wIHx8IHRoaXMuc3RhbXAoKSwgZnJvbSwgdm9pZCAwLCB0cnVlKVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzW25hbWVdID0gbmV3IHRoaXMuX2NsYXNzKHZvaWQgMCwgZmFsc2UsIHRoaXMpXG4gICAgICB0aGlzW25hbWVdLl9uYW1lID0gbmFtZVxuICAgICAgX3NldC5jYWxsKHRoaXNbbmFtZV0sIHZhbCwgc3RhbXAsIGZyb20sIG5vdXBkYXRlLCB0cnVlKVxuICAgIH1cbiAgICBpZiAodGhpcy5fX3QgPT09IDEgJiYgdGhpcy5fc2V0QXJyYXlJdGVtKSB7XG4gICAgICB0aGlzLl9zZXRBcnJheUl0ZW0oIHRoaXNbbmFtZV0sIHZhbCApXG4gICAgfVxuICB9XG4gIHJldHVybiB0cnVlXG59LFxuLyoqXG4gKiBSZW1vdmVzIGEgVi5PYmplY3QgaW5jbHVkaW5nIGFsbCBuZXN0ZWQgZmllbGRzIGFuZCB2YWx1ZXNcbiAqIEBtZXRob2QgcmVtb3ZlXG4gKiBAcGFyYW0gIHtCb29sZWFufSAgICAgICAgW25lc3RlZF0gICAgICAgICAgICAgV2hlbiB0cnVlIHJlbW92ZSBuZXN0ZWQgb2JqZWN0c1xuICogQHBhcmFtICB7Qm9vbGVhbn0gICAgICAgIFtibF0gICAgICAgICAgICAgICAgIFdoZW4gdHJ1ZSBkb2Vzbid0IHJlbW92ZSBibGFja2xpc3RlZCBpdGVtc1xuICogQHBhcmFtICB7Qm9vbGVhbn0gICAgICAgIFtub3RdICAgICAgICAgICAgICAgIFtkZXNjcmlwdGlvbl1cbiAqIEBwYXJhbSAge0Jvb2xlYW58T2JqZWN0fSBbZnJvbV0gICAgICAgICAgICAgICBbZGVzY3JpcHRpb25dXG4gKiBAcGFyYW0gIHtOdW1iZXJ9ICAgICAgICAgW3N0YW1wID0gbmV3IHN0YW1wXSAgW2Rlc2NyaXB0aW9uXVxuICogQHBhcmFtICB7Qm9vbGVhbn0gICAgICAgIFtub3VwZGF0ZV0gICAgICAgICAgIFtkZXNjcmlwdGlvbl1cbiAqIEByZXR1cm4ge0Jvb2xlYW59ICAgICAgICAgICAgICAgICAgICAgICAgICAgICBbZGVzY3JpcHRpb25dXG4gKi9cbiAvLyAgICB0aGlzLnJlbW92ZShmYWxzZSwgZmFsc2UsIGZhbHNlLCBmcm9tLCBzdGFtcCwgbm91cGRhdGUpXG5cbidyZW1vdmUnLCBmdW5jdGlvbihuZXN0ZWQsIGJsLCBub3QsIGZyb20sIHN0YW1wLCBub3VwZGF0ZSkgeyAvL25vIHVwZGF0ZSBmaXJzdCA+IChleHRlbmRlZCBpbiBzZWxlY3Rpb24uanMpXG4gIGlmICghbmVzdGVkKSB0aGlzLl9yZW1vdmVkID0gdHJ1ZVxuICB2YXIgciwgaSwgb2xkdmFsXG4gIGlmICghc3RhbXApIHN0YW1wID0gdGhpcy5zdGFtcCgpXG4gIC8vIGNvbnNvbGUubG9nKCdTVEFSVCcsc3RhbXAsdGhpcy5fbmFtZSk7XG4gIGlmICghbmVzdGVkKSB7XG4gICAgaWYgKHRoaXMuX3BhcmVudCkge1xuICAgICAgdGhpcy5fcGFyZW50W3RoaXMuX25hbWVdID0gbnVsbFxuICAgICAgZGVsZXRlIHRoaXMuX3BhcmVudFt0aGlzLl9uYW1lXVxuICAgIH1cbiAgICBpZiAodGhpcy5fdmFsICE9PSB2b2lkIDApIHtcbiAgICAgIGlmICh0aGlzLl92YWwgaW5zdGFuY2VvZiBvYmplY3QgJiYgdGhpcy5fdmFsLl9jb250YWluZWQpIHtcbiAgICAgICAgdGhpcy5fdmFsLnJlbW92ZShmYWxzZSwgZmFsc2UsIGZhbHNlLCBmcm9tIHx8IHRoaXMsIHN0YW1wLCBub3VwZGF0ZSlcbiAgICAgIH1cbiAgICAgIG9sZHZhbCA9IHRoaXMuX3ZhbFxuICAgICAgdGhpcy5fdmFsID0gbnVsbFxuICAgIH1cbiAgfVxuICBmb3IgKGkgaW4gdGhpcykge1xuICAgIGlmICgoIW5vdCB8fCAhbm90W2ldKSAmJiAhdXRpbC5jaGVja0FycmF5KHRoaXMuX2JsYWNrbGlzdCwgaSkpIHtcbiAgICAgIGlmICh0aGlzW2ldIGluc3RhbmNlb2Ygb2JqZWN0KSB7XG4gICAgICAgIHIgPSBmYWxzZVxuICAgICAgICAvLyBjb25zb2xlLmxvZygnREVMRVRFJyxzdGFtcCxpLHRoaXNbaV0pO1xuICAgICAgICB0aGlzW2ldLnJlbW92ZShmYWxzZSwgZmFsc2UsIGZhbHNlLCBmcm9tIHx8IHRoaXMsIHN0YW1wLCBub3VwZGF0ZSlcbiAgICAgIH1cbiAgICAgIHRoaXNbaV0gPSBudWxsXG4gICAgICBkZWxldGUgdGhpc1tpXSAvL2RlbGV0ZSBpcyBwcmV0dHkgbmFzdHkgZm9yIHBlcmZvcm1hbmNlXG4gICAgfVxuICB9XG4gIGlmICghbmVzdGVkKSB7XG4gICAgaWYgKHRoaXMuX3JlbW92ZSkge1xuICAgICAgLy9yXG4gICAgICB0aGlzLl9yZW1vdmUoZnJvbSwgbm91cGRhdGUgPyBmYWxzZSA6IGZyb20gLyp8fHIqLyAsIHN0YW1wLCBvbGR2YWwpO1xuICAgICAgaWYgKCFibCkge1xuICAgICAgICBmb3IgKHZhciBqIGluIHRoaXMpIHtcbiAgICAgICAgICBpZiAodGhpc1tqXSAhPT0gdm9pZCAwKSB7XG4gICAgICAgICAgICBpZiAoaiAhPT0gJ19wYXJlbnQnICYmIHRoaXNbal0gaW5zdGFuY2VvZiBvYmplY3QgJiYgdGhpc1tqXS5fY29udGFpbmVkKSB7XG4gICAgICAgICAgICAgIHRoaXNbal0ucmVtb3ZlKClcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXNbal0gPSBudWxsXG4gICAgICAgICAgICBkZWxldGUgdGhpc1tqXVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLl9yZW1vdmVkID0gdHJ1ZVxuICB9XG4gIHJldHVybiByXG59KVxuXG5cbi8vLS0tLXRoaXMgaGFzIHRvIGJlIGluaXRpYWxpemVkIGFmdGVyIGRlZmluaW5nIHRoZSBibGFja2xpc3QgcHJvcGVydHk7XG5leHBvcnRzLmxpc3RlbiA9IHJlcXVpcmUoJy4vbGlzdGVuJylcbnJlcXVpcmUoJy4vYXJyYXknKVxucmVxdWlyZSgnLi91dGlsJykiLCJ2YXIgdXRpbCA9IHJlcXVpcmUoJy4uL3V0aWwnKVxuICAsIHZPYmplY3QgPSByZXF1aXJlKCcuLycpXG4gICwgViA9IHJlcXVpcmUoJy4uLycpXG5cblxuZnVuY3Rpb24gX2FkZExpc3RlbmVyKCBvYmosIGZuLCBtYXJrLCBvcmlnaW5hbCApIHtcbiAgLy92YWwsIG1hcmssIHNraXBjaGVjaywgaWdub3JldmFsLCBvcmdpbmFsXG4gIGlmKCBtYXJrICkgXG4gIHtcbiAgICAvLyBjb25zb2xlLmxvZygnaGV5IGdvdCBvcmdpbmFsIScsIG9yaWdpbmFsKVxuICAgIG9iai5hZGRMaXN0ZW5lcihbIGZuLCBtYXJrIF0sIHRydWUsIGZhbHNlLCBmYWxzZSwgb3JpZ2luYWwgIClcbiAgfSBcbiAgZWxzZSBcbiAge1xuICAgICAgICAvLyBjb25zb2xlLmxvZygnaGV5IGdvdCBvcmdpbmFsIScsIG9yaWdpbmFsKVxuXG4gICAgb2JqLmFkZExpc3RlbmVyKCBmbiwgZmFsc2UsIGZhbHNlLCBmYWxzZSwgb3JpZ2luYWwgKVxuICB9XG59XG5cbi8qXG4gIF91cGRhdGUgY2FsbHMgbGlzdGVuZXJzIG9uIGEgZ2l2ZW4gT2JqZWN0IChsaXN0ZW5lcnMgaW5jbHVkZSBsaW5raW5nIGZpZWxkcyBpbiBvdGhlciBWLk9iamVjdHMpXG4gIFYuT2JqZWN0Ll91cGRhdGUgY2FuIGJlIG1vZGlmaWVkIHRvIGNoYW5nZSB1cGRhdGUgYmVoYXZpb3I6XG4gICAgLSBzdGFuZGFyZDogdXBkYXRlIE9iamVjdCBhbmQgaXQncyBwYXJlbnRzIC8gYW5jZXN0b3JzIHJlY3Vyc2l2ZWx5LlxuICAgIC0gcGFyZW50T25seTogdXBkYXRlIE9iamVjdCBhbmQgb25seSBpdHMgZGlyZWN0IHBhcmVudC5cbiAgICAtIGp1c3QgX3VwZGF0ZTogdXBkYXRlIG9ubHkgdGhlIE9iamVjdC5cbiovXG52YXIgX3VwZGF0ZSA9IGV4cG9ydHMuX3VwZGF0ZSA9IGZ1bmN0aW9uKHZhbCwgc3RhbXAsIGZyb20sIHJlbW92ZSwgYWRkZWQsIG9sZHZhbCwgdGVzdCkge1xuXG4gIC8vIGlmKHdpbmRvdy5oZXJlKSBjb25zb2xlLmxvZygnVVBEQVRFIScsdGhpcy5fcGF0aClcblxuICB2YXIgX2wgPSB0aGlzLl9saXN0ZW5lcnNcbiAgICAsIGlcbiAgICAsIGxpc3RlbmVyXG5cbiAgaWYgKF9sKSB7XG4gICAgZm9yIChpID0gX2wubGVuZ3RoOyBsaXN0ZW5lciA9IF9sWy0taV07KSB7IC8vb3JkZXIgaXMgaXJyZWxldmFudFxuICAgICAgaWYgKGxpc3RlbmVyIGluc3RhbmNlb2Ygdk9iamVjdCkge1xuXG4gICAgICAgIC8vIGNvbnNvbGUubG9nKCd1cGRhdGU/Pz8/PycsIGxpc3RlbmVyLl9wYXRoLCB0aGlzLl9wYXRoLCBmcm9tKVxuXG4gICAgICAgIGlmIChmcm9tKSBsaXN0ZW5lci5fbGZyb20gPSBmcm9tXG4gICAgICAgIGxpc3RlbmVyLl91cGRhdGUodmFsLCBzdGFtcCwgZmFsc2UsIHJlbW92ZSwgYWRkZWQsIG9sZHZhbClcbiAgICAgICAgaWYgKGxpc3RlbmVyKSBsaXN0ZW5lci5fbGZyb20gPSBudWxsXG4gICAgICB9IGVsc2UgaWYgKGxpc3RlbmVyWzBdKSB7XG4gICAgICAgIGlmKCF0ZXN0IHx8ICF0ZXN0KGxpc3RlbmVyKSkge1xuICAgICAgICAgIGlmIChsaXN0ZW5lci5sZW5ndGggPiAyKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBsID0gbGlzdGVuZXIubGVuZ3RoIC0gMlxuICAgICAgICAgICAgICAsIGwyID0gYXJndW1lbnRzLmxlbmd0aFxuICAgICAgICAgICAgICAsIGEgPSBbXSwgaiA9IC0xXG4gICAgICAgICAgICAgICwgbGEgPSBsICsgbDJcbiAgICAgICAgICAgICAgOyBqIDwgbGFcbiAgICAgICAgICAgICAgOyBhWysral0gPSBqIDwgbFxuICAgICAgICAgICAgICAgID8gbGlzdGVuZXJbaiArIDJdXG4gICAgICAgICAgICAgICAgOiBqID09PSBsID8gdGhpcyA6IGFyZ3VtZW50c1tqIC0gbCAtIDFdXG4gICAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgIGxpc3RlbmVyWzBdLmFwcGx5KGxpc3RlbmVyWzFdLCBhKVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBsaXN0ZW5lclswXS5jYWxsKGxpc3RlbmVyWzFdLCB0aGlzLCB2YWwsIHN0YW1wLCBmcm9tLCByZW1vdmUsIGFkZGVkLCBvbGR2YWwpXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsaXN0ZW5lci5jYWxsKHRoaXMsIHZhbCwgc3RhbXAsIGZyb20sIHJlbW92ZSwgYWRkZWQsIG9sZHZhbClcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuXG4vLyB1dGlsLmRlZmluZSh2T2JqZWN0LCBcbi8vICAgJ19ub2RlUGF0aF8nLCBmdW5jdGlvbigpIHtcbi8vICAgICBpZih0aGlzLl9jYWxsZXIpIHtcblxuLy8gICAgICAgdmFyIGFyciA9IFtdXG4vLyAgICAgICB2YXIgcCA9IHRoaXMuX2NhbGxlclxuXG4vLyAgICAgICB3aGlsZShwKSB7XG4vLyAgICAgICAgIGFyci5wdXNoKCBwLl9uYW1lIHx8IHAuX25vZGUgJiYgcC5fbm9kZS5jbGFzc05hbWUgKVxuLy8gICAgICAgICBwID0gcC5fbm9kZSAmJiBwLnBhcmVudFxuLy8gICAgICAgfVxuLy8gICAgICAgYXJyLnJldmVyc2UoKVxuLy8gICAgICAgcmV0dXJuIGFyclxuXG5cbi8vICAgICB9XG4vLyAgIH1cblxuLy8gKVxuXG5cbnZPYmplY3QucHJvdG90eXBlLl9ibGFja2xpc3QucHVzaCgnX2xpc3RlbmVycycsICdfbGlzdGVucycsICdfbGZyb20nLCAnX2xpc3Rlbk1hcCcpO1xuXG51dGlsLmRlZmluZSh2T2JqZWN0LFxuICAvKipcbiAgICogX3NldFxuICAgKiBpcyBjYWxsZWQgd2hlbiBhIHZhbHVlIGlzIHNldFxuICAgKiBAbWV0aG9kXG4gICAqL1xuICAnX3NldCcsIGZ1bmN0aW9uKHZhbCwgc3RhbXAsIGZyb20sIHJlbW92ZSwgbm91cGRhdGUsIGFkZGVkLCBvbGR2YWwpIHtcbiAgICBpZiAoIW5vdXBkYXRlKSB7XG4gICAgICAvLyBjb25zb2xlLmxvZyh0aGlzLl9wYXRoLCB2YWwpXG4gICAgICB0aGlzLl91cGRhdGUodmFsLCBzdGFtcCwgZnJvbSwgcmVtb3ZlLCBhZGRlZCwgb2xkdmFsKTtcbiAgICB9XG4gIH0sXG4gIC8qKlxuICAgKiBfX3VwZGF0ZVxuICAgKiBjYWxscyBsaXN0ZW5lcnMgYXR0YWNoZWQgdG8gdGhlIE9iamVjdFxuICAgKiB0eXBlcyAtLSBmdW5jdGlvbiBvciBWLk9iamVjdFxuICAgKiBAbWV0aG9kXG4gICAqL1xuICAnX191cGRhdGUnLCBfdXBkYXRlLFxuICAvKipcbiAgICogX3VwZGF0ZVxuICAgKiBlc2NhbGF0ZXMgYW4gdXBkYXRlIHVwIGl0J3Mgc3RydWN0dXJlIGFuZCBjYWxscyBfX3VwZGF0ZSB0byBjYWxsIGxpc3RlbmVyc1xuICAgKiB0eXBlcyAtLSBmdW5jdGlvbiBvciBWLk9iamVjdFxuICAgKiBAbWV0aG9kXG4gICAqL1xuICAnX3VwZGF0ZScsIGZ1bmN0aW9uKHZhbCwgc3RhbXAsIGZyb20sIHJlbW92ZSwgYWRkZWQsIG9sZHZhbCwgdGVzdCkgeyAvL2hlcmUgeW91IGNhbiBzZWUgaWYgaXRzIGFuIHVwZGF0ZSBmcm9tIGFub3RoZXIgb2JqZWN0IChmcm9tKVxuICAgIC8vIGNvbnNvbGUubG9nKCdWLk9iamVjdCBPRyBfdXBkYXRlJywgdmFsLCBzdGFtcCwgZnJvbSwgcmVtb3ZlLCBhZGRlZCwgb2xkdmFsKVxuICAgIHZhciBjdXJyID0gdGhpcyxcbiAgICBzID0gdHJ1ZVxuXG4gICAgd2hpbGUgKGN1cnIpIHtcbiAgICAgIC8vIHZhciBwID0gY3Vyci5fcGF0aFxuICAgICAgLy8gX3VwZGF0ZSBbXCJjbGllbnRzXCIsIFwiVl8ycHhjZXd2M2c0a1wiXSBcbiAgICAgIC8vIGNvbnNvbGUubG9nKCdfdXBkYXRlJywgcCwgdmFsLCBmcm9tIHx8ICgoIXMgJiYgdGhpcykgPyB0aGlzIDogdm9pZCAwLCB0aGlzKSApXG5cbiAgICAgIC8vVE9ETyAxMCBkb3VibGUgY2hlY2sgdGhpc1xuICAgICAgY3Vyci5fX3VwZGF0ZSh2YWwsIHN0YW1wLCBmcm9tIHx8IChzIT09dHJ1ZSkgPyB0aGlzIDogZmFsc2UgLCByZW1vdmUsIGFkZGVkLCBvbGR2YWwsIHRlc3QpXG4gICAgICBjdXJyID0gZnJvbSA/IGZhbHNlIDogY3Vyci5fcGFyZW50XG4gICAgICBzID0gZmFsc2VcbiAgICAgIGlmIChyZW1vdmUpIHJlbW92ZSA9IDFcbiAgICB9XG4gIH0sXG4gIC8qKlxuICAgKiBfcmVtb3ZlXG4gICAqIGNhbGxlZCBvbiByZW1vdmVcbiAgICogQG1ldGhvZFxuICAgKi9cbiAgJ19yZW1vdmUnLCBmdW5jdGlvbihmcm9tLCB1cGRhdGUsIHN0YW1wLCBvbGR2YWwpIHtcbiAgICBpZiAodXBkYXRlICE9PSBmYWxzZSkge1xuICAgICAgdGhpcy5fdXBkYXRlKG51bGwsIHN0YW1wLCBmcm9tLCB0cnVlLCBmYWxzZSwgb2xkdmFsKTtcbiAgICB9XG4gICAgdGhpcy5yZW1vdmVMaXN0ZW5lcigpO1xuICAgIHZhciBfbCA9IHRoaXMuX2xpc3RlbnMsXG4gICAgICBpLCBsaXN0ZW5lcjtcbiAgICBpZiAoX2wpIHtcbiAgICAgIC8vb3B0aW1pemUgbGF0ZXJcbiAgICAgIC8vdGhpcyx0aGlzIGlzIHdlaXJkIHRvIGFsd2F5cyB1c2UgdGhpcy4uLlxuICAgICAgZm9yIChpID0gX2wubGVuZ3RoIC0gMTsgaSA+PSAwOyBfbFtpLS1dLnJlbW92ZUxpc3RlbmVyKHRoaXMsIHZvaWQgMCwgZmFsc2UsIHRydWUpKTtcbiAgICB9XG4gIH0sXG4gIC8qKlxuICAgKiBfc2V0dm9ialxuICAgKiBpZiBhIHZhbHVlIGlzIHNldCB0byBhIFYuT2JqZWN0XG4gICAqIEBtZXRob2RcbiAgICovXG4gICdfc2V0dm9iaicsIGZ1bmN0aW9uKHZhbCkge1xuICAgIHZhbC5hZGRMaXN0ZW5lcih0aGlzKTtcbiAgfSxcbiAgLyoqXG4gICAqIF9jaGFuZ2V2b2JqXG4gICAqIGlmIGEgdmFsdWUgaXMgY2hhbmdlZCBmcm9tIGEgVi5PYmplY3RcbiAgICogQG1ldGhvZFxuICAgKi9cbiAgJ19jaGFuZ2V2b2JqJywgZnVuY3Rpb24odmFsKSB7XG4gICAgaWYgKHRoaXMuX190ID09PSA0KSB7XG4gICAgICB2YXIgX2wgPSB0aGlzLl9saXN0ZW5zLFxuICAgICAgICBfdmFsID0gdGhpcy5fdmFsLFxuICAgICAgICBpO1xuICAgICAgaWYgKF9sKSB7XG4gICAgICAgIGZvciAoaSA9IF9sLmxlbmd0aDsgaSA+PSAwOyBfbFstLWldICYmIF9sW2ldLnJlbW92ZUxpc3RlbmVyKHRoaXMsIHRoaXMpKTtcbiAgICAgIH1cbiAgICAgIGlmIChfdmFsIGluc3RhbmNlb2Ygdk9iamVjdCAmJiBfdmFsLl9jb250YWluZWQpIHtcbiAgICAgICAgX3ZhbC5yZW1vdmUoKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sXG4gIC8qKlxuICAgKiBhZGRMaXN0ZW5lclxuICAgKiBhZGRzIGEgbGlzdGVuZXIgdG8gYW4gb2JqZWN0IGNhbiBiZSBhIGZ1bmN0aW9uIG9yIFYuT2JqZWN0XG4gICAqIEBtZXRob2RcbiAgICovXG4gICdhZGRMaXN0ZW5lcicsIGZ1bmN0aW9uKCB2YWwsIG1hcmssIHNraXBjaGVjaywgaWdub3JldmFsLCBvcmlnaW5hbCApIHtcbiAgICB2YXIgX2wgPSB0aGlzLl9saXN0ZW5lcnMgfHwgKHRoaXMuX2xpc3RlbmVycyA9IFtdKSxcbiAgICAgIHRhcmdldCwgZztcblxuICAgIGlmKG9yaWdpbmFsKSB7XG4gICAgICAvLyBjb25zb2xlLmxvZygnT1JHSU5BTCEnLCBvcmlnaW5hbClcbiAgICAgIGlmKCF0aGlzLl9saXN0ZW5NYXApIHtcbiAgICAgICAgdGhpcy5fbGlzdGVuTWFwID0gW11cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvL21vcmUgc3BlZWQgdm9vciBjaGVja2FycmF5XG4gICAgaWYgKG1hcmspIHtcbiAgICAgIGcgPSB1dGlsLmNoZWNrQXJyYXkoX2wsIHZhbFsxXSwgMSk7XG4gICAgICBpZiAoZyA9PT0gZmFsc2VcbiAgICAgICAgfHwgIWlnbm9yZXZhbCAmJiB1dGlsLmNoZWNrQXJyYXkoX2wsIHZhbFswXSwgMCkgPT09IGZhbHNlXG4gICAgICAgIHx8IChtYXJrICE9PSB0cnVlICYmIG1hcmsuY2FsbCh0aGlzLCBfbFtnXSwgX2wsIGcsIHZhbCkgPT09IHRydWUpKSB7XG4gICAgICAgIFxuICAgICAgICAvL1RPRE86IGZpeCB0aGlzIHVsdHJhIGRpcnR5IHN0dWZmXG4gICAgICAgIGlmKCBvcmlnaW5hbCAmJiB2YWwgIT09IG9yZ2luYWwgKSB7XG4gICAgICAgICAgdGhpcy5fbGlzdGVuTWFwLnB1c2goWyBvcmdpbmFsLCB2YWwgXSlcbiAgICAgICAgfVxuXG4gICAgICAgIF9sLnB1c2godmFsKTtcbiAgICAgIH0gZWxzZSAge1xuICAgICAgICAgcmV0dXJuIF9sW2ddO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoIXZhbC5fX3QgfHwgIXV0aWwuY2hlY2tBcnJheShfbCwgdmFsKSkge1xuXG4gICAgICBpZiggb3JpZ2luYWwgJiYgdmFsICE9PSBvcmlnaW5hbCApIHtcbiAgICAgICAgdGhpcy5fbGlzdGVuTWFwLnB1c2goWyBvcmlnaW5hbCwgdmFsIF0pXG4gICAgICB9XG5cbiAgICAgIF9sLnB1c2godmFsKTtcbiAgICB9XG4gICAgaWYgKG1hcmsgfHwgdmFsIGluc3RhbmNlb2Ygdk9iamVjdCkge1xuICAgICAgdGFyZ2V0ID0gbWFyayA/IHZhbFsxXSA6IHZhbDtcbiAgICAgIGlmICh0YXJnZXQgaW5zdGFuY2VvZiB2T2JqZWN0KSB7XG4gICAgICAgIF9saSA9IHRhcmdldC5fbGlzdGVucyB8fCAodGFyZ2V0Ll9saXN0ZW5zID0gW10pO1xuICAgICAgICBpZiAoc2tpcGNoZWNrIHx8ICF1dGlsLmNoZWNrQXJyYXkoX2xpLCB0aGlzKSkge1xuXG4gICAgICAgICAgaWYoIG9yaWdpbmFsICYmIHZhbCAhPT0gb3JpZ2luYWwgKSB7XG4gICAgICAgICAgICB0aGlzLl9saXN0ZW5NYXAucHVzaChbIG9yaWdpbmFsLCB2YWwgXSlcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBfbGkucHVzaCh0aGlzKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSxcbiAgICdvbmNlJywgZnVuY3Rpb24oIHZhbCwgbWV0aG9kLCBtYXJrICkge1xuXG4gICAgLy92YWwsIG1hcmssIHNraXBjaGVjaywgaWdub3JldmFsLCBvcmdpbmFsXG5cbiAgICAvL1RPRE86dW5pZnkgL3cgb25cbiAgICB2YXIgbXZhbFxuXG4gICAgdmFyIGxpc3RlbiA9IGZ1bmN0aW9uKCkge1xuICAgICAgbXZhbC5hcHBseSggdGhpcywgYXJndW1lbnRzIClcbiAgICAgIC8vb3JpZ2luYWwgcGVyaGFwcz8/Pz9cbiAgICAgIHRoaXMucmVtb3ZlTGlzdGVuZXIoIG12YWwsIG1hcmsgKVxuICAgIH1cblxuICAgIGlmKCBtZXRob2QgKSB7XG4gICAgICBtdmFsID0gbWV0aG9kXG4gICAgICB0aGlzLm9uKCB2YWwsIGxpc3RlbiwgZmFsc2UsIG12YWwgKSAvL2RlemUgZm4gbW9ldCB3ZWwgZ2VyZW1vdmVkIHdvcmRlbiBnZWJldXJkIG51IG5pZXQhXG4gICAgfSBlbHNlIHtcbiAgICAgIG12YWwgPSB2YWxcbiAgICAgIHRoaXMub24oIGxpc3RlbiwgZmFsc2UsIGZhbHNlLCBtdmFsIClcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpc1xuXG4gIH0sXG4gICdvbicsIGZ1bmN0aW9uKCB2YWwsIG1ldGhvZCwgbWFyaywgb3JpZ2luYWwgKSB7XG4gICAgICAvKipcbiAgICAgICAgKiB2YWwgY2FuIGJlIGEgY29uZGl0aW9uIG9yIGEgY29tcGFyaXNvbiBvciBhIG1ldGhvZFxuICAgICAgKiovXG4gICAgICBpZiggVi5CYXNlICYmIG1ldGhvZCBpbnN0YW5jZW9mIFYuQmFzZSApIFxuICAgICAge1xuICAgICAgICBtYXJrID0gbWV0aG9kIC8vbWFrZSBleGNlcHRpb24gZm9yIHZhbHVlcyFcbiAgICAgICAgbWV0aG9kID0gbnVsbFxuICAgICAgfVxuXG4gICAgICBpZighb3JpZ2luYWwpIHtcbiAgICAgICAgb3JpZ2luYWwgPSBtZXRob2RcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIGNvbnNvbGUubG9nKCdzZXQgb3JpZ2luYWwhJywgb3JpZ2luYWwsIG1ldGhvZCApXG4gICAgICB9XG5cbiAgICAgIGlmKCAhbWV0aG9kICkgXG4gICAgICB7XG4gICAgICAgIF9hZGRMaXN0ZW5lciggdGhpcywgdmFsLCBtYXJrLCBvcmlnaW5hbCApXG4gICAgICB9XG4gICAgICBlbHNlIFxuICAgICAge1xuICAgICAgICBpZiggdXRpbC5pc09iaiggdmFsICkgKVxuICAgICAgICB7XG4gICAgICAgICAgY29uc29sZS53YXJuKCd0aGlzIHdpbGwgYmVjb21lIGEgY29uZGl0aW9uIGxhdGVyIG9uIGZvciBub3cgaXRzIG5vdCBzdXBwb3J0ZWQhLCBjb25kaXRpb25zIHdpbGwgYmUgdXNlZCBldmV5cndoZXJlJylcbiAgICAgICAgICAvL0hhcyB0byBiZWNvbWUgYSBjb25kaXRpb25cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmKCB0eXBlb2YgdmFsID09PSAnZnVuY3Rpb24nIClcbiAgICAgICAge1xuICAgICAgICAgIF9hZGRMaXN0ZW5lciggdGhpcywgZnVuY3Rpb24oIG52YWwgKSB7XG4gICAgICAgICAgICBpZiggdmFsLmFwcGx5KCB0aGlzLCBhcmd1bWVudHMgKSApIC8vbW9yZSBjaGVja3NcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgbWV0aG9kLmFwcGx5KCB0aGlzLCBhcmd1bWVudHMgKVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sIG1hcmssIG9yaWdpbmFsIClcbiAgICAgICAgfVxuICAgICAgICBlbHNlIFxuICAgICAgICB7XG5cbiAgICAgICAgICBpZiggdXRpbC5pc09iaiggbWV0aG9kICkgKVxuICAgICAgICAgIHtcblxuICAgICAgICAgICAgbWFyayA9IHZhbFxuXG4gICAgICAgICAgICBjb25zb2xlLndhcm4oJ3VudGVzdGVkIC0tIGFkZCBhcyBtYXJrJylcbiAgICAgICAgICAgIF9hZGRMaXN0ZW5lciggdGhpcywgZnVuY3Rpb24oIG52YWwsIHN0YW1wLCBmcm9tLCByZW1vdmUsIGFkZGVkLCBvbGR2YWwgKSB7XG4gICAgICAgICAgICAgIGlmKCByZW1vdmUgKSAvL21vcmUgY2hlY2tzXG4gICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBtZXRob2QuYXBwbHkoIHRoaXMsIGFyZ3VtZW50cyApXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIG1hcmssIG9yaWdpbmFsIClcblxuXG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2UgaWYoIHZhbCA9PT0gJ3JlbW92ZScgKVxuICAgICAgICAgIHtcbiAgICAgICAgICAgIC8vdmFsLCBzdGFtcCwgZmFsc2UsIHJlbW92ZSwgYWRkZWQsIG9sZHZhbFxuICAgICAgICAgICAgX2FkZExpc3RlbmVyKCB0aGlzLCBmdW5jdGlvbiggbnZhbCwgc3RhbXAsIGZyb20sIHJlbW92ZSwgYWRkZWQsIG9sZHZhbCApIHtcbiAgICAgICAgICAgICAgaWYoIHJlbW92ZSApIC8vbW9yZSBjaGVja3NcbiAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIG1ldGhvZC5hcHBseSggdGhpcywgYXJndW1lbnRzIClcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwgbWFyaywgb3JpZ2luYWwgKVxuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIGlmKCB2YWwgPT09ICdhZGRlZCcgKVxuICAgICAgICAgIHtcbiAgICAgICAgICAgIF9hZGRMaXN0ZW5lciggdGhpcywgZnVuY3Rpb24oIG52YWwsIHN0YW1wLCBmcm9tLCByZW1vdmUsIGFkZGVkLCBvbGR2YWwgKSB7XG4gICAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKCBhZGRlZCApIC8vd2Vya3QgbmlldCE7XG4gICAgICAgICAgICAgIGlmKCBhZGRlZCApIC8vbW9yZSBjaGVja3NcbiAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIG1ldGhvZC5hcHBseSggdGhpcywgYXJndW1lbnRzIClcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwgbWFyaywgb3JpZ2luYWwgKVxuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIGlmKCB2YWwgPT09ICdzZWxmJyApXG4gICAgICAgICAge1xuICAgICAgICAgICAgX2FkZExpc3RlbmVyKCB0aGlzLCBmdW5jdGlvbiggbnZhbCwgc3RhbXAsIGZyb20sIHJlbW92ZSwgYWRkZWQsIG9sZHZhbCApIHtcbiAgICAgICAgICAgICAgLy8gY29uc29sZS5sb2coIGFkZGVkICkgLy93ZXJrdCBuaWV0ITtcblxuICAgICAgICAgICAgICAvL1RPRE86IHB1dCBvbiBpbiBhIGRpZmZlcmVudCBmaWxlXG4gICAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKCdTSE9VTEQgRE8gU0VMRiEnLCBhcmd1bWVudHMsIGZyb20gKSAvL3pvIHdyb25nIVxuXG4gICAgICAgICAgICAgIGlmKCB0aGlzLl92YWwgPT09IG52YWwgKSAvL21vcmUgY2hlY2tzXG4gICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBtZXRob2QuYXBwbHkoIHRoaXMsIGFyZ3VtZW50cyApXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIG1hcmssIG9yaWdpbmFsIClcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZVxuICAgICAgICAgIHtcbiAgICAgICAgICAgIF9hZGRMaXN0ZW5lciggdGhpcywgZnVuY3Rpb24oIG52YWwgKSB7XG4gICAgICAgICAgICAgIGlmKCBudmFsID09PSB2YWwgfHwgdGhpcy52YWwgPT09IHZhbCB8fCB0aGlzLl92YWwgPT09IHZhbCApIC8vbW9yZSBjaGVja3NcbiAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIG1ldGhvZC5hcHBseSggdGhpcywgYXJndW1lbnRzIClcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwgbWFyaywgb3JpZ2luYWwgKVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXNcbiAgICB9LFxuXG4gIC8qKlxuICAgKiByZW1vdmVMaXN0ZW5lclxuICAgKiBpZiBubyB2YWwgcmVtb3ZlcyBhbGwgbGlzdGVuZXJzXG4gICAqIG1hcmsgY2hlY2tzIGluIGFycmF5IG9uIHBvc2l0aW9uIDEgZm9yIHVuaXF1ZW5lc3NcbiAgICogcmVtb3ZlIGlzIHVzZWQgaW4gY29tYmluYXRpb24gd2l0aCBtYXJrXG4gICAqIEBtZXRob2RcbiAgICovXG4gICdyZW1vdmVMaXN0ZW5lcicsIGZ1bmN0aW9uKHZhbCwgbWFyaywgcmVtb3ZlLCBub2JyZWFrKSB7XG4gICAgLy8gY29uc29sZS5sb2coJ3JlbW92ZUxpc3RlbmVyIScsIHRoaXMuX3BhdGgsIHRoaXMuX2xpc3RlbmVycyAmJiB0aGlzLl9saXN0ZW5lcnMubGVuZ3RoXG4gICAgLy8gICAsICdcXG5tYXJrOlxcbicsIG1hcmsgJiYgbWFyay5yYXdcbiAgICAvLyAgICwgJ1xcbnZhbDpcXG4nLCB2YWwgJiYgdmFsLm5hbWVcbiAgICAvLyAgICwgJ1xcbnZhbDpcXG4nLCB2YWxcbiAgICAvLyApXG4gICAgdmFyIF9sID0gdGhpcy5fbGlzdGVuZXJzLFxuICAgICAgaTtcbiAgICBpZiAoX2wpIHtcbiAgICAgIGZvciAoaSA9IF9sLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgIC8vbWF5YmUgY2hlY2tpbmcgbWFyayBhbGwgdGhlIHRpbWUgaXMgdG9vIHNsb3c/XG4gICAgICAgIHZhciBsaXN0ZW5lciA9IF9sW2ldXG4gICAgICAgIGlmIChcbiAgICAgICAgICAoIW1hcmsgJiYgIXZhbClcbiAgICAgICAgICB8fCAodmFsICYmIGxpc3RlbmVyID09PSB2YWwpIC8vZmFsc2Ugdm9vciBtYXJrXG4gICAgICAgICAgfHwgKG1hcmshPT1mYWxzZSAmJiAoKGxpc3RlbmVyIGluc3RhbmNlb2YgQXJyYXkpICYmICgobWFyayAmJiBsaXN0ZW5lclsxXSA9PT0gbWFyayAmJiAoIXZhbHx8bGlzdGVuZXJbMF09PT12YWwpKSB8fCB2YWwgJiYgbGlzdGVuZXJbMV0gPT09IHZhbCkpXG4gICAgICAgICAgICAmJiAoIXJlbW92ZVxuICAgICAgICAgICAgICB8fCAocmVtb3ZlID09PSB0cnVlICAvL2RpdCBtb2V0IGxhdGVyIHdlZyBpcyBkYW4gYWxsZWVuIGVlbiBmdW5jdGllIGlzIG51IG92ZXJib2RpZyAoY2hlY2sgYm92ZW4pXG4gICAgICAgICAgICAgICAgPyBsaXN0ZW5lclswXSA9PT0gdmFsXG4gICAgICAgICAgICAgICAgOiByZW1vdmUuY2FsbCh0aGlzLCBsaXN0ZW5lciwgbWFyaykpKSlcbiAgICAgICAgKSB7XG4gICAgICAgICAgLy8gY29uc29sZS5sb2coJ21hcmsuX2xpc3RlbnM/JywgISEobWFyayAmJiBtYXJrLl9saXN0ZW5zKVxuICAgICAgICAgIC8vICAgICAsICdcXG5pcyB2T2JqZWN0PycsIGxpc3RlbmVyIGluc3RhbmNlb2Ygdk9iamVjdFxuICAgICAgICAgIC8vICAgICAsICdcXG5pcyBtYXJrZWQ/JywgbGlzdGVuZXIgaW5zdGFuY2VvZiBBcnJheVxuICAgICAgICAgIC8vICAgKVxuICAgICAgICAgIHZhciBmb2N1cyA9IG1hcmtcbiAgICAgICAgICAgID8gbWFya1xuICAgICAgICAgICAgOiBsaXN0ZW5lciBpbnN0YW5jZW9mIHZPYmplY3RcbiAgICAgICAgICAgICAgPyBsaXN0ZW5lclxuICAgICAgICAgICAgICA6IGxpc3RlbmVyIGluc3RhbmNlb2YgQXJyYXlcbiAgICAgICAgICAgICAgICA/IGxpc3RlbmVyWzFdXG4gICAgICAgICAgICAgICAgOiBmYWxzZVxuICAgICAgICAgIHZhciBsaXN0ZW5zID0gZm9jdXMgJiYgZm9jdXMuX2xpc3RlbnNcbiAgICAgICAgICBpZihsaXN0ZW5zKXtcbiAgICAgICAgICAgIGZvcih2YXIgaiA9IGxpc3RlbnMubGVuZ3RoLTEgOyBqID49IDAgOyBqLS0pe1xuICAgICAgICAgICAgICBpZihsaXN0ZW5zW2pdID09PSB0aGlzKXtcbiAgICAgICAgICAgICAgICBsaXN0ZW5zLnNwbGljZShqLCAxKVxuICAgICAgICAgICAgICAgIGlmKGxpc3RlbnMubGVuZ3RoID09PSAwKVxuICAgICAgICAgICAgICAgICAgZm9jdXMuX2xpc3RlbnMgPSBudWxsXG4gICAgICAgICAgICAgICAgaWYoZm9jdXMuX190ID09PSA0ICYmIGxpc3RlbmVyLl92YWwgPT09IHRoaXMpXG4gICAgICAgICAgICAgICAgICBsaXN0ZW5lci5fdmFsID0gdm9pZCAwXG4gICAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBfbC5zcGxpY2UoaSwgMSlcbiAgICAgICAgICBpZiAoX2wubGVuZ3RoID09PSAwKSB0aGlzLl9saXN0ZW5lcnMgPSBudWxsO1xuICAgICAgICAgIGlmICh2YWwgJiYgIW5vYnJlYWspIGJyZWFrXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy9UT0RPOiB0aGlzIGhhcyB0byBiZSByZWZhY3RvcmVkIEFTQVAhIGRvIHdoZW4gbmV3IGRlc2lnbiBwaGFzZSBmb3Igdm9iamVjdCtiYXNlIGlzIGdvaW5nIGRvd25cbiAgICAgIGlmKCB0aGlzLl9saXN0ZW5NYXAgJiYgdmFsICkge1xuICAgICAgICAvLyBjb25zb2xlLmxvZygnaW0gaGVyZSEnLCB2YWwpXG4gICAgICAgIHZhciBwaXZcbiAgICAgICAgZm9yKHZhciBpID0gMCwgX2xlbiA9IHRoaXMuX2xpc3Rlbk1hcC5sZW5ndGg7IGkgPCBfbGVuOyBpKysgKSB7XG4gICAgICAgICAgaWYoIHRoaXMuX2xpc3Rlbk1hcFtpXVswXSA9PT0gdmFsICkge1xuICAgICAgICAgICAgIHRoaXMucmVtb3ZlTGlzdGVuZXIoIHRoaXMuX2xpc3Rlbk1hcFtpXVsxXSApXG4gICAgICAgICAgICAgcGl2ID0gaVxuICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiggcGl2ICE9PSB2b2lkIDAgKSB7XG4gICAgICAgICAgdGhpcy5fbGlzdGVuTWFwLnNwbGljZShwaXYsIDEpXG4gICAgICAgICAgaWYodGhpcy5fbGlzdGVuTWFwLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgdGhpcy5fbGlzdGVuTWFwID0gZmFsc2VcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgIH1cbiAgfSk7IiwiLyohXG4gKiBAbGljZW5zZSBDb3B5cmlnaHQgKGMpIDIwMTItMjAxNCwgVmlnb3VyLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogQGF1dGhvcjogSmltIGRlIEJlZXIsIGppbUB2aWdvdXIuaW9cbiAqL1xudmFyIHV0aWwgPSByZXF1aXJlKCcuLi91dGlsJyksXG4gIFZPYmplY3QgPSByZXF1aXJlKCcuLycpLFxuICBWID0gcmVxdWlyZSgnLi4vJylcbiAgX2MgPSB1dGlsLmNoZWNrQXJyYXlcblxuLyoqXG4gKiBHZXRzL3NldHMgVk9iamVjdCBvcmlnaW5cbiAqIEluIGEgY2hhaW4gb2YgVi5PYmplY3RzIGUuZy4geC52YWwgPSB5LCB5LnZhbCA9IHogLS0tPiB4LmZyb20gcmV0dXJucyB6O1xuICogQG1ldGhvZCBmcm9tXG4gKiBAcGFyYW0gIHtPYmplY3R9IG9iaiBbZGVzY3JpcHRpb25dXG4gKiBAcmV0dXJuIHtPYmplY3R9ICAgICBbZGVzY3JpcHRpb25dXG4gKi9cbnZhciBfY29yZVNldCA9IFZPYmplY3Quc2V0LFxuICBfZnJvbSA9IHRoaXMuZnJvbSA9IGZ1bmN0aW9uKG9iaikge1xuICAgIHZhciB2YWwgPSBvYmosXG4gICAgICBsYXN0O1xuICAgIHdoaWxlICh2YWwgaW5zdGFuY2VvZiBWT2JqZWN0KSB7XG4gICAgICBsYXN0ID0gdmFsO1xuICAgICAgdmFsID0gdmFsLl92YWw7XG4gICAgfVxuICAgIHJldHVybiBsYXN0ICE9PSBvYmogPyBsYXN0IDogZmFsc2U7XG4gIH0sXG4gIF9sYXN0TEZyb20gPSBmdW5jdGlvbihvYmopIHtcbiAgICB3aGlsZSAob2JqICYmIG9iai5fX3QgPT09IDQpIHtcbiAgICAgIGlmIChvYmouX2xmcm9tKSB7XG4gICAgICAgIHJldHVybiBvYmouX2xmcm9tO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgb2JqID0gb2JqLl92YWw7XG4gICAgICB9XG4gICAgfVxuICB9LFxuICAvKipcbiAgICogUmV0dXJucyBwYXRoXG4gICAqIEBtZXRob2QgX3VwZGF0ZVBhdGhcbiAgICogQHBhcmFtICB7T2JqZWN0fSAgICB0aWxsIFtkZXNjcmlwdGlvbl1cbiAgICogQHJldHVybiB7T2JqZWN0fSAgICAgICAgIFJldHVybnMgcGF0aFxuICAgKi9cbiAgX3VwZGF0ZVBhdGggPSBmdW5jdGlvbih0aWxsLCBzdGFydCkge1xuICAgIHZhciBwYXJlbnQgPSB0aGlzLFxuICAgICAgbGZyb20sXG4gICAgICBwYXRoID0gW107IC8vcmVkdWNlIGFtb3VudCBvZiBuZXcgYXJyYXlzXG4gICAgd2hpbGUgKHBhcmVudCAmJiAocGFyZW50Ll9uYW1lICE9PSB2b2lkIDAgfHwgc3RhcnQpKSB7XG4gICAgICBsZnJvbSA9IHBhcmVudC5fbGZyb20gfHwgX2xhc3RMRnJvbShwYXJlbnQpXG4gICAgICBpZiAobGZyb20pIHtcbiAgICAgICAgdmFyIGEgPSBfdXBkYXRlUGF0aC5jYWxsKGxmcm9tKSxcbiAgICAgICAgICBjID0gcGFyZW50LmZyb20uX25hbWU7XG4gICAgICAgIHV0aWwuYWRkKGEsIHBhdGgpO1xuICAgICAgICBwYXRoID0gYTtcbiAgICAgICAgaWYgKGMpIHtcbiAgICAgICAgICBjID0gYS5pbmRleE9mKGMpO1xuICAgICAgICAgIGEuc3BsaWNlKGMsIGEubGVuZ3RoIC0gYyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChwYXJlbnQgIT09IHRpbGwpIHtcbiAgICAgICAgcGF0aC5wdXNoKHBhcmVudC5fbmFtZSk7XG4gICAgICAgIHBhcmVudCA9IHBhcmVudC5fcGFyZW50O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcGFyZW50ID0gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICAgIC8vIGNvbnNvbGUubG9nKCctLS0tLT4nLHBhdGgpXG4gICAgcmV0dXJuIHRpbGwgPyBwYXRoLnJldmVyc2UoKSA6IHBhdGg7XG4gIH1cblxudXRpbC5kZWZpbmUoVk9iamVjdCxcbiAgLyoqXG4gICAqIFJlbW92ZXMgYWxsIGxpbmtlZCBjb250YWluZXJzLCB1c2VzIHNsaWNlIG9uIGFycmF5c1xuICAgKiBSZW1vdmVzIGFsbCBfbGlzdGVuZXJzXG4gICAqIEBtZXRob2QgZGVzdHJveVxuICAgKi9cbiAgJ2Rlc3Ryb3knLCBmdW5jdGlvbihuZXN0ZWQsIGJsLCBub3QsIGZyb20sIHN0YW1wLCBub3VwZGF0ZSkge1xuICAgIGlmKCFzdGFtcClcbiAgICAgIHN0YW1wID0gdGhpcy5zdGFtcCgpXG5cbiAgICB0aGlzLl9yZW1vdmVkID0gdHJ1ZVxuICAgIHRoaXMuZGVzdHJveVJlZmVyZW5jZXMobmVzdGVkLCBibCwgbm90LCBmcm9tLCBzdGFtcCwgbm91cGRhdGUpXG4gICAgdGhpcy5yZW1vdmUobmVzdGVkLCBibCwgbm90LCBmcm9tLCBzdGFtcCwgbm91cGRhdGUpXG4gIH0sXG4gICdkZXN0cm95UmVmZXJlbmNlcycsIGZ1bmN0aW9uKG5lc3RlZCwgYmwsIG5vdCwgZnJvbSwgc3RhbXAsIG5vdXBkYXRlKSB7XG4gICAgaWYoIXN0YW1wKVxuICAgICAgc3RhbXAgPSB0aGlzLnN0YW1wKClcblxuICAgIHZhciBfbCA9IHRoaXMuX2xpc3RlbmVyc1xuICAgICAgLCBwYXJlbnRcbiAgICAgIC8vICwgaXRlbVxuICAgIGlmIChfbCkge1xuICAgICAgZm9yICh2YXIgaSA9IF9sLmxlbmd0aCwgcmVmOyByZWYgPSBfbFstLWldOykge1xuICAgICAgICAvLyBpZihsaXN0ZW5lciBpbnN0YW5jZW9mIEFycmF5KXtcbiAgICAgICAgLy8gICBpZihsaXN0ZW5lcilcbiAgICAgICAgLy8gfVxuICAgICAgICAvLyByZWYgPSAgaW5zdGFuY2VvZiBBcnJheSA/IF9sW2ldWzFdIDogX2xbaV07XG4gICAgICAgIGlmIChyZWYgaW5zdGFuY2VvZiBWT2JqZWN0KSB7XG4gICAgICAgICAgcGFyZW50ID0gcmVmLl9wYXJlbnQ7XG4gICAgICAgICAgaWYgKHBhcmVudCAmJiBwYXJlbnQuX190ID09PSAxKSB7XG4gICAgICAgICAgICBwYXJlbnQuc3BsaWNlKHJlZi5fbmFtZSwgMSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlZi5yZW1vdmUobmVzdGVkLCBibCwgbm90LCBmcm9tLCBzdGFtcCwgbm91cGRhdGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSxcbiAgLyoqXG4gICAqIFBlcmZvcm1zIHBhc3NlZCBmdW5jdGlvbiBvbiBlYWNoIGl0ZW0uXG4gICAqIFNraXBzIGl0ZW1zIGluIHRoZSBibGFja2xpc3QuXG4gICAqIEBtZXRob2RcbiAgICogQHBhcmFtICB7RnVuY3Rpb259ICBmbiAgIGZ1bmN0aW9uIHRvIHBlcmZvcm0gb24gZWFjaFxuICAgKiBAcGFyYW0gIHtCb29sZWFufSAgIGRlZXAgSWYgdHJ1ZSwgcmVwZWF0cyBlYWNobWV0aG9kIG9uIG5lc3RlZCBmaWVsZHNcbiAgICogQHBhcmFtICB7QXJndW1lbnRzfSBhcmcgIEFyZ3VtZW50cyB0byBwYXNzIHRvIHRoZSBmdW5jdGlvblxuICAgKiBAcmV0dXJuIHtCb29sZWFufSAgICAgICAgW2Rlc2NyaXB0aW9uXVxuICAgKi9cbiAgJ2VhY2gnLCBmdW5jdGlvbihmbiwgZGVlcCwgYXJnKSB7XG4gICAgLy90cnkgdG8gbWFrZSB0aGlzIGEgbG90IHNob3J0ZXJcbiAgICB2YXIgaSwgaXRlbTtcbiAgICBpZiAoYXJnICE9PSB2b2lkIDApIHtcbiAgICAgIGFyZyA9IHV0aWwuYXJnKGFyZ3VtZW50cywgMik7XG4gICAgICBmb3IgKGkgaW4gdGhpcykge1xuICAgICAgICBpZiAoIV9jKHRoaXMuX2JsYWNrbGlzdCwgaSkpIHtcbiAgICAgICAgICBpdGVtID0gdGhpc1tpXTtcbiAgICAgICAgICBpZiAoZm4uYXBwbHkoaXRlbSwgYXJnKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChkZWVwICYmIChpdGVtLl9fdCAhPT0gNCB8fCBpdGVtLl9jb250YWluZWQpKSB7XG4gICAgICAgICAgICBpZiAoaXRlbS5lYWNoLmFwcGx5KGl0ZW0sIGFyZykpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGZvciAoaSBpbiB0aGlzKSB7XG4gICAgICAgIGlmICghX2ModGhpcy5fYmxhY2tsaXN0LCBpKSkge1xuICAgICAgICAgIGl0ZW0gPSB0aGlzW2ldO1xuICAgICAgICAgIGlmIChmbi5jYWxsKGl0ZW0sIGkpKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGRlZXAgJiYgKGl0ZW0uX190ICE9PSA0IHx8IGl0ZW0uX2NvbnRhaW5lZCkpIHtcbiAgICAgICAgICAgIGlmIChpdGVtLmVhY2goZm4sIGRlZXAsIGFyZykpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9LFxuICAvKipcbiAgICogUmV0dXJucyB0aGUgcmVhbCBwYXRoXG4gICAqIEBhdHRyaWJ1dGUgX3BhdGhcbiAgICovXG4gICAgJ19wYXRoJywge1xuICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHBhcmVudCA9IHRoaXNcbiAgICAgICAgICAsIHBhdGggPSBbXVxuXG4gICAgICAgIHdoaWxlIChwYXJlbnQgJiYgcGFyZW50Ll9uYW1lICE9PSB2b2lkIDApIHtcbiAgICAgICAgICBwYXRoLnB1c2gocGFyZW50Ll9uYW1lKTtcbiAgICAgICAgICBwYXJlbnQgPSBwYXJlbnQuX3BhcmVudDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBwYXRoLnJldmVyc2UoKTtcbiAgICAgIH1cbiAgICB9LFxuICAgICdfY2FjaGVkUGF0aCcsIHtcbiAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9fY2FjaGVkUGF0aCB8fCAodGhpcy5fX2NhY2hlZFBhdGggPSB0aGlzLl9wYXRoLmpvaW4oJy4nKSlcbiAgICAgIH1cbiAgICB9LFxuICAvKipcbiAgICogUmV0dXJucyB0aGUgdXBkYXRlIHBhdGhcbiAgICogQGF0dHJpYnV0ZSB1cGRhdGVQYXRoXG4gICAqL1xuICAndXBkYXRlUGF0aCcsIHtcbiAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGEgPSBfdXBkYXRlUGF0aC5jYWxsKHRoaXMsIHRoaXMsIHRydWUpLFxuICAgICAgICBuYW1lID0gdGhpcy5fbmFtZTtcbiAgICAgIG5hbWUgIT09IHZvaWQgMCAmJiBhLnVuc2hpZnQobmFtZSk7XG4gICAgICByZXR1cm4gYTtcbiAgICB9XG4gIH0sXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBrZXlzIG9mIGFuIG9iamVjdFxuICAgKiBAYXR0cmlidXRlIGtleXNcbiAgICovXG4gICdrZXlzJywge1xuICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgaSwgYXJyID0gW107XG4gICAgICBmb3IgKGkgaW4gdGhpcykge1xuICAgICAgICBpZiAoIV9jKHRoaXMuX2JsYWNrbGlzdCwgaSkpIHtcbiAgICAgICAgICBhcnIucHVzaChpKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGFycjtcbiAgICB9XG4gIH0sXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRydWUgaWYgb2JqZWN0IGlzIEFuY2VzdG9yXG4gICAqIGFsc28gcmV0dXJuIHRydWUgd2hlbiBvYmplY3QgaXMgb2JqZWN0IHRvIGJlIGNvbXBhcmVkIHRvXG4gICAqIEBhdHRyaWJ1dGUga2V5c1xuICAgKi9cbiAgLy90Ll9kID09PSBmcm9tLl9wYXJlbnQgfHwgdC5fZCA9PT0gZnJvbVxuICAnX2FuY2VzdG9yJywgZnVuY3Rpb24ob2JqKSB7XG4gICAgLy8gY29uc29sZS5sb2coJ0FOQ0VTVE9SJy5yZWQuaW52ZXJzZSwgb2JqLCB0aGlzKVxuICAgIHZhciBwID0gdGhpc1xuICAgIHdoaWxlIChwKSB7XG4gICAgICBpZiAob2JqID09PSBwKSByZXR1cm4gdHJ1ZVxuICAgICAgcCA9IHAuX3BhcmVudFxuICAgIH1cbiAgfSxcbiAgLyoqXG4gICAqIEdldCBhIGZpZWxkIGF0IGZpcnN0IG9jY3VyZW5jZSBpbiB0aGUgcGFyZW50IGNoYWluXG4gICAqIEBtZXRob2QgY2hlY2tQYXJlbnRcbiAgICogQHBhcmFtICB7U3RyaW5nfSAgZmllbGQgW2Rlc2NyaXB0aW9uXVxuICAgKiBAcGFyYW0gIHtCb29sZWFufSBnZXQgICBXaGVuIHRydWUgcmV0dXJucyBmb3VuZCBpbnN0ZWFkIG9mIGN1cnJlbnRcbiAgICogQHJldHVybiB7T2JqZWN0fSAgICAgICAgW2Rlc2NyaXB0aW9uXVxuICAgKi9cbiAgJ2NoZWNrUGFyZW50JywgdXRpbC5jaGVja1BhcmVudEZhY3RvcnkoJ19wYXJlbnQnKSxcbiAgLyoqXG4gICAqIFJldHVybnMgYSBub3JtYWwgb2JqZWN0LCBhbmQga2VlcHMgbGlua3MgdG8gVi5PYmplY3RzXG4gICAqIEBtZXRob2RcbiAgICogQHBhcmFtICB7Kn0gICAgICBbdmFsXSBbZGVzY3JpcHRpb25dXG4gICAqIEByZXR1cm4ge09iamVjdH0gICAgICAgW2Rlc2NyaXB0aW9uXVxuICAgKi9cbiAgJ2NvbnZlcnQnLCBmdW5jdGlvbih2YWwpIHtcbiAgICB2YXIgb2JqID0ge30sIGwgPSAwXG4gICAgaWYgKCF2YWwgfHwgdmFsLnZhbCkgb2JqLnZhbCA9IHRoaXMuX3ZhbFxuICAgIGlmICh0aGlzLl9fdCA9PT0gMSkge1xuICAgICAgb2JqID0gW11cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBsKytcbiAgICAgICAgb2JqW2ldID0gdGhpc1tpXS5jb252ZXJ0KClcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5lYWNoKGZ1bmN0aW9uKGkpIHtcbiAgICAgICAgaWYgKCF2YWwgfHwgdmFsW2ldIT09dm9pZCAwKSB7XG4gICAgICAgICAgbCsrXG4gICAgICAgICAgb2JqW2ldID0gdGhpcy5jb252ZXJ0KClcbiAgICAgICAgfVxuICAgICAgfSlcbiAgICB9XG4gICAgaWYgKHZhbCkge1xuICAgICAgZm9yICh2YXIgaSBpbiB2YWwpIHtcbiAgICAgICAgaWYgKG9ialtpXSA9PT0gdm9pZCAwKSBvYmpbaV0gPSB2b2lkIDBcbiAgICAgICAgbCsrXG4gICAgICB9XG4gICAgfVxuICAgIGlmICghbCAmJiAoIXZhbCB8fCB2YWwudmFsKSkgb2JqID0gb2JqLnZhbFxuICAgIHJldHVybiBvYmpcbiAgfSxcbiAgLyoqXG4gICAqIFJldHVybnMgYSBub3JtYWwgb2JqZWN0XG4gICAqIEBhdHRyaWJ1dGUgcmF3XG4gICAqL1xuICAncmF3Jywge1xuICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgc2VsZiA9IHRoaXMsXG4gICAgICAgIHR5cGUgPSBzZWxmLl9maWx0ZXIgPyAyIDogc2VsZi5fX3QsXG4gICAgICAgIG9iaiwgaSwgbDtcbiAgICAgIGlmICh0eXBlID09PSA0KSB7XG4gICAgICAgIHJldHVybiBzZWxmLl92YWwgJiYgc2VsZi5fdmFsLnJhdztcbiAgICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gMykge1xuICAgICAgICByZXR1cm4gc2VsZi52YWw7IC8vd2hlbiB0aGUgdHlwZSBpcyBtaXhlZCBhbHdheXMgdXNlcyB2YWxcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmICh0eXBlID09PSAxKSB7XG4gICAgICAgICAgb2JqID0gW107XG4gICAgICAgICAgZm9yIChpID0gLTEsIGwgPSBzZWxmLmxlbmd0aCAtIDE7IGkgPCBsOyBzZWxmWysraV0gJiYgb2JqLnB1c2goc2VsZltpXS5yYXcpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBvYmogPSB7fTtcbiAgICAgICAgICBmb3IgKGkgaW4gc2VsZikge1xuICAgICAgICAgICAgaWYgKCFfYyhzZWxmLl9ibGFja2xpc3QsIGkpICYmIHNlbGZbaV0pIHtcbiAgICAgICAgICAgICAgb2JqW2ldID0gc2VsZltpXS5yYXc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgICB9XG4gICAgfVxuICB9LFxuICAvKipcbiAgICogR2V0cy9zZXRzIG9iamVjdCBvcmlnaW5cbiAgICogSW4gYSBjaGFpbiBvZiBWLk9iamVjdHMgZS5nLiB4LnZhbCA9IHksIHkudmFsID0geiAtLS0+IHguZnJvbSByZXR1cm5zIHo7XG4gICAqIEBhdHRyaWJ1dGUgZnJvbVxuICAgKi9cbiAgJ2Zyb20nLCB7XG4gICAgc2V0OiBmdW5jdGlvbih2YWwpIHtcbiAgICAgIHZhciBmb3VuZCA9IF9mcm9tKHRoaXMpXG4gICAgICBfY29yZVNldC5jYWxsKGZvdW5kIHx8IHRoaXMsIHZhbClcbiAgICB9LFxuICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gX2Zyb20odGhpcykgfHwgdGhpc1xuICAgIH1cbiAgfSxcbiAgLyoqXG4gICAqIE1lcmdlIGFueSBvYmplY3QgaW50byBhbm90aGVyIG9iamVjdFxuICAgKiBTaGFsbG93IGZvciBhIHNoYWxsb3cgbWVyZ2VcbiAgICogQG1ldGhvZCBtZXJnZVxuICAgKiBAcGFyYW0gIHtPYmplY3R9ICBvYmogICAgICBbZGVzY3JpcHRpb25dXG4gICAqIEBwYXJhbSAge0Jvb2xlYW59IHNoYWxsb3cgIFtkZXNjcmlwdGlvbl1cbiAgICogQHBhcmFtICB7TnVtYmVyfSAgc3RhbXAgICAgW2Rlc2NyaXB0aW9uXVxuICAgKiBAcGFyYW0gIHtCb29sZWFufSBub3VwZGF0ZSBbZGVzY3JpcHRpb25dXG4gICAqIEByZXR1cm4ge09iamVjdH0gICAgICAgICAgIFtkZXNjcmlwdGlvbl1cbiAgICovXG4gICdtZXJnZScsIGZ1bmN0aW9uIG1lcmdlKCBvYmosIHNoYWxsb3csIHN0YW1wLCBub3VwZGF0ZSwgYmxvY2ssIHNvcnRlZCwgZGVmZXJVcGRhdGVzICkge1xuXG4gICAgLy8gY29uc29sZS5sb2coJ01FUkdFLS0tLT4nLCBvYmogKVxuXG4gICAgdmFyIG1lcmdlQXJyYXkgPSB0aGlzLl9tZXJnZUFycmF5XG4gICAgICAsIHJcbiAgICAgICwgaVxuICAgICAgLCBzdG9wXG4gICAgICAsIHJ0XG4gICAgICAsIGNvYmpcbiAgICAgICwgdG9ialxuICAgICAgLCB0b3BMZXZlbFxuXG4gICAgaWYoIWRlZmVyVXBkYXRlcykge1xuICAgICAgLy8gY29uc29sZS5sb2coJ05PIGRlZmVyVXBkYXRlcycueWVsbG93LmludmVyc2UpXG4gICAgICB0b3BMZXZlbCA9IHRydWVcbiAgICAgIGRlZmVyVXBkYXRlcyA9IFtdXG4gICAgfVxuICAgIC8vRklYTUU6IG1ha2UgaXQgYmV0dGVyIGxvbmcgbmFtZXMgZXRjLCBjb2RlIGZvcm1hdHRpbmdcblxuICAgIGlmICggIXN0YW1wICkgc3RhbXAgPSB0aGlzLnN0YW1wKClcblxuICAgIGlmICggdGhpcy5fX3QgPT09IDEgKSB7XG4gICAgICBpZiAobWVyZ2VBcnJheSkge1xuICAgICAgICBtZXJnZUFycmF5KCBvYmosIHN0YW1wLCBub3VwZGF0ZSApIC8vaGllciBtb2V0IG9vayBmZiBkZWZlclVwZGF0ZXNcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZvciAodmFyIGogaW4gb2JqKSB7XG4gICAgICAgICAgY29iaiA9IG9ialtqXVxuICAgICAgICAgIHRvYmogPSB0aGlzW2pdXG4gICAgICAgICAgaWYgKChqID0gTnVtYmVyKGopKSA+IC0xKSB7XG4gICAgICAgICAgICByID0gdHJ1ZVxuICAgICAgICAgICAgaWYgKHRvYmopIHtcbiAgICAgICAgICAgICAgdG9iai5tZXJnZShjb2JqLCBmYWxzZSwgc3RhbXAsIHRydWUsIGJsb2NrLCBzb3J0ZWQsIGRlZmVyVXBkYXRlcyApXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBpZiAoaiA+IHRoaXMubGVuZ3RoIC0gMSkgdGhpcy5sZW5ndGggPSBqICsgMVxuICAgICAgICAgICAgICB0aGlzLnNldChqLCBjb2JqLCBmYWxzZSwgc3RhbXAsIHRydWUsIHRydWUpXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGZvciAoaSBpbiBvYmopIHtcbiAgICAgICAgc3RvcCA9IHRydWVcbiAgICAgICAgY29iaiA9IG9ialtpXVxuICAgICAgICB0b2JqID0gdGhpc1tpXVxuICAgICAgICBpZiAoaSAhPT0gJ3ZhbCcgJiYgIV9jKHRoaXMuX2JsYWNrbGlzdCwgaSkpIHtcbiAgICAgICAgICBpZiAoIXNoYWxsb3cgJiYgdG9iaiAmJiB1dGlsLmlzT2JqKGNvYmopKSB7IC8vY29iaiBpbnN0YW5jZW9mIE9iamVjdCAmJiAodHlwZW9mIGNvYmogIT09ICdmdW5jdGlvbicpICYmIGNvYmouX190ICE9PSAzKVxuICAgICAgICAgICAgaWYgKGNvYmouY2xlYXIpIHtcbiAgICAgICAgICAgICAgX2NvcmVTZXQuY2FsbCh0b2JqLCBjb2JqLCBzdGFtcCwgZmFsc2UsIHRydWUpXG4gICAgICAgICAgICAgIHIgPSB0cnVlXG4gICAgICAgICAgICB9IGVsc2Uge1xuXG4gICAgICAgICAgICAgIC8vIGNvbnNvbGUuZXJyb3IoJy0tLS0gbWVyZ2UgL3cgdXBkYXRlIHRoYXRzIG1vcyBkZWYgd3JvbmchJywgaSwgZGVmZXJVcGRhdGVzKVxuICAgICAgICAgICAgICAvL2RlZmVyVXBkYXRlc1xuXG4gICAgICAgICAgICAgIHJ0ID0gdG9iai5tZXJnZShjb2JqLCBmYWxzZSwgc3RhbXAsIHRydWUsIGJsb2NrLCBzb3J0ZWQsIGRlZmVyVXBkYXRlcyApXG4gICAgICAgICAgICAgIGlmIChyICE9PSB0cnVlKSByID0gcnRcblxuICAgICAgICAgICAgICBpZiAoIXJ0KSBcbiAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKCcwMDAwJylcbiAgICAgICAgICAgICAgICBvYmpbaV0gPSB2b2lkIDBcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgICAgIGlmICh0b2JqICYmIHRvYmouX3ZhbCA9PT0gY29iaikgeyAvL2NoYW5nZWQgdG8gZGlmZmVyZW50aWF0ZSBiZXR3ZWVuIDAgYW5kIGZhbHNlLCBub3cgYWxzbyBkaWZmZXJlbnRpYXRlcyBiZXR3ZWVuIDEgYW5kICcxJ1xuICAgICAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKCctLS0tIDIgdXBkYXRlIHRoYXRzIG1vcyBkZWYgd3JvbmchJywgaSlcblxuICAgICAgICAgICAgICBpZiAociAhPT0gdHJ1ZSkgciA9IGZhbHNlXG4gICAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKCc/Pz8/Pz8/JylcbiAgICAgICAgICAgICAgb2JqW2ldID0gdm9pZCAwXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAvLyBjb25zb2xlLmxvZygnLS0tLSAzIHVwZGF0ZSB0aGF0cyBtb3MgZGVmIHdyb25nIScsIGkpXG4gICAgICAgICAgICAgIGlmKGNvYmo9PT1udWxsICYmIHRoaXNbaV0pIHtcbiAgICAgICAgICAgICAgICB0aGlzW2ldLnJlbW92ZSggZmFsc2UsIGZhbHNlLCBmYWxzZSwgdm9pZCAwLCBzdGFtcCApXG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gY29uc29sZS5sb2coJyE/Jy5ib2xkLCBpLCB0aGlzW2ldKVxuICAgICAgICAgICAgICAgIC8vbmFtZSwgdmFsLCB2b2JqLCBzdGFtcCwgbm91cGRhdGUsIGZyb21cbiAgICAgICAgICAgICAgICB0aGlzLnNldCggaSwgY29iaiwgZmFsc2UsIHN0YW1wLCB0cnVlIClcbiAgICAgICAgICAgICAgICAvLyBjb25zb2xlLmxvZygnIXh4eHg/JywgaSlcbiAgICAgICAgICAgICAgICBpZih0aGlzW2ldICYmIHRoaXNbaV0uX2xpc3RlbmVycykge1xuICAgICAgICAgICAgICAgICAgLy8gY29uc29sZS5sb2coJ3B1c2ggcHVzaCcuZ3JlZW4sICBKU09OLnN0cmluZ2lmeShvYmopIClcbiAgICAgICAgICAgICAgICAgIGRlZmVyVXBkYXRlcy5wdXNoKCBbdGhpc1tpXSwgY29ial0gKVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvL2FkZCBkaXQgbmFhciBsaXN0XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKCFyKSByID0gcnQ7XG5cbiAgICAgICAgICAgICAgLy8gY29uc29sZS53YXJuKHIsIHJ0KVxuXG4gICAgICAgICAgICAgIGlmICghcnQpIFxuICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgLy9UT0RPOiBURU1QIEZJWCBET05UIEtOT1cgSUYgVEhJUyBXT1JLUyFcbiAgICAgICAgICAgICAgICAvLyBjb25zb2xlLmxvZygnPz8/Pz8/PzIyMjIyJylcbiAgICAgICAgICAgICAgICAvLyBvYmpbaV0gPSB2b2lkIDBcbiAgICAgICAgICAgICAgICAvLyBjb25zb2xlLndhcm4oJ2NhbnQgYmUgcmlnaHQhJylcbiAgICAgICAgICAgICAgICAvL1NVUEVSIENBUkVGVUxMIFdJVEggVEhJUyBSIFRISU5HISEhISFcbiAgICAgICAgICAgICAgICByID0gdHJ1ZVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAob2JqLnZhbCkge1xuICAgICAgICBydCA9IF9jb3JlU2V0LmNhbGwodGhpcywgb2JqLnZhbCwgc3RhbXAsIGZhbHNlLCB0cnVlKVxuICAgICAgICBpZiAoIXIpIHtcbiAgICAgICAgICByID0gcnRcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXJ0KSB7XG4gICAgICAgICAgb2JqLnZhbCA9IHZvaWQgMFxuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKCFzdG9wKSB7XG4gICAgICAgIGlmICghcikge1xuICAgICAgICAgIHIgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgciA9IChyICE9PSBmYWxzZSkgfHwgclxuICAgIH1cblxuICAgIGlmIChyKSB7XG4gICAgICBpZiAoIWJsb2NrKSB7XG4gICAgICAgIC8vIGFsZXJ0KG5vdXBkYXRlKVxuICAgICAgICBpZiAobm91cGRhdGUpIHtcblxuICAgICAgICAgIC8vIGNvbnNvbGUubG9nKCchIT8/Pz8/Pz8/Pz8/IE5PVVBEQVRFJy5ibHVlLCBKU09OLnN0cmluZ2lmeShvYmopKVxuXG4gICAgICAgICAgaWYodG9wTGV2ZWwpIHtcbiAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKCdVUERBVEU+PycubWFnZW50YS5pbnZlcnNlLCBvYmosIEpTT04uc3RyaW5naWZ5KCBvYmogKSwgbm91cGRhdGUsIHN0YW1wKVxuICAgICAgICAgICAgdGhpcy5fdXBkYXRlKG9iaiwgc3RhbXApXG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fX3VwZGF0ZShvYmosIHN0YW1wKVxuICAgICAgICAgICAgZGVmZXJVcGRhdGVzLnB1c2goWyB0aGlzLCBvYmogXSlcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgXG4gICAgICAgICAgLy8gY29uc29sZS5sb2coJzJVUERBVEU+PycuY3lhbi5pbnZlcnNlLCB0b3BMZXZlbCwgZGVmZXJVcGRhdGVzLCBvYmosIG5vdXBkYXRlLCBzdGFtcClcblxuICAgICAgICAgIHRoaXMuX3VwZGF0ZSggb2JqLCBzdGFtcCApXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICBcblxuICAgIGlmKHRvcExldmVsICYmIGRlZmVyVXBkYXRlcykge1xuICAgICAgLy8gY29uc29sZS5sb2coICdkZWZlcmVkIHVwZGFjZScsIHRvcExldmVsLCBkZWZlclVwZGF0ZXMpXG4gICAgICBmb3IodmFyIGRmIGluIGRlZmVyVXBkYXRlcykge1xuICAgICAgICBpZiggZGVmZXJVcGRhdGVzW2RmXVswXSAmJiBkZWZlclVwZGF0ZXNbZGZdWzBdLl9fdXBkYXRlICkge1xuICAgICAgICAgIC8vIGNvbnNvbGUubG9nKCdERUZFUkVEISEhIScuY3lhbi5pbnZlcnNlLCBkZiwgZGVmZXJVcGRhdGVzW2RmXVsxXSwgc3RhbXAgKVxuICAgICAgICAgIGRlZmVyVXBkYXRlc1tkZl1bMF0uX191cGRhdGUoIGRlZmVyVXBkYXRlc1tkZl1bMV0sIHN0YW1wIClcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gclxuICB9LFxuICAvKipcbiAgICogQ29waWVzIGFuIG9iamVjdCBhbmQgcmV0dXJucyBhIG5ldyBvbmUsIGNhbiBhbHNvIHBhc3MgYSBtZXJnZSBvYmplY3RcbiAgICogQG1ldGhvZFxuICAgKiBAcGFyYW0gIHtPYmplY3R9ICAgICAgICBvYmogICAgICAgT2JqZWN0IHRvIGNvcHlcbiAgICogQHBhcmFtICB7Qm9vbGVhbn0gICAgICAgW3NoYWxsb3ddIFtkZXNjcmlwdGlvbl1cbiAgICogQHBhcmFtICB7QXJyYXl8T2JqZWN0fSAgW2xpc3RdICAgIFRha2VzIGFueSBvYmplY3Qgd2l0aCAubGVuZ3RoXG4gICAqIEBwYXJhbSAge09iamVjdH0gICAgICAgIFtwYXJlbnRdICBbZGVzY3JpcHRpb25dXG4gICAqIEByZXR1cm4ge09iamVjdH0gICAgICAgICAgICAgICAgICBbZGVzY3JpcHRpb25dXG4gICAqL1xuICAnY2xvbmUnLCBmdW5jdGlvbihvYmosIHNoYWxsb3csIGxpc3QsIHBhcmVudCkgeyAvL3N1cHBvcnQgc2hhbGxvdyE7IGNoZWNrIG9iaiBjb3B5IG9ubHkgd2hhdCBpcyBuZXNzZWNhcnkgYWRkZWQgbWFrZXNob3J0ICwgbWFkZSBwYXJlbnQgc2hvcnRlclxuICAgIHZhciBjb3B5ID0gbmV3IHRoaXMuX2NsYXNzKCksXG4gICAgICBfdmFsID0gdGhpcy5fdmFsLFxuICAgICAgaTtcbiAgICBpZiAocGFyZW50KSB7XG4gICAgICBjb3B5Ll9wYXJlbnQgPSBwYXJlbnQ7XG4gICAgfVxuICAgIGNvcHkuX190ID0gdGhpcy5fX3Q7XG4gICAgaWYgKHRoaXMuX190ID09PSAxKSB7XG4gICAgICBjb3B5Lmxlbmd0aCA9IHRoaXMubGVuZ3RoO1xuICAgIH1cbiAgICBpZiAobGlzdCkge1xuICAgICAgLy9saXN0XG4gICAgICBmb3IgKHZhciBqID0gbGlzdC5sZW5ndGggLSAxLCBpdGVtOyBqID49IDA7IGotLSkge1xuICAgICAgICBpdGVtID0gbGlzdFtqXTtcblxuICAgICAgICBpZiAoaXRlbSBpbnN0YW5jZW9mIEFycmF5ICYmIHRoaXNbaXRlbVswXV0pIHtcbiAgICAgICAgICBpZihpdGVtWzFdID09PSB0cnVlKSB7XG4gICAgICAgICAgICBjb3B5W2l0ZW1bMF1dID0gdXRpbC5jbG9uZSh0aGlzW2l0ZW1bMF1dLCBmYWxzZSwgdHJ1ZSlcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29weVtpdGVtWzBdXSA9IGl0ZW1bMV07XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKHRoaXNbaXRlbV0pIHtcbiAgICAgICAgICAvLyBjb25zb2xlLmxvZyhpdGVtKVxuICAgICAgICAgIGNvcHlbaXRlbV0gPSB0aGlzW2l0ZW1dO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChfdmFsICYmIChfdmFsIGluc3RhbmNlb2YgVk9iamVjdCAmJiBfdmFsLl9jb250YWluZWQpKSB7XG4gICAgICBjb3B5LnZhbCA9IF92YWwuY2xvbmUoY29weSwgZmFsc2UsIGxpc3QsIGNvcHkpO1xuICAgICAgY29weS5fdmFsLl9jb250YWluZWQgPSB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICBWT2JqZWN0LnNldC5jYWxsKGNvcHksIF92YWwsIGZhbHNlLCBmYWxzZSwgdHJ1ZSk7XG4gICAgfVxuICAgIGZvciAoaSBpbiB0aGlzKSB7XG4gICAgICBpZiAoIV9jKHRoaXMuX2JsYWNrbGlzdCwgaSkpIHtcbiAgICAgICAgLy8gY29uc29sZS5sb2coaSlcbiAgICAgICAgaWYgKCFzaGFsbG93KSB7XG4gICAgICAgICAgaWYgKHRoaXNbaV0gaW5zdGFuY2VvZiBWT2JqZWN0KSB7XG4gICAgICAgICAgICAvL2Z1bmN0aW9uKCBuYW1lLCB2YWwsIHZvYmosIHN0YW1wLCBub3VwZGF0ZSwgZnJvbSApXG5cbiAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKCctLS0tLT4xJywgaSwgdGhpc1tpXS5jbG9uZSh2b2lkIDAsIGZhbHNlLCBsaXN0LCBjb3B5KSlcbiAgICAgICAgICAgIC8vc3RhbXAgdm9pZCAwXG4gICAgICAgICAgICBjb3B5LnNldChpLCB0aGlzW2ldLmNsb25lKHZvaWQgMCwgZmFsc2UsIGxpc3QsIGNvcHkpLCB0cnVlLCBmYWxzZSwgdHJ1ZSlcbiAgICAgICAgICB9IGVsc2Uge1xuXG4gICAgICAgICAgICAvLyBjb25zb2xlLmxvZygnLS0tLS0+MicsIGksIHV0aWwuY2xvbmUodGhpc1tpXSkpXG5cbiAgICAgICAgICAgIGNvcHlbaV0gPSB1dGlsLmNsb25lKHRoaXNbaV0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvL2Z1bmN0aW9uKCBuYW1lLCB2YWwsIHZvYmosIHN0YW1wLCBub3VwZGF0ZSwgZnJvbSApXG4gICAgICAgICAgY29weS5zZXQoaSwgdGhpc1tpXSwgZmFsc2UsIGZhbHNlLCB0cnVlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBpZiAob2JqICE9PSB2b2lkIDApIHtcbiAgICAgIGlmICh1dGlsLmlzT2JqKG9iaikpIHtcbiAgICAgICAgLy8gY29uc29sZS5sb2coJ01FUkdFLS0tLS0+Jywgb2JqLCBzaGFsbG93KVxuICAgICAgICBjb3B5Lm1lcmdlKG9iaiwgc2hhbGxvdyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBWT2JqZWN0LnNldC5jYWxsKGNvcHksIG9iaiwgZmFsc2UsIGZhbHNlLCB0cnVlKVxuICAgICAgfVxuICAgIH1cbiAgICBjb3B5Ll9fdCA9IHRoaXMuX190O1xuICAgIHJldHVybiBjb3B5O1xuICB9LFxuICAvKipcbiAgICogUmV0dXJucyBvYmplY3Qgb24gdGhlIGVuZCBvZiBhIGRlZmluZWQgcGF0aFxuICAgKiBAbWV0aG9kIHBhdGhcbiAgICogQHBhcmFtICB7QXJyYXl9ICAgICBwYXRoICAgICAgICAgICBBcnJheSBvZiBmaWVsZHMgaW4gcGF0aFxuICAgKiBAcGFyYW0gIHsqfSAgICAgICAgIFt2YWxdICAgICAgICAgIFdoZW4gZGVmaW5lZCwgdmFsIHdpbGwgYmUgc2V0IG9uIGVuZHBvaW50IG9mIHBhdGggaWYgbm90IGFscmVhZHkgZGVmaW5lZFxuICAgKiBAcGFyYW0gIHtCb29sZWFufSAgIFtvdmVyd3JpdGVdICAgIElmIHRydWUsIHZhbCBXSUxMIG92ZXJ3cml0ZSBleGlzdGluZyB2YWx1ZSBvbiBlbmRwb2ludCBvZiBwYXRoIHdoZW4gYWxyZWFkeSBkZWZpbmVkXG4gICAqIEBwYXJhbSAge0Z1bmN0aW9ufSAgW3dyaXRlSGFuZGxlcl0gQ2FsbGJhY2sgb24gd3JpdGVcbiAgICogQHJldHVybiB7Kn0gICAgICAgICAgICAgICAgICAgICAgICBPYmplY3Qgb24gdGhlIGVuZCBvZiBhIGRlZmluZWQgcGF0aFxuICAgKi9cbiAgJ3BhdGgnLCBmdW5jdGlvbihwYXRoLCB2YWwsIG92ZXJ3cml0ZSwgd3JpdGVIYW5kbGVyLCB2b2JqLCBzdGFtcCwgbm91cGRhdGUsIHNlbGYpIHtcbiAgICBpZighKHBhdGggaW5zdGFuY2VvZiBBcnJheSkpIHBhdGggPSBwYXRoLnNwbGl0KCcuJyk7XG4gICAgcmV0dXJuIHV0aWwucGF0aCh0aGlzLCBwYXRoLCB2YWwsIG92ZXJ3cml0ZSwgd3JpdGVIYW5kbGVyLCB2b2JqLCBzdGFtcCwgbm91cGRhdGUsIHNlbGYpO1xuICB9LFxuICAvKipcbiAgICogR2V0cyBvYmplY3QgZnJvbSBzcGVjaWZpZWQgcGF0aC4gV2hlbiBwYXRoIGlzIGEgc3RyaW5nIGNoZWNrcyBmb3IgJ2RvdG5vdGF0aW9uJy5cbiAgICogQG1ldGhvZCBnZXRcbiAgICogQHBhcmFtICB7U3RyaW5nfEFycmF5fSBwYXRoIERlZmluZXMgZmllbGQge3N0cmluZ30gb3IgcGF0aCB7YXJyYXl8J2RvdC1ub3RhdGlvbid9XG4gICAqIEByZXR1cm4geyp9ICAgICAgICAgICAgICAgICBvYmpbcGF0aF18bmVzdGVkIG9iamVjdC92YWx1ZVxuICAgKi9cbiAgJ2dldCcsIGZ1bmN0aW9uKHBhdGgsIHNlbGYpIHsgLy9nZXQgZG9lcyBub3QgbmVlZCBhbiBhcnJheSBhcyBwYXRoXG4gICAgcmV0dXJuIHV0aWwuZ2V0KHRoaXMsIHBhdGgsIHNlbGYpO1xuICB9LFxuXG4gIC8vKHZhbCwgc3RhbXAsIGZyb20sIG5vdXBkYXRlLCBhZGQpXG4gIC8vICckc2V0JywgZnVuY3Rpb24oIHZhbCwgc3RhbXAsIGZyb20sIHVwZGF0ZSApIHsgLy9nZXQgZG9lcyBub3QgbmVlZCBhbiBhcnJheSBhcyBwYXRoXG5cbiAgLy8gICByZXR1cm4gVk9iamVjdC5zZXQuY2FsbCggdGhpcywgdmFsLCBzdGFtcCwgZnJvbSwgIXVwZGF0ZSApXG4gICAgXG4gIC8vICAgICAnX3NldCcsIGZ1bmN0aW9uKHZhbCwgc3RhbXAsIGZyb20sIHJlbW92ZSwgbm91cGRhdGUsIGFkZGVkLCBvbGR2YWwpIHtcbiAgLy8gICBpZiAoIW5vdXBkYXRlKSB7XG4gIC8vICAgICAodmFsLCBzdGFtcCwgZnJvbSwgbm91cGRhdGUsIGFkZClcbiAgLy8gICAgIC8vIGNvbnNvbGUubG9nKHRoaXMuX3BhdGgsIHZhbClcbiAgLy8gICAgIHRoaXMuX3VwZGF0ZSh2YWwsIHN0YW1wLCBmcm9tLCByZW1vdmUsIGFkZGVkLCBvbGR2YWwpO1xuICAvLyAgIH1cbiAgICBcblxuICAvLyB9LFxuICAvKipcbiAgICogQ2hlY2sgaWYgb2JqIGlzIGVtcHR5IGV4Y2x1ZGUgZmllbGQgbmFtZXMgcGFzc2VkIHRvIGxpc3RcbiAgICogQG1ldGhvZCBlbXB0eVxuICAgKiBAcmV0dXJuIHtCb29sZWFufSBUcnVlL2ZhbHNlXG4gICAqL1xuICAnZW1wdHknLCB7XG4gICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB1dGlsLmVtcHR5KHRoaXMsIHRoaXMuX2JsYWNrbGlzdCk7XG4gICAgfVxuICB9LFxuICAnJGVtcHR5JywgZnVuY3Rpb24oIGV4Y2x1ZGVzLCB1cGRhdGUgKSB7XG4gICAgICAvL2dldCBkb2VzIG5vdCBuZWVkIGFuIGFycmF5IGFzIHBhdGhcbiAgICAgIHZhciBfdGhpcyA9IHRoaXNcbiAgICAgIHRoaXMuZWFjaCggZnVuY3Rpb24oIGtleSApIHtcbiAgICAgICAgaWYoIFxuICAgICAgICAgICAgIWV4Y2x1ZGVzIFxuICAgICAgICAgICAgICB8fCB0eXBlb2YgZXhjbHVkZXMgPT09ICdzdHJpbmcnICBcbiAgICAgICAgICAgICAgICAgPyBrZXkgIT09IGV4Y2x1ZGVzIFxuICAgICAgICAgICAgICAgICA6ICF1dGlsLmNoZWNrQXJyYXkoIGV4Y2x1ZGVzLCBrZXkgKSBcbiAgICAgICAgICApXG4gICAgICAgIHtcbiAgICAgICAgICBpZiggdGhpcy5yZW1vdmUgKSBcbiAgICAgICAgICB7XG4gICAgICAgICAgICB0aGlzLnJlbW92ZSggZmFsc2UsIGZhbHNlLCBmYWxzZSwgZmFsc2UsIGZhbHNlLCB0cnVlIClcbiAgICAgICAgICB9IFxuICAgICAgICAgIGVsc2UgXG4gICAgICAgICAge1xuICAgICAgICAgICAgLy8gY29uc29sZS53YXJuKCAnJGVtcHR5IG5vbi12T2JqZWN0IG9iamVjdC51dGlsIHJlbW92ZScsIHRoaXMsIGtleSApXG4gICAgICAgICAgICBfdGhpc1trZXldID0gbnVsbFxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSlcbiAgICBcbiAgICAgIGlmKCB0aGlzLmNsZWFyQ2FjaGUgKSB0aGlzLmNsZWFyQ2FjaGUoKVxuXG4gICAgICBpZiggdXBkYXRlIClcbiAgICAgIHtcbiAgICAgICAgdGhpcy5fdXBkYXRlKCdlbXB0eScpXG4gICAgICB9XG4gIH0sXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBWLk9iamVjdCBmcm9tIHdoaWNoIHRoZSBjdXJyZW50IHVwZGF0ZSBvcmlnaW5hdGVkLlxuICAgKiBAbWV0aG9kIF91cGRhdGVPcmlnaW5cbiAgICogQHJldHVybiB7Vi5PYmplY3R9IG9yaWdpbiBvZiB0aGUgdXBkYXRlXG4gICAqL1xuICAnX3VwZGF0ZU9yaWdpbicsIHtcbiAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIG1hcmsgPSB0aGlzO1xuICAgICAgd2hpbGUgKG1hcmsuX2xmcm9tKSB7XG4gICAgICAgIG1hcmsgPSBtYXJrLl9sZnJvbTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBtYXJrO1xuICAgIH1cbiAgfSxcbiAgJ19vcmlnaW4nLCB7XG4gICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBtYXJrID0gdGhpcztcbiAgICAgIHdoaWxlIChtYXJrICYmIG1hcmsuX190ID09PSA0KSB7XG4gICAgICAgIG1hcmsgPSBtYXJrLl92YWw7XG4gICAgICB9XG4gICAgICByZXR1cm4gbWFyaztcbiAgICB9XG4gIH1cbilcblxuXG4vL2FkZCBmaW5kXG5cbiIsIi8qIVxuICogQGxpY2Vuc2UgQ29weXJpZ2h0IChjKSAyMDEyLTIwMTQsIFZpZ291ci4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIEBhdXRob3I6IFlvdXJpIERhYW1lbiwgeW91cmlAdmlnb3VyLmlvXG4gKi9cblxudmFyIEVsZW1lbnQgPSByZXF1aXJlKCcuLi8uLi9icm93c2VyL2VsZW1lbnQnKVxuXG5yZXF1aXJlKCcuLi8uLi92YWx1ZS9mbGFncy9wYXJlbnQnKVxucmVxdWlyZSgnLi4vLi4vdmFsdWUvZmxhZ3Mvc2VsZicpXG5yZXF1aXJlKCcuLi8uLi92YWx1ZS9mbGFncy9wcm9jZXNzJylcbnJlcXVpcmUoJy4uLy4uL3ZhbHVlL2ZsYWdzL3V0aWwnKVxucmVxdWlyZSgnLi4vLi4vYnJvd3Nlci9ldmVudHMnKVxuXG5tb2R1bGUuZXhwb3J0cyA9XG4gIEVsZW1lbnRcbiAgLmluamVjdFxuICAoIHJlcXVpcmUoJy4uLy4uL2Jyb3dzZXIvZWxlbWVudC9wcm9wZXJ0aWVzL2NvbGxlY3Rpb24nKVxuICAsIHJlcXVpcmUoJy4uLy4uL2Jyb3dzZXIvZWxlbWVudC9wcm9wZXJ0aWVzJylcbiAgLCByZXF1aXJlKCcuLi8uLi9icm93c2VyL2VsZW1lbnQvcHJvcGVydGllcy9zY3JvbGxiYXInKVxuICAsIHJlcXVpcmUoJy4uLy4uL2Jyb3dzZXIvZWxlbWVudC9wcm9wZXJ0aWVzL3Byb2Nlc3MnKVxuICAsIHJlcXVpcmUoJy4uLy4uL3ZhbHVlL29uJylcbiAgKVxuXG4iLCIvL2NoZWNrIHRoaXMgZm9yIG1vcmUgY29tcHJlc3Npb24gaHR0cDovL3d3dy5odG1sZ29vZGllcy5jb20vaHRtbDUvY2xpZW50L29wdGltaXppbmctd2Vic29ja2V0cy1iYW5kd2lkdGguaHRtbCNmYmlkPTZRWng4bmFwdTIwXG5cbi8qXG52YXIgY3JjVGFibGVcbiAgLCBjcmVhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBjcmNUYWJsZSA9IFtdXG4gICAgICBmb3IgKHZhciBjLCBuID0gMCwgazsgbiA8IDI1NjsgYyA9ICsrbikge1xuICAgICAgICBmb3IgKGsgPSAwOyBrIDwgODsgaysrLCBjID0gKChjICYgMSkgPyAoKDB4RURCODgzMjApIF4gKGMgPj4+IDEpKSA6IChjID4+PiAxKSkpO1xuICAgICAgICBjcmNUYWJsZVtuXSA9IGNcbiAgICAgIH1cbiAgICAgIHJldHVybiBjcmNUYWJsZVxuICAgIH1cblxuZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKHN0cikge1xuICBmb3IgKHZhciB0YWIgPSBjcmNUYWJsZSB8fCBjcmVhdGUoKSwgY3JjID0gLTEsIGkgPSAwLCBsID0gc3RyLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIGNyYyA9IChjcmMgPj4+IDgpIF4gdGFiWyhjcmMgXiBzdHIuY2hhckNvZGVBdChpKSkgJiAweEZGXVxuICB9XG4gIHJldHVybiBleHBvcnRzLmVuY29kZSgoKGNyYyBeICgtMSkpID4+PiAwKSlcbn1cblxuXG4qL1xuXG5leHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihrZXksIHNlZWQpIHtcbiAgdmFyIHJlbWFpbmRlciwgYnl0ZXMsIGgxLCBoMWIsIGMxLCBjMWIsIGMyLCBjMmIsIGsxLCBpO1xuICBzZWVkID0gMVxuXG4gIHJlbWFpbmRlciA9IGtleS5sZW5ndGggJiAzOyAvLyBrZXkubGVuZ3RoICUgNFxuICBieXRlcyA9IGtleS5sZW5ndGggLSByZW1haW5kZXI7XG4gIGgxID0gc2VlZDtcbiAgYzEgPSAweGNjOWUyZDUxO1xuICBjMiA9IDB4MWI4NzM1OTM7XG4gIGkgPSAwO1xuICBcbiAgd2hpbGUgKGkgPCBieXRlcykge1xuICAgICAgazEgPSBcbiAgICAgICAgKChrZXkuY2hhckNvZGVBdChpKSAmIDB4ZmYpKSB8XG4gICAgICAgICgoa2V5LmNoYXJDb2RlQXQoKytpKSAmIDB4ZmYpIDw8IDgpIHxcbiAgICAgICAgKChrZXkuY2hhckNvZGVBdCgrK2kpICYgMHhmZikgPDwgMTYpIHxcbiAgICAgICAgKChrZXkuY2hhckNvZGVBdCgrK2kpICYgMHhmZikgPDwgMjQpO1xuICAgICsraTtcbiAgICBcbiAgICBrMSA9ICgoKChrMSAmIDB4ZmZmZikgKiBjMSkgKyAoKCgoazEgPj4+IDE2KSAqIGMxKSAmIDB4ZmZmZikgPDwgMTYpKSkgJiAweGZmZmZmZmZmO1xuICAgIGsxID0gKGsxIDw8IDE1KSB8IChrMSA+Pj4gMTcpO1xuICAgIGsxID0gKCgoKGsxICYgMHhmZmZmKSAqIGMyKSArICgoKChrMSA+Pj4gMTYpICogYzIpICYgMHhmZmZmKSA8PCAxNikpKSAmIDB4ZmZmZmZmZmY7XG5cbiAgICBoMSBePSBrMTtcbiAgICAgICAgaDEgPSAoaDEgPDwgMTMpIHwgKGgxID4+PiAxOSk7XG4gICAgaDFiID0gKCgoKGgxICYgMHhmZmZmKSAqIDUpICsgKCgoKGgxID4+PiAxNikgKiA1KSAmIDB4ZmZmZikgPDwgMTYpKSkgJiAweGZmZmZmZmZmO1xuICAgIGgxID0gKCgoaDFiICYgMHhmZmZmKSArIDB4NmI2NCkgKyAoKCgoaDFiID4+PiAxNikgKyAweGU2NTQpICYgMHhmZmZmKSA8PCAxNikpO1xuICB9XG4gIFxuICBrMSA9IDA7XG4gIFxuICBzd2l0Y2ggKHJlbWFpbmRlcikge1xuICAgIGNhc2UgMzogazEgXj0gKGtleS5jaGFyQ29kZUF0KGkgKyAyKSAmIDB4ZmYpIDw8IDE2O1xuICAgIGNhc2UgMjogazEgXj0gKGtleS5jaGFyQ29kZUF0KGkgKyAxKSAmIDB4ZmYpIDw8IDg7XG4gICAgY2FzZSAxOiBrMSBePSAoa2V5LmNoYXJDb2RlQXQoaSkgJiAweGZmKTtcbiAgICBcbiAgICBrMSA9ICgoKGsxICYgMHhmZmZmKSAqIGMxKSArICgoKChrMSA+Pj4gMTYpICogYzEpICYgMHhmZmZmKSA8PCAxNikpICYgMHhmZmZmZmZmZjtcbiAgICBrMSA9IChrMSA8PCAxNSkgfCAoazEgPj4+IDE3KTtcbiAgICBrMSA9ICgoKGsxICYgMHhmZmZmKSAqIGMyKSArICgoKChrMSA+Pj4gMTYpICogYzIpICYgMHhmZmZmKSA8PCAxNikpICYgMHhmZmZmZmZmZjtcbiAgICBoMSBePSBrMTtcbiAgfVxuICBcbiAgaDEgXj0ga2V5Lmxlbmd0aDtcblxuICBoMSBePSBoMSA+Pj4gMTY7XG4gIGgxID0gKCgoaDEgJiAweGZmZmYpICogMHg4NWViY2E2YikgKyAoKCgoaDEgPj4+IDE2KSAqIDB4ODVlYmNhNmIpICYgMHhmZmZmKSA8PCAxNikpICYgMHhmZmZmZmZmZjtcbiAgaDEgXj0gaDEgPj4+IDEzO1xuICBoMSA9ICgoKChoMSAmIDB4ZmZmZikgKiAweGMyYjJhZTM1KSArICgoKChoMSA+Pj4gMTYpICogMHhjMmIyYWUzNSkgJiAweGZmZmYpIDw8IDE2KSkpICYgMHhmZmZmZmZmZjtcbiAgaDEgXj0gaDEgPj4+IDE2O1xuXG4gIHJldHVybiAoaDEgPj4+IDApLnRvU3RyaW5nKDM2KVxufVxuXG4vLyBleHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiggc3RyIClcbi8vIHtcbi8vICAgdmFyIEZOVjFfMzJBX0lOSVQgPSAweDgxMWM5ZGM1O1xuLy8gICB2YXIgaHZhbCA9IEZOVjFfMzJBX0lOSVQ7XG4vLyAgIGZvciAoIHZhciBpID0gMDsgaSA8IHN0ci5sZW5ndGg7ICsraSApXG4vLyAgIHtcbi8vICAgICBodmFsIF49IHN0ci5jaGFyQ29kZUF0KGkpO1xuLy8gICAgIGh2YWwgKz0gKGh2YWwgPDwgMSkgKyAoaHZhbCA8PCA0KSArIChodmFsIDw8IDcpICsgKGh2YWwgPDwgOCkgKyAoaHZhbCA8PCAyNCk7XG4vLyAgIH1cbi8vICAgcmV0dXJuIGh2YWwgPj4+IDA7XG4vLyB9XG5cbi8qKlxuICogRW5jb2RlIHRvIGJhc2UgNjIgKHVybCBzYXZlKVxuKi9cbmV4cG9ydHMuZW5jb2RlID0gZnVuY3Rpb24gYyAoYSwgYikge1xuICBiID0gYiB8fCBcIlwiXG4gIHJldHVybiB+fiBhIFxuICAgICAgID8gYyhhIC8gNjIsIFN0cmluZy5mcm9tQ2hhckNvZGUoKChhICU9IDYyKSA+IDkgXG4gICAgICAgICAgPyBhID4gMzUgPyAyOSA6IDg3IFxuICAgICAgICAgIDogNDgpICsgYSkgKyBiKSBcbiAgICAgICA6IGJcbn1cblxuLyoqXG4gKiBkZWNvZGUgYmFzZSA2MlxuKi9cbmV4cG9ydHMuZGVjb2RlID0gZnVuY3Rpb24gKGEsIGIsIGMsIGQpIHtcbiAgZm9yIChiID0gYyA9IDA7IGQgPSBhLmNoYXJDb2RlQXQoYysrKTsgYiA9IGIgKiA2MiArIGQgLSBbICwgNDgsIDI5LCA4N11bZCA+PiA1XSk7XG4gIHJldHVybiBiXG59XG5cblxuLy8gZXhwb3J0cy5kZWNvZGU2NFxuIiwiLyohXG4gKiBAbGljZW5zZSBDb3B5cmlnaHQgKGMpIDIwMTItMjAxNCwgVmlnb3VyLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogQGF1dGhvcjogSmltIGRlIEJlZXIsIGppbUB2aWdvdXIuaW9cbiAqL1xucmVxdWlyZSgnLi9vYmplY3QnKSAvL3RoZXNlIHRoaW5ncyBhZGQgZXh0cmEgbWV0aG9kcyB0byB1dGlsIGZvciByZWFkYWJpbGl0eSBpbiBhIHNlcGVyYXRlIG1vZHVsZVxucmVxdWlyZSgnLi9wcm9wJylcblxuZXhwb3J0cy5pc05vZGUgPSAodHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcpID8gdHJ1ZSA6IGZhbHNlXG5cbi8qKlxuICogQWRkIGlzIHNpbWlsYXIgdG8gLnB1c2ggaXQgcmV0dXJucyB0aGUgYXJyYXkgaW5zdGVhZCBvZiBsZW5ndGhcbiAqIENhbiBiZSBleHRlbmRlZCB0byBzdXBwb3J0IG1vcmUgdHlwZXMgZS5nLiBhZGQgYW4gb2JqZWN0IHRvIGFub3RoZXJcbiAqIEBtZXRob2QgYWRkXG4gKiBAcGFyYW0gIHtBcnJheX0gIG9iaiBUYXJnZXRcbiAqIEBwYXJhbSAge09iamVjdH0gYWRkIE9iamVjdCB0byBhZGRcbiAqIEBkZXByZWNhdGVkXG4gKi9cbmV4cG9ydHMuYWRkID0gZnVuY3Rpb24gKG9iaiwgYWRkKSB7XG4gIGlmIChhZGQpIG9iai5wdXNoLmFwcGx5KG9iaiwgYWRkKTtcbiAgcmV0dXJuIG9ialxufVxuXG4vKipcbiAqIEZpbmRzIGl0ZW1zIGluIGFuIGFycmF5XG4gKiBAbWV0aG9kIGNoZWNrQXJyYXlcbiAqIEBwYXJhbSAge09iamVjdHxBcnJheX0gICAgICAgICAgICAgICAgIGxpc3QgIERlZmluZXMgdGhlIGxpc3Qgd2hlcmUgeW91IHdhbnQgdG8gc2VhcmNoIHRocm91Z2gsIG9ubHkgdXNlcyAubGVuZ3RoIGZpZWxkXG4gKiBAcGFyYW0gIHtPYmplY3R9ICAgICAgICAgICAgICAgICAgICAgICB2YWwgICBEZWZpbmVzIHRoZSB2YWx1ZSB5b3Ugd2FudCB0byBzZWFyY2ggZm9yXG4gKiBAcGFyYW0gIHtCb29sZWFufFN0cmluZ3xOdW1iZXJ9ICAgICAgICBbaW5kZXhdIFdoZW4gaW5kZXggaXMgdHJ1ZSByZXR1cm4gdGhlIGluZGV4IGluc3RlYWQgb2YgdHJ1ZSBvciBmYWxzZSwgd2hlbiBpbmRleCBhbmQgaW5kZXggIT09IHRydWUgaW5kZXggaXMgdXNlZCBhcyBhIGZpZWxkIGluIG9iamVjdHMgaW4gdGhlIGFycmF5XG4gKiBAcGFyYW0gIHtTdHJpbmd9ICAgICAgICAgICAgICAgICAgICAgICBbZmllbGRdIFdoZW4gZmllbGQgcmV0dXJuIGZpZWxkIGluc3RlYWQgb2YgaW5kZXggb3IgdHJ1ZVxuICogQHJldHVybiB7Kn1cbiAqL1xuZXhwb3J0cy5jaGVja0FycmF5ID0gZnVuY3Rpb24gKGxpc3QsIHZhbCwgaW5kZXgsIGZpZWxkKSB7XG4gIHZhciBhcnIgPSBpbmRleCBpbnN0YW5jZW9mIEFycmF5XG4gIGlmKCFsaXN0KSByZXR1cm4gZmFsc2VcbiAgZm9yICh2YXIgaSA9IDAsIGwgPSBsaXN0Lmxlbmd0aCwgdDsgaSA8IGw7IGkrKykge1xuICAgIHQgPSBsaXN0W2ldXG4gICAgaWYgKGluZGV4ICE9PSB2b2lkIDApIHtcbiAgICAgIGlmIChpbmRleCA9PT0gdHJ1ZSkge1xuICAgICAgICBpZiAodCA9PT0gdmFsKSByZXR1cm4gaVxuICAgICAgfSBlbHNlIGlmIChhcnIgPyBleHBvcnRzLnBhdGgodCxpbmRleCk9PT12YWwgOiB0W2luZGV4XSA9PT0gdmFsKSByZXR1cm4gZmllbGQgPyB0IDogaVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAodCA9PT0gdmFsKSByZXR1cm4gdHJ1ZVxuICAgIH1cbiAgfVxuICByZXR1cm4gZmFsc2Vcbn1cblxuLyoqXG4gKiBQYXNzIGFyZ3VtZW50cyAoYXJndW1lbnRzKSBhbmQgcmV0dXJuIGEgbmV3IGFycmF5LCB3aGVuIGluZGV4IHJldHVybiBhIG5ldyBhcnJheSBzbGljZWQgZnJvbSBpbmRleFxuICogQG1ldGhvZCBhcmdcbiAqIEBwYXJhbSAge0FyZ3VtZW50c30gYXJncyAgICAgICAgQXJndW1lbnRzXG4gKiBAcGFyYW0gIHtOdW1iZXJ9ICAgIFtpbmRleCA9IDBdIFdoZW4gaW5kZXggcmV0dXJuIGEgbmV3IGFycmF5IHNsaWNlZCBmcm9tIGluZGV4XG4gKiBAcmV0dXJuIHtBcnJheX1cbiAqL1xuZXhwb3J0cy5hcmcgPSBmdW5jdGlvbiAoYXJncywgaW5kZXgpIHtcbiAgcmV0dXJuIEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3MsICFpbmRleCA/IDAgOiBpbmRleClcbn1cblxuLyoqXG4gKiBDaGVjayBpZiBvYmogaXMgZW1wdHkgZXhjbHVkZSBmaWVsZCBuYW1lcyBwYXNzZWQgdG8gbGlzdFxuICogQG1ldGhvZCBlbXB0eVxuICogQHBhcmFtICB7T2JqZWN0fSAgICAgICBvYmogIE9iamVjdFxuICogQHBhcmFtICB7T2JqZWN0fEFycmF5fSBsaXN0IFRha2VzIGFueSBvYmplY3Qgd2l0aCAubGVuZ3RoXG4gKiBAcmV0dXJuIHtCb29sZWFufSAgICAgICAgICAgVHJ1ZS9mYWxzZVxuICovXG5leHBvcnRzLmVtcHR5ID0gZnVuY3Rpb24gKG9iaiwgbGlzdCkge1xuICBmb3IgKHZhciBpIGluIG9iaikge1xuICAgIGlmICghbGlzdCB8fCAhdGhpcy5jaGVja0FycmF5KGxpc3QsIGkpKSByZXR1cm4gZmFsc2VcbiAgfVxuICByZXR1cm4gdHJ1ZVxufVxuXG5cblxuIiwiXG52YXIgViA9IHJlcXVpcmUoJy4uLycpXG4gICwgdXRpbCA9IHJlcXVpcmUoJy4vJylcblxubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzID0gZnVuY3Rpb24oZXh0ZW5kKSB7XG4gIHZhciBhcmdzID0gYXJndW1lbnRzXG4gIGlmKCAodHlwZW9mIHRoaXMgPT09ICdmdW5jdGlvbicpIHx8IChWLkJhc2UgJiYgKHRoaXMgaW5zdGFuY2VvZiBWLkJhc2UpKSkge1xuICAgIGlmKChWLkJhc2UgXG4gICAgICAgICYmICh0aGlzPT09Vi5CYXNlIFxuICAgICAgICB8fCAodGhpcy5wcm90b3R5cGUgaW5zdGFuY2VvZiBWLkJhc2UpXG4gICAgICAgIHx8ICh0aGlzIGluc3RhbmNlb2YgVi5CYXNlKSlcbiAgICAgICkpIHsgXG4gICAgICBhcmdzID0gdXRpbC5hcmcoYXJncylcbiAgICAgIGFyZ3MudW5zaGlmdCh0aGlzKVxuICAgICAgZXh0ZW5kID0gdGhpc1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gaW5qZWN0LmFwcGx5KHRoaXMsYXJncylcbiAgICB9XG4gIH1cbiAgZm9yKHZhciBpID0gMTsgaSA8IGFyZ3MubGVuZ3RoOyBpKyspIHtcbiAgIG1ha2VFeHRlbmQoZXh0ZW5kLCBhcmdzW2ldKVxuICB9XG4gIHJldHVybiBleHRlbmRcbn1cblxuZnVuY3Rpb24gbWFrZUV4dGVuZChleHRlbmQsIG1vZHVsZSkge1xuICBpZihtb2R1bGUuZXh0ZW5kKSB7XG4gICAgIG1vZHVsZS5leHRlbmQoZXh0ZW5kKVxuICB9IGVsc2UgaWYobW9kdWxlIGluc3RhbmNlb2YgQXJyYXkpIHtcbiAgICB2YXIgYXJyID0gbW9kdWxlLmNvbmNhdCgpXG4gICAgICAsIG1vZCA9IGFyclswXVxuICAgIGFyclswXSA9IGV4dGVuZFxuICAgIG1vZC5leHRlbmQuYXBwbHkobW9kLGFycilcbiAgfSBcbn0gXG5cbmZ1bmN0aW9uIGluamVjdCgpIHtcbiAgLy9kbyBzcGVjaWFsIHN0dWZmIHZvb3IgYmxhY2tsaXN0XG4gIC8vIEN1c3RvbS5wcm90b3R5cGUgPSBuZXcgdGhpcygpIC8vbGlnaHRlclxuICB2YXIgQ3VzdG9tXG4gICAgLCBleHRlbmRSZXNpZHVlID0gW11cbiAgICAsIEFzcGVjdHMgPSBbdGhpc11cblxuICBmb3IgKHZhciBpID0gMCwgQXNwZWN0LCBhcmdzID0gYXJndW1lbnRzLCBsZW4gPSBhcmdzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgXG4gICAgQXNwZWN0ID0gYXJnc1tpXVxuXG4gICAgaWYodHlwZW9mIEFzcGVjdCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgaWYoIUN1c3RvbSkge1xuICAgICAgICBDdXN0b20gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICBmb3IgKHZhciBqID0gMCwgbGVuID0gQXNwZWN0cy5sZW5ndGg7IGogPCBsZW47ICBqKyspIHtcbiAgICAgICAgICAgIEFzcGVjdHNbal0uYXBwbHkodGhpcywgYXJndW1lbnRzKVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpbmhlcml0cyggQ3VzdG9tLCB0aGlzIClcbiAgICAgIH1cbiAgICAgIEFzcGVjdHMucHVzaChBc3BlY3QpXG4gICAgICBmb3IgKHZhciBtZXRob2QkIGluIEFzcGVjdC5wcm90b3R5cGUpIGlmICh7fS5oYXNPd25Qcm9wZXJ0eS5jYWxsKEFzcGVjdC5wcm90b3R5cGUsIG1ldGhvZCQpKSB7XG4gICAgICAgIGlmIChtZXRob2QkID09PSAnY29uc3RydWN0b3InKSBjb250aW51ZVxuICAgICAgICBDdXN0b20ucHJvdG90eXBlW21ldGhvZCRdID0gQXNwZWN0LnByb3RvdHlwZVttZXRob2QkXVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpZihDdXN0b20pIHtcbiAgICAgICBtYWtlRXh0ZW5kKEN1c3RvbSAsIEFzcGVjdClcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGV4dGVuZFJlc2lkdWUucHVzaChBc3BlY3QpXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgaWYoIUN1c3RvbSkgQ3VzdG9tID0gdGhpc1xuICBcbiAgZm9yKHZhciBqIGluIGV4dGVuZFJlc2lkdWUpIHtcbiAgICBtYWtlRXh0ZW5kKEN1c3RvbSxleHRlbmRSZXNpZHVlW2pdKVxuICB9XG5cbiAgcmV0dXJuIEN1c3RvbVxufVxuXG5mdW5jdGlvbiBpbmhlcml0cyhjdG9yLCBzdXBlckN0b3IpIHtcbiAgY3Rvci5zdXBlcl8gPSBzdXBlckN0b3JcbiAgY3Rvci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlXG4gICAgKCBzdXBlckN0b3IucHJvdG90eXBlXG4gICAgLCB7IGNvbnN0cnVjdG9yOiBcbiAgICAgICAgeyB2YWx1ZTogY3RvclxuICAgICAgICAsIGVudW1lcmFibGU6IGZhbHNlXG4gICAgICAgICwgd3JpdGFibGU6IHRydWVcbiAgICAgICAgLCBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfVxuICAgICAgfVxuICAgIClcbn1cblxuLypcbiBEaXQgbW9ldCB3b3JkZW4gZ2VhZGQgdm9vciBWLk9iamVjdHNcbi8qXG4gIG9iamVjdC5uZXcgPSBmdW5jdGlvbihwYXJhbXMsIGNvbnN0cnVjdG9yKSB7XG4gIHZhciB2T2JqID0gZnVuY3Rpb24odmFsLCBob29rLCBwYXJlbnQpIHtcbiAgICAgIGlmIChwYXJlbnQpIHRoaXMuX3BhcmVudCA9IHBhcmVudFxuICAgICAgaWYgKGhvb2sgJiYgdGhpcy5faG9vaykgdGhpcy5faG9vayh2YWwsIGhvb2spXG4gICAgICBpZiAodGhpcy5fb25Db25zdHJ1Y3QpIHRoaXMuX29uQ29uc3RydWN0KHZhbCwgaG9vaylcbiAgICAgIGlmICh2YWwgIT09IHZvaWQgMCkgdGhpcy52YWwgPSB2YWxcbiAgICAgIC8vIGNvbnNvbGUubG9nKGNvbnN0cnVjdG9yKVxuICAgICAgaWYoY29uc3RydWN0b3IpIGNvbnN0cnVjdG9yLmFwcGx5KHRoaXMsYXJndW1lbnRzKSAgXG4gICAgfSxcbiAgICBwcm90byA9IHZPYmoucHJvdG90eXBlID0gbmV3IHRoaXMoKVxuICB2T2JqLm5ldyA9IG9iamVjdC5uZXdcbiAgdXRpbC5kZWZpbmUodk9iaiwgJ19ibGFja2xpc3QnLCBwcm90by5fYmxhY2tsaXN0LmNvbmNhdCgpKVxuICBfcGFyYW1zLmNhbGwodk9iaiwgcGFyYW1zLCBbJ21peGVkJywgJ21lcmdlJ10pXG4gIHV0aWwuZGVmaW5lKHZPYmosICdfY2xhc3MnLCB2T2JqKVxuICByZXR1cm4gdk9ialxufVxuXG52ZWVsIGRpbmdlbiB3ZXJrZW4gYWxzIGV4dGVuc2lvbiBuaWV0IGFscyBsb3NzZSBjbGFzcyAtLSBcblxuKi9cblxuIiwiLyohXG4gKiBAbGljZW5zZSBDb3B5cmlnaHQgKGMpIDIwMTItMjAxNCwgVmlnb3VyLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogQGF1dGhvcjogSmltIGRlIEJlZXIsIGppbUB2aWdvdXIuaW9cbiAqL1xudmFyIHV0aWwgPSBtb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMgPSByZXF1aXJlKCcuLycpXG4gICwgdmlnb3VyID0gcmVxdWlyZSgnLi4vJykgLy9vbmx5IGhlcmUgdG8gYmUgYWJsZSB0byB1c2UgdXRpbCB3aXRob3V0IHZpZ291ci5PYmplY3QgbWF5YmUgcmVmYWN0b3IgdGhpcyBhd2F5P1xuICAsIERPVCA9ICcuJ1xuXG4vKipcbiAqIGxvb2t1cFxuICogcG9seWZpbGwgaWYgX19sb29rdXBTZXR0ZXJfXyBkb2VzIG5vdCBleGlzdDtcbiAqL1xuZXhwb3J0cy5sb29rdXAgPSBPYmplY3QuX19sb29rdXBTZXR0ZXJfXyB8fCBmdW5jdGlvbiAoaSkge1xuICB2YXIgdCA9IHRoaXNcbiAgICAsIGFcbiAgd2hpbGUgKHQpIHtcbiAgICBhID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0LCBpKVxuICAgIGlmIChhICYmIGEuc2V0KSByZXR1cm4gdHJ1ZVxuICAgIHQgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YodClcbiAgfVxuICByZXR1cm4gZmFsc2Vcbn1cblxuLyoqXG4gKiBVc2VkIHRvIHNldCBhIHZhbCB0byBhbiBmaWVsZCBvbiBhIG9iamVjdCwgd2hldGhlciBpdCBpcyBhIHZpZ291ci5PYmplY3Qgb3IgYSByZWd1bGFyIG9iamVjdFxuICogQG1ldGhvZCBzZXRcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmogICBEZWZpbmVzIHRhcmdldCBPYmplY3RcbiAqIEBwYXJhbSB7U3RyaW5nfSBmaWVsZCBUYXJnZXQgZmllbGRcbiAqIEBwYXJhbSB7Kn0gICAgICB2YWwgICBWYWx1ZSB0byBzZXRcbiAqIEB0b2RvICAgICAgICAgICAgICAgICBNb3ZlIHRoaXMgZnVuY3Rpb24gdG8gYSBkaWZmZXJlbnQgbW9kdWxlIChlLmcuICdjb252ZW5pZW5jZScgbW9kdWxlKVxuICovXG5leHBvcnRzLnNldCA9IGZ1bmN0aW9uIChvYmosIGZpZWxkLCB2YWwsIHZvYmosIHN0YW1wLCBub3VwZGF0ZSkge1xuICByZXR1cm4gKHZpZ291ci5PYmplY3QgJiYgKG9iaiBpbnN0YW5jZW9mIHZpZ291ci5PYmplY3QpKVxuICAgID8gb2JqLnNldChmaWVsZCwgdmFsLCB2b2JqLCBzdGFtcCwgbm91cGRhdGUpXG4gICAgOiAob2JqW2ZpZWxkXSA9IHZhbClcbn1cblxuXG4vKipcbiAqIFJldHVybnMgb2JqZWN0IG9uIHRoZSBlbmQgb2YgYSBkZWZpbmVkIHBhdGhcbiAqIEBtZXRob2QgcGF0aFxuICogQGV4YW1wbGVcbiAqIC8vIHJldHVybnMgb2JqLmEuYi5jXG4gKiB2YXIgb2JqID0geyBhOiB7IGI6IHsgYzogMSB9fX1cbiAqIFYudXRpbC5vYmplY3QucGF0aChvYmosWydhJywnYicsJ2MnXSlcbiAqIEBwYXJhbSAge09iamVjdH0gICAgb2JqICAgICAgICAgICAgT2JqZWN0IHRvIHNlYXJjaFxuICogQHBhcmFtICB7QXJyYXl9ICAgICBwYXRoICAgICAgICAgICBBcnJheSBvZiBmaWVsZHMgaW4gcGF0aFxuICogQHBhcmFtICB7Kn0gICAgICAgICBbdmFsXSAgICAgICAgICBXaGVuIGRlZmluZWQsIHZhbCB3aWxsIGJlIHNldCBvbiBlbmRwb2ludCBvZiBwYXRoIGlmIG5vdCBhbHJlYWR5IGRlZmluZWRcbiAqIEBwYXJhbSAge0Jvb2xlYW59ICAgW292ZXJ3cml0ZV0gICAgSWYgdHJ1ZSwgdmFsIFdJTEwgb3ZlcndyaXRlIGV4aXN0aW5nIHZhbHVlIG9uIGVuZHBvaW50IG9mIHBhdGggd2hlbiBhbHJlYWR5IGRlZmluZWRcbiAqIEBwYXJhbSAge0Z1bmN0aW9ufSAgW3dyaXRlSGFuZGxlcl0gQ2FsbGJhY2sgb24gd3JpdGVcbiAqIEBwYXJhbSAge0Jvb2xlYW59ICAgW25vdXBkYXRlXSAgICAgV2hlbiB0cnVlLCB1cGRhdGVzIHdpbGwgYmUgc2tpcHBlZCBvbiB3cml0ZVxuICogQHBhcmFtICB7TnVtYmVyfSAgICBbaSA9IDBdICAgICAgICBTdGFydGluZyBwb2ludCBmb3Igc2VhcmNoaW5nIHRocm91Z2ggcGF0aFxuICogQHJldHVybiB7Kn0gICAgICAgICAgICAgICAgICAgICAgICBPYmplY3Qgb24gdGhlIGVuZCBvZiBhIGRlZmluZWQgcGF0aFxuICovXG5cbmV4cG9ydHMucGF0aCA9IGZ1bmN0aW9uICggb2JqLCBwYXRoLCB2YWwsIG92ZXJ3cml0ZSwgd3JpdGVIYW5kbGVyLCB2b2JqLCBzdGFtcCwgbm91cGRhdGUsIHNlbGYsIHVpZCwgaSApIHtcbiAgaWYgKCFpKSBpID0gMFxuXG4gIC8vIGlmKHBhdGgubGVuZ3RoID09PSAwKSByZXR1cm4gb2JqXG5cbiAgdmFyIGZpZWxkID0gcGF0aFtpXVxuICAgICwgcmVzdWx0XG4gICAgLCBjXG4gICAgLCB0YXJnZXQgPSAoIXNlbGYgJiYgb2JqICYmIG9iai5fX3QgPT09IDQpID8gb2JqLmZyb21bZmllbGRdIDogb2JqICYmIG9ialtmaWVsZF1cbiAgICAsIGwgPSBpIDwgcGF0aC5sZW5ndGggLSAxXG5cbiAgICAvL2RlemUgdGFyZ2V0XG5cbiAgaWYgKGwgJiYgISh0YXJnZXQgaW5zdGFuY2VvZiBPYmplY3QpKSB0YXJnZXQgPSB2b2lkIDBcblxuICBpZiAoKHZhbCAhPT0gdm9pZCAwKSAmJiAodGFyZ2V0ID09PSB2b2lkIDAgfHwgKCFsICYmIG92ZXJ3cml0ZSkpKSB7XG4gICAgYyA9IHRydWVcbiAgICBleHBvcnRzLnNldChvYmosIGZpZWxkLCBsID8ge30gOiB2YWwsIGwgPyBmYWxzZSA6IHZvYmosIHN0YW1wLCBub3VwZGF0ZSlcbiAgICB0YXJnZXQgPSBvYmpbZmllbGRdXG4gIH1cblxuICBpZiAobCkge1xuICAgIHJlc3VsdCA9IHRhcmdldFxuICAgICAgPyB0aGlzLnBhdGgodGFyZ2V0LCBwYXRoLCB2YWwsIG92ZXJ3cml0ZSwgd3JpdGVIYW5kbGVyLCB2b2JqLCBzdGFtcCwgbm91cGRhdGUsIHNlbGYsIHVpZCwgKytpKVxuICAgICAgOiB0YXJnZXRcbiAgfSBlbHNlIHtcbiAgICByZXN1bHQgPSAoIXNlbGYgJiYgdGFyZ2V0ICYmIHRhcmdldC5fX3QgPT09IDQpID8gdGFyZ2V0LmZyb20gOiB0YXJnZXQ7XG4gICAgaWYgKGMgJiYgd3JpdGVIYW5kbGVyKSB3cml0ZUhhbmRsZXIocmVzdWx0KVxuICB9XG4gIHJldHVybiByZXN1bHRcbn1cblxuLyoqXG4gKiBBZGRzIHBhdGggdXNpbmcgJ2RvdC1ub3RhdGlvbidcbiAqIEBtZXRob2QgZG90RmllbGRcbiAqIEBleGFtcGxlXG4gKiAvLyByZXR1cm5zIGJsdXI6e2Q6e2E6e3M6e319fX1cbiAqIHZhciBibHVyID0ge307XG4gKiBWLnV0aWwub2JqZWN0LmRvdEZpZWxkKGJsdXIsJ2QuYS5zJyk7XG4gKiBAcGFyYW0gIHtPYmplY3R9IG9iaiAgIE9iamVjdCB3aGVyZSBmaWVsZCB3aWxsIGJlIGFkZGVkXG4gKiBAcGFyYW0gIHtTdHJpbmd9IGZpZWxkIFN0cmluZyB1c2luZyAnZG90LW5vdGF0aW9uJ1xuICogQHJldHVybiB7T2JqZWN0fSAgICAgICBSZXR1cm5zIGZpZWxkXG4gKi9cbmV4cG9ydHMuZG90RmllbGQgPSBmdW5jdGlvbiAob2JqLCBmaWVsZCkge1xuICBpZiAofmZpZWxkLmluZGV4T2YoRE9UKSkge1xuICAgIHZhciBwYXRoID0gZmllbGQuc3BsaXQoRE9UKVxuICAgICAgLCBmaXJzdCA9IHBhdGguc2hpZnQoKVxuICAgICAgLCB2YWwgPSB7fVxuICAgIHRoaXMucGF0aCh2YWwsIHBhdGgsIG9ialtmaWVsZF0pXG4gICAgZGVsZXRlIG9ialtmaWVsZF1cbiAgICBvYmpbZmlyc3RdID0gdmFsXG4gICAgZmllbGQgPSBmaXJzdFxuICB9XG4gIHJldHVybiBmaWVsZFxufVxuXG4vKipcbiAqIENoZWNrcyBpZiB0d28gbGlzdHMgY29udGFpbiBpZGVudGljYWwgY29udGVudFxuICogQG1ldGhvZCBjb21wYXJlQXJyYXlzXG4gKiBAcGFyYW0gIHtBcnJheXxPYmplY3R9IGEgVGFrZXMgYW55IG9iamVjdCB3aXRoIC5sZW5ndGhcbiAqIEBwYXJhbSAge0FycmF5fE9iamVjdH0gYiBUYWtlcyBhbnkgb2JqZWN0IHdpdGggLmxlbmd0aFxuICogQHJldHVybiB7Qm9vbGVhbn0gICAgICAgIFRydWUvZmFsc2VcbiAqIEB0b2RvICAgICAgICAgICAgICAgICAgICBNYXliZSBjaGFuZ2UgdGl0bGUgPT4gY29tcGFyZUxpc3RzXG4gKi9cbmV4cG9ydHMuY29tcGFyZUFycmF5cyA9IGZ1bmN0aW9uKGEsIGIpIHtcbiAgLy8gY29uc29sZS5sb2coJ2NvbXBhcmUnLGEsYilcbiAgaWYgKGEubGVuZ3RoICE9PSBiLmxlbmd0aCkgcmV0dXJuIGZhbHNlXG4gIGZvciAodmFyIGkgPSBiLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgaWYgKGFbaV0gIT0gYltpXSkgcmV0dXJuIGZhbHNlXG4gIH1cbiAgcmV0dXJuIHRydWVcbn1cblxuLyoqXG4gKiBHZXRzIG9iamVjdCBmcm9tIHNwZWNpZmllZCBwYXRoLiBXaGVuIHBhdGggaXMgYSBzdHJpbmcgY2hlY2tzIGZvciAnZG90bm90YXRpb24nLlxuICogQG1ldGhvZCBnZXRcbiAqIEBleGFtcGxlXG4gKiAvLyByZXR1cm5zICdmb28nXG4gKiB2YXIgYSA9IHtiOntjOidmb28nfX1cbiAqIFYudXRpbC5vYmplY3QuZ2V0KGEsJ2IuYycpXG4gKiBAcGFyYW0gIHtPYmplY3R9ICAgICAgIG9iaiAgRGVmaW5lcyBvYmplY3Qgb3IgVi5WYWx1ZVxuICogQHBhcmFtICB7U3RyaW5nfEFycmF5fSBwYXRoIERlZmluZXMgZmllbGQge3N0cmluZ30gb3IgcGF0aCB7YXJyYXl8J2RvdC1ub3RhdGlvbid9XG4gKiBAcmV0dXJuIHsqfSAgICAgICAgICAgICAgICAgb2JqW3BhdGhdfG5lc3RlZCBvYmplY3QvdmFsdWVcbiAqL1xuZXhwb3J0cy5nZXQgPSBmdW5jdGlvbiAob2JqLCBwYXRoLCBzZWxmKSB7XG4gIGlmICghb2JqIHx8ICFwYXRoKSByZXR1cm5cbiAgaWYgKCFzZWxmICYmIG9iai5fX3QgPT09IDQgJiYgIW9iai5fZmlsdGVyKSBvYmogPSBvYmouZnJvbVxuICBpZiAoIShwYXRoIGluc3RhbmNlb2YgQXJyYXkpKSB7XG4gICAgaWYgKH5wYXRoLmluZGV4T2YoRE9UKSkge1xuICAgICAgcGF0aCA9IHBhdGguc3BsaXQoRE9UKVxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gKCFzZWxmICYmIG9ialtwYXRoXSAmJiBvYmpbcGF0aF0uZnJvbSkgfHwgb2JqW3BhdGhdXG4gICAgfVxuICB9XG4gIC8vc2VsZiBpcyB0b28gZmFyIGF3YXkgaW4gdGhlIGFyZ3VtZW50c1xuICByZXR1cm4gdGhpcy5wYXRoKG9iaiwgcGF0aCwgdm9pZCAwLCBmYWxzZSwgZmFsc2UsIGZhbHNlLCBmYWxzZSwgZmFsc2UsIHNlbGYpXG59XG5cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIGFuIG9iamVjdCBpcyBhbiBpbnN0YW5jZSBvZiBhbiBvYmplY3QgYW5kIG5vdCBhIGZ1bmN0aW9uICwgVi5PYmplY3Qgb3IgVi5CYXNlXG4gKiBAbWV0aG9kIGlzT2JqXG4gKiBAcGFyYW0gIHtPYmplY3R9ICBvYmogT2JqZWN0IHRvIGluc3BlY3RcbiAqIEByZXR1cm4ge0Jvb2xlYW59ICAgICBUcnVlL0ZhbHNlXG4gKi9cbmV4cG9ydHMuaXNPYmogPSBmdW5jdGlvbiAob2JqKSB7XG4gIHJldHVybiAob2JqIGluc3RhbmNlb2YgT2JqZWN0XG4gICAgJiYgdHlwZW9mIG9iaiAhPT0gJ2Z1bmN0aW9uJ1xuICAgICYmICghdmlnb3VyLk9iamVjdCB8fCAhKG9iaiBpbnN0YW5jZW9mIHZpZ291ci5PYmplY3QpKVxuICAgICYmICghdmlnb3VyLkJhc2UgfHwgIShvYmogaW5zdGFuY2VvZiB2aWdvdXIuQmFzZSkpKVxufVxuXG4vKipcbiAqIENyZWF0ZXMgbmV3IG9iamVjdCB3aXRoIHRoZSBzYW1lIHZhbHVlICwgdGFrZXMgY3VzdG9tIG9iamVjdHMgaW50byBhY2NvdW50IChuZXcgb2JqLmNvbnN0cnVjdG9yKCkpXG4gKiBAbWV0aG9kIGNsb25lXG4gKiBAcGFyYW0gIHtPYmplY3R9IG9iaiBPYmplY3QgdG8gY2xvbmVcbiAqIEByZXR1cm4ge09iamVjdH0gICAgIFJldHVybnMgY2xvbmVcbiAqL1xuZXhwb3J0cy5jbG9uZSA9IGZ1bmN0aW9uIChvYmosIGV4Y2x1ZGUsIHNoYWxsb3cpIHtcbiAgaWYgKHRoaXMuaXNPYmoob2JqKSkge1xuICAgIHZhciBjb3B5ID0gbmV3IG9iai5jb25zdHJ1Y3RvcigpXG4gICAgZm9yICh2YXIgaSBpbiBvYmopIHtcbiAgICAgIGlmKCFleGNsdWRlIHx8ICFleGNsdWRlW2ldKVxuICAgICAgICBjb3B5W2ldID0gIXNoYWxsb3dcbiAgICAgICAgICA/IHRoaXMuY2xvbmUob2JqW2ldLCBleGNsdWRlKVxuICAgICAgICAgIDogb2JqW2ldXG4gICAgfVxuICAgIHJldHVybiBjb3B5XG4gIH1cbiAgcmV0dXJuIG9ialxufTtcblxuLyoqXG4gKiBNZXJnZXMgb2JqZWN0IGIgaW50byBvYmplY3QgYSBhbmQgcmV0dXJucyBvYmplY3QgYVxuICogQG1ldGhvZCBtZXJnZVxuICogQHBhcmFtICB7T2JqZWN0fSBhIE9iamVjdCBhXG4gKiBAcGFyYW0gIHtPYmplY3R9IGIgT2JqZWN0IGJcbiAqIEByZXR1cm4ge09iamVjdH0gICBPYmplY3QgYVxuICovXG5leHBvcnRzLm1lcmdlID0gZnVuY3Rpb24gKGEsIGIsIG5vcmVmcywgb3ZlcndyaXRlKSB7XG4gIGZvciAodmFyIGkgaW4gYikge1xuICAgIHZhciBhaXNvYmogPSB1dGlsLmlzT2JqKGFbaV0pXG4gICAgICAsIGJpc29iaiA9IHV0aWwuaXNPYmooYltpXSlcblxuICAgIGlmIChhaXNvYmogJiYgYmlzb2JqKSB7XG4gICAgICB1dGlsLm1lcmdlKGFbaV0sIGJbaV0sIG5vcmVmcywgb3ZlcndyaXRlKVxuICAgIH0gZWxzZSBpZighbm9yZWZzIHx8ICFiaXNvYmope1xuICAgICAgaWYoIG92ZXJ3cml0ZSA9PT0gdm9pZCAwXG4gICAgICAgfHwgIShpIGluIGEpXG4gICAgICAgfHwgdHlwZW9mIG92ZXJ3cml0ZSA9PT0gJ2Z1bmN0aW9uJyAmJiBvdmVyd3JpdGUoYVtpXSwgYltpXSlcbiAgICAgICAgKXtcbiAgICAgICAgYVtpXSA9IGJbaV1cbiAgICAgIH1cblxuICAgIH1lbHNle1xuICAgICAgYVtpXSA9IGJbaV0gaW5zdGFuY2VvZiBBcnJheSA/IFtdIDoge31cbiAgICAgIHV0aWwubWVyZ2UoYVtpXSwgYltpXSwgbm9yZWZzLCBvdmVyd3JpdGUpXG4gICAgfVxuICB9XG4gIHJldHVybiBhXG59XG5cbi8vIGV4cG9ydHMucmVzb2x2ZSA9IGZ1bmN0aW9uKGEsIGIsIGJGcm9tLCBqKSB7XG4vLyAgIHZhciBzYW1lID0gdHJ1ZTtcbi8vICAgaWYoYiBpbnN0YW5jZW9mIE9iamVjdCkge1xuLy8gICAgIGZvcih2YXIgaSBpbiBiKSB7XG4vLyAgICAgICBpZihhW2ldIT09dm9pZCAwKSB7XG4vLyAgICAgICAgIGlmKGV4cG9ydHMucmVzb2x2ZShhW2ldLGJbaV0sYkZyb20gPyBiRnJvbVtpXSA6IGJbaV0saSkpIHtcbi8vICAgICAgICAgICBpZihiRnJvbSkge1xuLy8gICAgICAgICAgICAgZGVsZXRlIGJGcm9tW2ldXG4vLyAgICAgICAgICAgfVxuLy8gICAgICAgICB9IGVsc2Uge1xuLy8gICAgICAgICAgIHNhbWUgPSBmYWxzZVxuLy8gICAgICAgICB9XG4vLyAgICAgICB9IGVsc2Uge1xuLy8gICAgICAgICBzYW1lID0gZmFsc2Vcbi8vICAgICAgIH1cbi8vICAgICB9XG4vLyAgICAgaWYoc2FtZSkge1xuLy8gICAgICAgaWYoIShiRnJvbSYmaiE9PXZvaWQgMCkpIHJldHVybiB0cnVlXG4vLyAgICAgICBkZWxldGUgYkZyb21bal1cbi8vICAgICB9XG4vLyAgICAgcmV0dXJuIHNhbWU7XG4vLyAgIH0gZWxzZSB7XG4vLyAgICAgaWYoYT09Yikge1xuLy8gICAgICAgaWYoYkZyb20mJmohPT12b2lkIDApIHtcbi8vICAgICAgICAgZGVsZXRlIGJGcm9tW2pdXG4vLyAgICAgICB9XG4vLyAgICAgICByZXR1cm4gdHJ1ZVxuLy8gICAgIH1cbi8vICAgfVxuLy8gfVxuXG5leHBvcnRzLnJlc29sdmUgPSBmdW5jdGlvbihhLCBiLCBiRnJvbSwgaikge1xuICAvLyBjb25zb2xlLmxvZygnbG9scmVzb2x2ZVxcbicsYkZyb20pXG4gIHZhciBzYW1lID0gdHJ1ZTtcbiAgaWYoYiBpbnN0YW5jZW9mIE9iamVjdCkge1xuICAgIGZvcih2YXIgaSBpbiBiKSB7XG4gICAgICBpZihhW2ldIT09dm9pZCAwKSB7XG4gICAgICAgIGlmKGV4cG9ydHMucmVzb2x2ZShhW2ldLGJbaV0sKGJGcm9tIT09dm9pZCAwICYmIGJGcm9tIT09bnVsbCkgPyBiRnJvbVtpXSA6IGJbaV0saSkpIHtcbiAgICAgICAgICBpZihiRnJvbSE9PXZvaWQgMCAmJiBiRnJvbSE9PW51bGwpIHtcbiAgICAgICAgICAgIGlmKGJGcm9tW2ldPT09bnVsbCkge1xuICAgICAgICAgICAgICBzYW1lID0gZmFsc2VcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGRlbGV0ZSBiRnJvbVtpXVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzYW1lID0gZmFsc2VcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2FtZSA9IGZhbHNlXG4gICAgICB9XG4gICAgfVxuICAgIGlmKHNhbWUpIHtcbiAgICAgIGlmKCEoYkZyb20mJmohPT12b2lkIDApKSByZXR1cm4gdHJ1ZVxuICAgICAgZGVsZXRlIGJGcm9tW2pdXG4gICAgfVxuICAgIHJldHVybiBzYW1lO1xuICB9IGVsc2Uge1xuICAgIGlmKGE9PWIpIHtcbiAgICAgIGlmKGJGcm9tJiZqIT09dm9pZCAwKSB7XG4gICAgICAgIGRlbGV0ZSBiRnJvbVtqXVxuICAgICAgfVxuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBBZGRzIHZhbHVlIHRvIGFycmF5IGlmIGl0IGlzIG5vdCBjb250YWluZWQgaW4gYXJyYXksIGV4ZWN1dGVzIGhhbmRsZXIgb24gZW5jb3VudGVyaW5nIHZhbCBpbiBhcnJheVxuICogQG1ldGhvZCBpbmNsdWRlXG4gKiBAcGFyYW0gIHtPYmplY3R8QXJyYXl9ICAgb2JqICAgICAgIFRha2VzIGFueSBvYmplY3Qgd2l0aCAubGVuZ3RoXG4gKiBAcGFyYW0gIHsqfSAgICAgICAgICAgICAgdmFsICAgICAgIFZhbHVlIHRvIGFkZFxuICogQHBhcmFtICB7RnVuY3Rpb259ICAgICAgIFtoYW5kbGVyXSBGdW5jdGlvbiB0byBleGVjdXRlIG9uIGVuY291bnRlcmluZyB2YWwgaW4gYXJyYXlcbiAqIEBwYXJhbSAge0Jvb2xlYW59ICAgICAgICBhcnIgICAgICAgSW5jbHVkZSBlbGVtZW50cyBvZiB2YWwgc2VwYXJhdGVseSByYXRoZXIgdGhhbiBpbmNsdWRpbmcgdmFsIGl0c2VsZlxuICogQHJldHVybiB7Qm9vbGVhbn0gICAgICAgICAgICAgICAgICBUcnVlL2ZhbHNlXG4gKi9cbmV4cG9ydHMuaW5jbHVkZSA9IGZ1bmN0aW9uIChvYmosIHZhbCwgaGFuZGxlciwgYXJyKSB7XG5cbiAgaWYoYXJyICYmIHZhbCBpbnN0YW5jZW9mIEFycmF5KSB7XG4gICAgdmFyIHJldCA9IGZhbHNlXG4gICAgZm9yKHZhciBpID0gMCAsIGxlbiA9IHZhbC5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgcmV0ID0gZXhwb3J0cy5pbmNsdWRlKG9iaiwgdmFsW2ldLCBoYW5kbGVyKVxuICAgIH1cbiAgICByZXR1cm4gcmV0XG4gIH1cblxuICB2YXIgaSA9IDBcbiAgICAsIGwgPSBvYmoubGVuZ3RoXG4gICAgLCBmaWVsZFxuICAgICwgY2hlY2tcblxuICBpZiAob2JqLl9fdCA9PT0gMSkge1xuICAgIGZvciAoO2kgPCBsOyBpKyspIHtcbiAgICAgIGZpZWxkID0gY2hlY2sgPSBvYmpbaV1cbiAgICAgIGlmIChjaGVjay5fX3QgPT09IDQpIGNoZWNrID0gY2hlY2suZnJvbVxuICAgICAgaWYgKGNoZWNrID09PSB2YWwgfHwgY2hlY2sudmFsID09PSB2YWwpIHtcbiAgICAgICAgaWYgKGhhbmRsZXIpIGhhbmRsZXIoZmllbGQpXG4gICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgfVxuICAgIH1cbiAgICBvYmoucHVzaCh2YWwpXG4gICAgcmV0dXJuIHRydWVcbiAgfSBlbHNlIGlmIChvYmogaW5zdGFuY2VvZiBBcnJheSkge1xuICAgIGZvciAoO2kgPCBsOyBpKyspIHtcbiAgICAgIGlmIChvYmpbaV0gPT09IHZhbCkge1xuICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgIH1cbiAgICB9XG4gICAgb2JqLnB1c2godmFsKVxuICAgIHJldHVybiB0cnVlXG4gIH1cbn1cblxuZXhwb3J0cy5jaGFuZ2VUeXBlID0gZnVuY3Rpb24oIG9iaiApIHtcbiAgdmFyIHJlc3VsdFxuICBpZihvYmogaW5zdGFuY2VvZiBBcnJheSkge1xuICAgIHJlc3VsdCA9IHt9XG4gICAgZm9yKHZhciBpPTAsbGVuPW9iai5sZW5ndGg7aTxsZW47aSsrKSB7XG4gICAgICByZXN1bHRbaV09b2JqW2ldXG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHJlc3VsdCA9IFtdXG4gICAgZm9yKHZhciBpIGluIG9iaikge1xuICAgICAgcmVzdWx0LnB1c2gob2JqW2ldKVxuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0XG59XG5cbi8qKlxuICogRW5zdXJlcyBhIHZhbHVlIGlzIG5vdCBvciBjb250YWlucyBubyBWLk9iamVjdHMsIG9ubHkgdGhlaXIgXCJyYXdcIiB2ZXJzaW9uc1xuICogVGhpcyBuZWVkcyB0byBiZSB1bmlmaWVkIHdpdGggY29udmVydCwgb3IgYXQgbGVhc3QgZ2V0IGEgYmV0dGVyIG5hbWUuXG4gKiBAbWV0aG9kIHJhd1xuICogQHBhcmFtICB7Kn0gICB2YWwgICB0aGUgdmFsdWUgdG8gYmUgcHJvY2Vzc2VkXG4gKiBAcmV0dXJuIHsqfSAgICAgICAgIHRoZSBwcm9jZXNzZWQgdmFsdWVcbiAqL1xuZXhwb3J0cy5yYXcgPSBmdW5jdGlvbiggdmFsLCBycGFyYW1zICkge1xuICBpZiAodmFsIGluc3RhbmNlb2YgT2JqZWN0KSB7XG4gICAgaWYgKHZhbCBpbnN0YW5jZW9mIHZpZ291ci5PYmplY3QpIHtcbiAgICAgIHJldHVybiB2YWwucmF3XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciByZXN1bHRcbiAgICAgIGlmICh2YWwgaW5zdGFuY2VvZiBBcnJheSkge1xuICAgICAgICByZXN1bHQgPSBbXVxuICAgICAgICBmb3IgKHZhciBpID0gMCwgbCA9IHZhbC5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICByZXN1bHRbaV0gPSB0aGlzLnJhdyh2YWxbaV0sIHJwYXJhbXMpXG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlc3VsdCA9IHt9XG4gICAgICAgIGZvciAodmFyIGYgaW4gdmFsKSB7XG4gICAgICAgICAgcmVzdWx0W2ZdID0gdGhpcy5yYXcodmFsW2ZdLCBycGFyYW1zKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHJldHVybiB2YWxcbiAgfVxufVxuXG4vL2FkZCBsZXZlbCBhbmQgc3RvcHMgZm9yIGNlcnRhaW4gYnJhbmNoZXNcbmV4cG9ydHMud2FsayA9IGZ1bmN0aW9uKG9iaiwgZm4gKSB7XG4gIGZvcih2YXIgaSBpbiBvYmopIHtcbiAgICBpZihvYmpbaV0gaW5zdGFuY2VvZiBPYmplY3QpIHtcbiAgICAgIGlmKCFmbihpLCBvYmpbaV0sIG9iaiwgdHJ1ZSkpIHtcbiAgICAgICAgaWYoZXhwb3J0cy53YWxrKG9ialtpXSwgZm4pKSByZXR1cm4gdHJ1ZVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYoZm4oaSwgb2JqW2ldLCBvYmopKSB7XG4gICAgICAgIHJldHVybiB0cnVlXG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmV4cG9ydHMuY2hlY2tQYXJlbnRGYWN0b3J5ID0gZnVuY3Rpb24oIHBhcmVudEZpZWxkICkge1xuICByZXR1cm4gZnVuY3Rpb24oZmllbGQsIGdldCwgbGlua3MsIG1hdGNoKSB7XG4gICAgaWYoZ2V0JiZnZXQhPT10cnVlKSB7XG4gICAgICBtYXRjaCA9IGdldFxuICAgICAgZ2V0ID0gZmFsc2VcbiAgICB9XG4gICAgdmFyIGZpZWxkcyA9IGZpZWxkIGluc3RhbmNlb2Ygdmlnb3VyLk9iamVjdCA/IGZhbHNlIDogZmllbGQsXG4gICAgICBjdXJyID0gdGhpcyxcbiAgICAgIGZvdW5kO1xuICAgIHdoaWxlIChjdXJyKSB7XG4gICAgICBmb3VuZCA9IGZpZWxkcyA9PT0gZmFsc2UgPyBjdXJyID09PSBmaWVsZCA6IGV4cG9ydHMuZ2V0KGN1cnIsIGZpZWxkcywgIWxpbmtzKTtcbiAgICAgIGlmIChmb3VuZCkge1xuICAgICAgICBpZihtYXRjaCkge1xuICAgICAgICAgIGlmKG1hdGNoID09PSBmb3VuZCB8fCAoZm91bmQgaW5zdGFuY2VvZiB2aWdvdXIuT2JqZWN0KSAmJiBmb3VuZC52YWwgPT09IG1hdGNoKSB7XG4gICAgICAgICAgICByZXR1cm4gIWdldCAmJiBmaWVsZHMgPyBjdXJyIDogZm91bmQ7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiAhZ2V0ICYmIGZpZWxkcyA/IGN1cnIgOiBmb3VuZDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgY3VyciA9IGN1cnJbcGFyZW50RmllbGRdO1xuICAgIH1cbiAgfVxufVxuXG5cbiIsIi8vcHJvY2Vzc2VzXG52YXIgdk9iamVjdCA9IHJlcXVpcmUoJy4uL29iamVjdCcpXG5cbi8vIGNvbnNvbGUubG9nKCdpbml0IHByb2Nlc3MhJylcblxubW9kdWxlLmV4cG9ydHMgPSB7fVxuIiwiLyohXG4gKiBAbGljZW5zZSBDb3B5cmlnaHQgKGMpIDIwMTItMjAxNCwgVmlnb3VyLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogQGF1dGhvcjogSmltIGRlIEJlZXIsIGppbUB2aWdvdXIuaW9cbiAqL1xudmFyIHV0aWwgPSBtb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMgPSByZXF1aXJlKCcuLycpXG4gICwgViA9IHJlcXVpcmUoJy4uLycpXG4vKipcbiAqIFNldHN0b3JlcyBhcmUgdXNlZCB0byBhdm9pZCB1cGRhdGVzIHRyb3VnaG91dCBwcm90b3R5cGUgY2hhaW5zIGZvciBjaGFuZ2VzIG9mIGZpZWxkcyBvbiBvYmplY3RzXG4gKiBJdCB1c2VzIHR3byBmaWVsZHNcbiAqICAgLl9fIHRvIGluZGljYXRlIG93biB2YWx1ZXMgZm9yIHBpZWNlcyBvZiBhbiBvYmplY3QgaW5oZXJpdGVkIHRyb3VnaCB0aGUgcHJvdG90eXBlIGNoYWluXG4gKiAgIC5fIGlzIHRoZSByZWZlbmNlIGJhY2sgdG8gdGhlIG9iamVjdHMgYXMgc3RlIGluIHRoZSBwcm90b3R5cGVcbiAqIEBjb25zdHJ1Y3RvciBzZXRzdG9yZVxuICovXG5leHBvcnRzLnNldHN0b3JlID0gZnVuY3Rpb24oKSB7XG4gIGlmICggIXRoaXMuX18gKSB0aGlzLl9fID0ge31cbn1cblxuLy9UT0RPOiByZWNvbnN0cnVjdCB2YWx1ZSB1c2luZyBwaWVjZXMgb2Ygb2JqZWN0cyBpbiBfX1xuXG5leHBvcnRzLmdldFN0b3JlID0gZnVuY3Rpb24oIG5hbWUgKSB7XG4gIHJldHVybiB0aGlzLl9fIFxuICAgICAgICAgID8gKCB0aGlzLl9fW25hbWVdICE9PSB2b2lkIDAgXG4gICAgICAgICAgICA/IHRoaXMuX19bbmFtZV0gXG4gICAgICAgICAgICA6IHRoaXMuX1tuYW1lXVxuICAgICAgICAgICAgKSBcbiAgICAgICAgICA6IHRoaXMuXyAmJiB0aGlzLl9bbmFtZV1cbn1cblxuZnVuY3Rpb24gZXh0ZW5zaW9ucyggZXh0ZW5kLCBmbiwgYmFzZSwgYXJncywgZXh0ZW5kZWQgKSB7XG4gICAgXG4gIGlmKCAhZXh0ZW5kLmV4dGVuc2lvbnMgKSBcbiAge1xuICAgIGlmKGJhc2UpIHtcbiAgICAgIGV4dGVuZC5leHRlbnNpb25zID0gW11cbiAgICB9IGVsc2Uge1xuXG4gICAgICAvLyBjb25zb2xlLmxvZyhleHRlbmQpXG4gICAgICBpZihleHRlbmQgaW5zdGFuY2VvZiBWLk9iamVjdCApIHtcbiAgICAgICAgdXRpbC5kZWZpbmUoIGV4dGVuZCwgJ2V4dGVuc2lvbnMnLFtdKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy9nZWJydWlrIGRlemUgZXh0ZW5zaW9uIHN0eWxvXG4gICAgICAgIHV0aWwuZGVmaW5lKCBleHRlbmQsICdleHRlbnNpb25zJyx7dmFsOltdLCBzZXRDbGFzczp0cnVlfSApXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy8gY29uc29sZS5sb2coICdFWFRFTkQnLnJlZCwgZXh0ZW5kLmV4dGVuc2lvbnMsIGJhc2UsIGZuLCB0aGlzLCBleHRlbmRlZCApXG5cbiAgaWYoIHV0aWwuY2hlY2tBcnJheSggZXh0ZW5kLmV4dGVuc2lvbnMsIHRoaXMgKT09PWZhbHNlICkgXG4gIHtcblxuICAgIC8vIGNvbnNvbGUubG9nKCAnRVhURU5EIC0yJy5yZWQsIHRoaXMgKVxuXG4gICAgaWYoICFleHRlbmRlZCApIGV4dGVuZC5leHRlbnNpb25zID0gWyB0aGlzIF0uY29uY2F0KCBleHRlbmQuZXh0ZW5zaW9ucyApIFxuXG4gICAgICAvLyBjb25zb2xlLmxvZyggJ0VYVEVORCAtMycucmVkLCBleHRlbmQuZXh0ZW5zaW9ucyApXG4gICAgICAvL3NvbWV0aGluIHdlaXJkIVxuXG4gICAgLy8gY29uc29sZS5sb2coICdFWFRFTkQgLTMnLnJlZCwgdGhpcywgZXh0ZW5kLCBleHRlbmQuZXh0ZW5zaW9ucy5sZW5ndGggKVxuXG5cbiAgICB2YXIgbXlBcmdzID0gdXRpbC5hcmcoIGFyZ3MgKVxuICAgIGlmKCBiYXNlICYmICFleHRlbmRlZCApIHtcbiAgICAgIG15QXJnc1swXSA9IGJhc2VcbiAgICB9XG4gICAgcmV0dXJuIGZuLmFwcGx5KCB0aGlzLCBteUFyZ3MgKVxuICB9XG5cbn1cblxuZXhwb3J0cy5leHRlbmQgPSBmdW5jdGlvbigpIHtcbiAgXG4gIHZhciBleHRlbmRBcnJheSA9IHV0aWwuYXJnKCBhcmd1bWVudHMgKVxuXG4gIHJldHVybiBmdW5jdGlvbihleHRlbmQpIHtcbiAgICB2YXIgYmFzZVxuICAgICAgLCBwcm90b1xuXG4gICAgaWYoIHR5cGVvZiBleHRlbmQgPT09ICdmdW5jdGlvbicgKSBcbiAgICB7XG4gICAgICBpZiggVi5CYXNlICYmICggZXh0ZW5kLnByb3RvdHlwZSBpbnN0YW5jZW9mIFYuQmFzZSApICkge1xuICAgICAgICBiYXNlID0gZXh0ZW5kLmJhc2VcbiAgICAgICAgcHJvdG8gPSB0cnVlXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwcm90byA9IGV4dGVuZC5wcm90b3R5cGVcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYoIFYuQmFzZSAmJiAoIGV4dGVuZCBpbnN0YW5jZW9mIFYuQmFzZSApICkgXG4gICAge1xuICAgICAgcHJvdG8gPSBleHRlbmRcbiAgICB9XG5cbiAgICBmb3JcbiAgICAoIFxuICAgICAgdmFyIGZuXG4gICAgICAgICwgcmV0XG4gICAgICAgICwgYXJncyA9IHV0aWwuYXJnKCBhcmd1bWVudHMgKVxuICAgICAgICAsIGV4dGVuZEFyclxuICAgICAgICAsIHhBcmdcbiAgICAgICAgLCBpID0gMFxuICAgICAgICAsIGxlbiA9IGV4dGVuZEFycmF5Lmxlbmd0aFxuICAgICAgICA7IGkgPCBsZW5cbiAgICAgICAgOyBpICsrIFxuICAgICkgXG4gICAgeyAgICBcbiAgICAgIGlmKGV4dGVuZEFycmF5W2ldIGluc3RhbmNlb2YgQXJyYXkpIFxuICAgICAge1xuICAgICAgICBleHRlbmRBcnIgPSBleHRlbmRBcnJheVtpXVswXVxuICAgICAgICB4QXJnID0gdXRpbC5hcmcoZXh0ZW5kQXJyYXlbaV0sMSlcbiAgICAgICAgeEFyZy51bnNoaWZ0KGV4dGVuZClcbiAgICAgIH0gZWxzZSBcbiAgICAgIHtcbiAgICAgICAgeEFyZyA9IGFyZ3NcbiAgICAgICAgZXh0ZW5kQXJyID0gZXh0ZW5kQXJyYXlbaV1cbiAgICAgIH1cblxuICAgICAgcmV0ID0gZXh0ZW5zaW9ucy5jYWxsIFxuICAgICAgKCBleHRlbmRBcnIuZXh0ZW5kID8gIGV4dGVuZEFyciA6IHRoaXMgXG4gICAgICAsIGJhc2UgfHwgcHJvdG9cbiAgICAgICwgZXh0ZW5kQXJyLmV4dGVuZCB8fCAgZXh0ZW5kQXJyXG4gICAgICAsIGJhc2VcbiAgICAgICwgeEFyZ1xuICAgICAgLCBleHRlbmRBcnIuZXh0ZW5kID8gdHJ1ZSA6IGZhbHNlIFxuICAgICAgKSBcbiAgICAgIHx8IGV4dGVuZFxuXG4gICAgfVxuICAgIHJldHVybiByZXRcbiAgfVxuXG59XG5cbi8qKlxuICogQWRkIGlzIHVzZWQgYXMgYSBzaG9ydGN1dCBtZXRob2QgZm9yIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSBhbmQgZXh0ZW5kcyBzZXRzdG9yZSBmdW5jdGlvbmFsaXR5IHRvIG5vcm1hbCBwcm90b3R5cGVzXG4gKiBAbWV0aG9kIGFkZFxuICogQHBhcmFtICB7T2JqZWN0fSAgICAgICAgICBvYmogIFdoZW4gb2JqIGlzIGEgY29uc3RydWN0b3IgaXQgc2VsZWN0cyBvYmoucHJvdG90eXBlLCB3aGVuIG9iaiBpcyBhIG5vcm1hbCBvYmplY3QgdGhpcyBpcyB1c2VkIGluc3RlYWRcbiAqIEBwYXJhbSAge1N0cmluZ3xBcnJheX0gICAgbmFtZSBXaGVuIG5hbWUgaXMgYSBzdHJpbmcgaXQgYWRkcyB0aGUgbmFtZSBmb3IgdGhlIG9iamVjdCwgd2hlbiBuYW1lIGlzIGEgYXJyYXkgZG8gdGhlIHNhbWUgc2V0dGluZyBmb3IgZWFjaCBuYW1lXG4gKiBAcGFyYW0gIHtPYmplY3R8RnVuY3Rpb259IHZhbCAgV2hlbiB2YWwgaXMgYW4gb2JqZWN0ICwgdXNlIHRoaXMgb2JqZWN0IGZvciBPYmplY3QuZGVmaW5lUHJvcGVydHkgd2l0aCBkZWZhdWx0IGZvciBlbnVtbWVyYWJsZTpmYWxzZSwgd2hlbiBvYmplY3QgaXMgZW1wdHkgYWRkcyB7dmFsdWU6e30sZW5udW1lcmFibGU6ZmFsc2V9LCB3aGVuIHZhbCBpcyBhIGZ1bmN0aW9uIGl0IGF1dG9tYXRpY2FsbHkgd3JhcHMgYSBwcm9wZXJ0eSBkZWZpbml0aW9uIG9iamVjdCB3aXRoIHt2YWx1ZTogdmFsICwgZW51bW1lcmFibGU6ZmFsc2V9LCB3aGVuIHZhbCBpcyBub3QgYSBmdW5jdGlvbiBhbmQgbm90IGFuIG9iamVjdCAoYm9vbGVhbiwgc3RyaW5nLCBudW1iZXIpIGFkZHMgc3BlY2lhbCBzZXRzdG9yZSB2YWx1ZVxuICogQHBhcmFtICB7RnVuY3Rpb259ICAgICAgICBbc2V0XSAgQWRkcyBjdXN0b20gc2V0dGVycyB0byBhIHNldHN0b3JlIG9iamVjdCwgd2hlbiBzZXQgaXMgYSBzdHJpbmcgdGhlIGFkZCBmdW5jdGlvbnMgaW50ZXJwcmV0cyB0aGUgYXJndW1lbnRzIGFzIG5hbWUgOiBwcm9wZXJ0eSBkZWZpbml0aW9uIHBhaXJzXG4gKiBAcGFyYW0gIHtGdW5jdGlvbn0gICAgICAgIFtnZXRdICBBZGRzIGN1c3RvbSBnZXR0ZXJzIHRvIGEgc2V0c3RvcmUgb2JqZWN0XG4gKiBAXG4gKi9cbmV4cG9ydHMuZGVmaW5lID0gZnVuY3Rpb24gKG9iaiwgbmFtZSwgdmFsLCBzZXQsIGdldCwgaWQpIHtcbiAgaWYgKHR5cGVvZiBzZXQgPT09ICdzdHJpbmcnKSB7XG4gICAgdmFyIF9hcmdzID0gdXRpbC5hcmcoYXJndW1lbnRzKVxuICAgIGZvciAodmFyIGkgPSAxLCBsID0gX2FyZ3MubGVuZ3RoOyBpIDwgbDsgaSArPSAyKSB7XG4gICAgICBleHBvcnRzLmRlZmluZShvYmosIF9hcmdzW2ldLCBfYXJnc1tpICsgMV0pXG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGlmIChuYW1lIGluc3RhbmNlb2YgQXJyYXkpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gbmFtZS5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgZXhwb3J0cy5kZWZpbmUob2JqLCBuYW1lW2ldLCB2YWwpXG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICh0eXBlb2YgdmFsID09PSAnZnVuY3Rpb24nIHx8IHZhbCBpbnN0YW5jZW9mIEFycmF5KSB7XG4gICAgICAgIHZhbCA9IHtcbiAgICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgICB2YWx1ZTogdmFsLFxuICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKCF2YWwgfHwgKCAhKHZhbCBpbnN0YW5jZW9mIE9iamVjdCkgfHwgdmFsLnNldENsYXNzICApKSB7XG5cbiAgICAgICAgaWYoIHZhbCAmJiB2YWwuc2V0Q2xhc3MgKSB7XG4gICAgICAgICAgdmFsID0gdmFsLnZhbFxuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHByb3RvID0gb2JqLnByb3RvdHlwZSB8fCBvYmpcblxuXG4gICAgICAgIC8vXG5cbiAgICAgICAgLy9UT0RPOiBub3QgYSBnb29kIHNvbHV0aW9uIC0tIGhhcyB0byByZWRlZmluZSBjb25zdGFudGx5ICggdG9vIGhlYXZ5IClcbiAgICAgICAgLy8gaWYoIHByb3RvICE9PSBvYmoucHJvdG90eXBlICYmIHByb3RvLl8gKSB7XG4gICAgICAgIC8vICAgIC8vVE9ETzogdGhpcyBjYW4gZ28gY29tcGxldGVseSB3cm9uZyB3aGVuIHlvdSBleHBlY3QgaW5oZXJpdGFuY2Ugbm90IHRvIGJyZWFrIHdoZW4gbWFraW5nIGEgbmV3IGNsYXNzIVxuICAgICAgICAvLyAgICBpZiggcHJvdG8uY29uc3RydWN0b3IucHJvdG90eXBlLl8gPT09IHByb3RvLl8gKSB7XG4gICAgICAgIC8vICAgICAgIHZhciBvbGQgPSBwcm90by5fXG4gICAgICAgIC8vICAgICAgIHByb3RvLl8gPSB7fVxuICAgICAgICAvLyAgICAgICBmb3IodmFyIGtleSBpbiBvbGQpIHtcbiAgICAgICAgLy8gICAgICAgICBwcm90by5fW2tleV0gPSBvbGRba2V5XVxuICAgICAgICAvLyAgICAgICB9XG4gICAgICAgIC8vICAgIH1cbiAgICAgICAgLy8gfVxuICAgICAgICBcbiAgICAgICAgLy9tYXliZSBtYWtlIGludG8gYSBtZXRob2RcbiAgICAgICAgaWYoIGlkKSB7XG4gICAgICAgICAgLy8gY29uc29sZS5sb2coJ0RFRklORSEgRE8gSVQnLnJlZC5pbnZlcnNlLCBuYW1lLCBpZCwgcHJvdG8pXG4gICAgICAgICAgaWYgKCFwcm90by5fXykgcHJvdG8uX18gPSB7fVxuICAgICAgICAgIHByb3RvLl9fW25hbWVdID0gdmFsXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKCFwcm90by5fKSBwcm90by5fID0ge31cbiAgICAgICAgICBwcm90by5fW25hbWVdID0gdmFsXG4gICAgICAgIH1cblxuXG5cbiAgICAgIFxuXG4gICAgICAgIC8vaWYgcHJvdG8gaXMgbm90IGEgcHJvdG90eXBlIChob3cgdG8gY2hlY2s/KSB0aGVuIHVzZSBfXyBwZXJoYXBzP1xuXG4gICAgICAgIC8vbW9ldCBoaWVyIG5pZXQgYWx0aWpkIHplIGVpZ3VoIHdvcmRlbiBnZW1hYWt0P1xuXG4gICAgICAgLy9kZWZhdWx0IGRpdCBpcyBlaWdlbmxpamsgaGV0IGVuaWdlIGRhdCBtaXMgZ2FhdFxuXG4gICAgICAgIHZhciBzZXR0ZXIgPSBmdW5jdGlvbih2YWwpIHtcbiAgICAgICAgICAgICAgZXhwb3J0cy5zZXRzdG9yZS5jYWxsKHRoaXMpXG4gICAgICAgICAgICAgIC8vVE9ETzogZml4IGNsb3N1cmUgZm9yIHZhbFxuICAgICAgICAgICAgICBpZiAodmFsIHx8IHZhbCA9PT0gMCB8fCB2YWwgPT09IGZhbHNlKSB0aGlzLl9fW25hbWVdID0gdmFsXG4gICAgICAgICAgICB9XG4gICAgICAgICAgLCB3c2V0ID0gZnVuY3Rpb24odmFsKSB7XG4gICAgICAgICAgICAgIHZhbCA9IHNldC5jYWxsKHRoaXMsIHZhbCk7XG4gICAgICAgICAgICAgIHNldHRlci5jYWxsKHRoaXMsIHZhbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgLCBnZXR0ZXIgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGV4cG9ydHMuZ2V0U3RvcmUuY2FsbCh0aGlzLCBuYW1lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAsIHdnZXQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgdmFyIHByb3AgPSBnZXR0ZXIuY2FsbCh0aGlzKTtcbiAgICAgICAgICAgICAgcmV0dXJuIGdldC5jYWxsKHRoaXMsIHByb3ApO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgIHZhbCA9IHtcbiAgICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgZ2V0OiBnZXQgPyB3Z2V0IDogZ2V0dGVyLFxuICAgICAgICAgIHNldDogc2V0ID8gd3NldCA6IHNldHRlclxuICAgICAgICB9XG5cbiAgICAgIH0gZWxzZSBpZiAoIXZhbC5lbnVtZXJhYmxlKSB7XG4gICAgICAgIGlmICh1dGlsLmVtcHR5KHZhbCkpIHZhbC52YWx1ZSA9IHt9XG4gICAgICAgIHZhbC5jb25maWd1cmFibGUgPSB0cnVlXG4gICAgICAgIHZhbC5lbnVtZXJhYmxlID0gZmFsc2VcbiAgICAgIH1cblxuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iai5wcm90b3R5cGUgfHwgb2JqLCBuYW1lLCB2YWwpXG5cbiAgICAgIC8vIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmoucHJvdG90eXBlIHx8IG9iaiwgbmFtZSwgdmFsKVxuICAgICAgLy9tYXllYiBkbyBib3RoP1xuICAgIH1cbiAgfVxufSIsIi8qIVxuICogQGxpY2Vuc2UgQ29weXJpZ2h0IChjKSAyMDEyLTIwMTQsIFZpZ291ci4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIEBhdXRob3I6IEppbSBkZSBCZWVyLCBqaW1Admlnb3VyLmlvXG4gKi9cbnZhciBiYXNlID0gcmVxdWlyZSgnLi4vYmFzZScpXG4gICwgdmFsdWUgPSByZXF1aXJlKCcuLycpXG4gICwgb2JqZWN0U2V0ID0gcmVxdWlyZSgnLi4vb2JqZWN0Jykuc2V0XG4gICwgdXRpbCA9IHJlcXVpcmUoJy4uL3V0aWwnKVxuICAvLyAsIHJhZiA9IHJlcXVpcmUoJy4uL2Jyb3dzZXIvYW5pbWF0aW9uL3JhZicpXG5cbmV4cG9ydHMuY2xvbmVsaXN0ID0gW1xuICBbICdfYmFzZScsIGZhbHNlIF0sICdfY2FsbGVyJywgJ19wcm9wJywgJ19uYW1lJywgJ19za2lwJ1xuXVxuXG5mdW5jdGlvbiByZXNvbHZlTGlzdGVuZXIoIGxpc3RlbmVyLCB2YWwsIHByb3AsIGluc3RhbmNlICkge1xuICBpZiAobGlzdGVuZXIpIHtcbiAgICBpZiAoIGxpc3RlbmVyLl9iaW5kID09PSBpbnN0YW5jZSAmJiBsaXN0ZW5lci5fX3QgPT09IDQgKSB7XG4gICAgICAvLyBjb25zb2xlLmxvZygnYmluZCByZXNvbHZlJy5yZWQuYm9sZCwgdmFsIClcbiAgICAgIGxpc3RlbmVyLnZhbCA9IHZhbFxuICAgIH1cbiAgICBlbHNlIGlmICghbGlzdGVuZXIuX2JpbmQgKSB7IFxuXG4gICAgICBpZiggbGlzdGVuZXIuX190ID09PSA0ICYmIGxpc3RlbmVyLl92YWwgPT09IHByb3AgKVxuICAgICAge1xuICAgICAgICAvLyBsaXN0ZW5lci52YWwgPSBcbiAgICAgICAgbGlzdGVuZXIudmFsID0gdmFsXG4gICAgICAgIGNvbnNvbGUubG9nKCctLS0tLS0tLS0tJywgbGlzdGVuZXIuX190IClcbiAgICAgIH1cbiAgICAgIGVsc2VcbiAgICAgIHtcbiAgICAgICAgLy8gY29uc29sZS5sb2coJ3VsdGltYXRlIHVnbHkhJylcbiAgICAgICAgdmFsLmFkZExpc3RlbmVyKGxpc3RlbmVyKSAvL2RpdCBmaXhlZCAgXG4gICAgICB9XG5cbiAgICAgIC8vVE9ETzogaW1wbGVtZW50IHRoaXMgbGF0ZXJcbiAgICAgIC8vIGlmKCBsaXN0ZW5lciBpbnN0YW5jZW9mIEFycmF5ICkge1xuICAgICAgLy8gICB2YXIgbWFyayA9IGxpc3RlbmVyWzFdXG4gICAgICAvLyAgIGlmKCBtYXJrICkge1xuICAgICAgLy8gICAgIGlmKCBtYXJrID09PSBwcm9wLl9iYXNlIHx8IG1hcmsgPT09IGluc3RhbmNlIHx8IGluc3RhbmNlIGluc3RhbmNlb2YgbWFyay5fY2xhc3MgKSB7XG4gICAgICAvLyAgICAgICAvL1RPRE86IHByb3BhYmx5IG5lZWQgdG8gY2hlY2sgZm9yIGluaGVyaXRhbmNlICggbWFyayBpbnN0YW5jZSBvZiBwcm9wLl9iYXNlKVxuICAgICAgLy8gICAgICAgLy8gY29uc29sZS5sb2coJ21hcmsgcmVzb2x2ZScuZ3JlZW4uaW52ZXJzZSwgbGlzdGVuZXIpXG4gICAgICAvLyAgICAgICAvLyB2YWwuYWRkTGlzdGVuZXIoWyBsaXN0ZW5lclswXSAsIGluc3RhbmNlIF0sIHRydWUpXG4gICAgICAvLyAgICAgfVxuICAgICAgLy8gICB9XG4gICAgICAvLyB9XG5cbiAgICAgIFxuICAgICAgLy8gdmFsLmFkZExpc3RlbmVyKF9saXN0ZW5lcnNbaV0pXG4gICAgfVxuICB9XG59XG5cbi8vIGZ1bmN0aW9uIHJlc29sdmVMaXN0ZW5lciggKSB7XG5cbi8vIH1cblxuLyoqXG4gKiBWLnZhbHVlLmJhc2UudHlwZVxuICogRGVmaW5lcyB0aGUgYmFzZSB0eXBlIHVzZWQgaW4gVi5WYWx1ZVxuICogQHR5cGVcbiAqL1xuZXhwb3J0cy50eXBlID0ge1xuICB0eXBlOiB2YWx1ZSxcbiAgLyoqXG4gICAqIERlZmluZXMgd2hhdCB0aGlzIHR5cGUgd2lsbCBkbyBvbiBjcmVhdGlvbi5cbiAgICogQG1ldGhvZCBjcmVhdGVcbiAgICogQHBhcmFtICB7Kn0gdmFsICAgICAgICAgICAgICBWYWx1ZVxuICAgKiBAcGFyYW0gIHtbdHlwZV19ICBbcHJvcF0gICAgIFtkZXNjcmlwdGlvbl0gLy9XT1JEVCBOSUVUIEdFQlJVSUtUXG4gICAqIEBwYXJhbSAge09iamVjdH0gIFtzZXR0aW5nc10gU2V0dGluZ29iamVjdFxuICAgKiBAcGFyYW0gIHtCb29sZWFufSBbbm91cGRhdGVdIFdoZW4gdHJ1ZSwgZG9lc24ndCB1cGRhdGUgdGhlIFYuVmFsdWVcbiAgICogQHJldHVybiB7T2JqZWN0fSAgICAgICAgICAgICBSZXR1cm5zIHRoZSBWLlZhbHVlXG4gICAqL1xuICBjcmVhdGU6IGZ1bmN0aW9uKHZhbCwgcHJvcCwgc2V0dGluZ3MsIG5vdXBkYXRlKSB7XG4gICAgdmFyIHYgPSBuZXcgdmFsdWUoKVxuICAgIHYuX2Jhc2UgPSB0aGlzXG4gICAgdi5fY2FsbGVyID0gdi5fYmFzZVxuICAgIHYuX3Byb3AgPSBzZXR0aW5nc1xuICAgIC8vIGNvbnNvbGUubG9nKCdzZXQnKVxuICAgIG9iamVjdFNldC5jYWxsKHYsIHZhbCwgZmFsc2UsIGZhbHNlLCB0cnVlKVxuICAgIC8vIGNvbnNvbGUubG9nKCdkb25lIHNldHRpbmcnKVxuICAgIGlmICh0aGlzLl9jbGFzcykgdGhpcy5fY2xhc3MucHJvdG90eXBlLl9bc2V0dGluZ3MubmFtZV0gPSB2XG4gICAgaWYgKHNldHRpbmdzLnNldCkge1xuICAgICAgaWYgKCFzZXR0aW5ncy5fdnNldCkge1xuICAgICAgICBzZXR0aW5ncy5fdnNldCA9IGZ1bmN0aW9uKHN0YW1wLCBmcm9tLCByZW1vdmUsIGN2YWwpIHtcbiAgICAgICAgICAvLyB2YXIgdCA9IHRoaXNcbiAgICAgICAgICAvLyB0Ll9fcyA9IHRydWVcbiAgICAgICAgICAvLyBpZighdC5fcykge1xuICAgICAgICAgICAgLy8gcmFmKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAvLyBjb25zb2xlLmxvZygnSU0gSEVSRT8nKVxuICAgICAgICAgICAgICAvLyB0Ll9fcyA9IG51bGxcbiAgICAgICAgICAgICAgc2V0dGluZ3Muc2V0LmNhbGwoXG4gICAgICAgICAgICAgICAgICAgdGhpcy5fY2FsbGVyXG4gICAgICAgICAgICAgICAgfHwgdGhpcy5fYmFzZVxuICAgICAgICAgICAgICAgIHx8IHRoaXMsIHRoaXMsIHN0YW1wLCBmcm9tLCByZW1vdmUsIGN2YWxcbiAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgLy8gfSlcbiAgICAgICAgICAvLyB9XG5cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKCFub3VwZGF0ZSkge1xuICAgICAgICAvLyBjb25zb2xlLmxvZygnVVBEQVRFIGNyZWF0aW9uJylcbiAgICAgICAgdi5fdXBkYXRlKHZhbClcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHZcbiAgfSxcbiAgLyoqXG4gICAqIERlZmluZXMgd2hhdCB0aGlzIHR5cGUgd2lsbCBkbyBvbiBzZXQuXG4gICAqIEBtZXRob2Qgc2V0XG4gICAqIEBwYXJhbSAgeyp9ICAgICAgdmFsICAgICAgVmFsdWVcbiAgICogQHBhcmFtICB7T2JqZWN0fSBwcm9wICAgICBQcm9wZXJ0aWVzXG4gICAqIEBwYXJhbSAge09iamVjdH0gc2V0dGluZ3MgU2V0dGluZ3NvYmplY3RcbiAgICogQHJldHVybiB7Kn0gICAgICAgICAgICAgICBSZXR1cm5zIHZhbHVlXG4gICAqL1xuICBzZXQ6IGZ1bmN0aW9uKHZhbCwgcHJvcCwgc2V0dGluZ3MpIHtcblxuICAgIGlmKCFwcm9wKSByZXR1cm5cbiAgICAvLyBjb25zb2xlLmxvZygnU0VUIEZVTiEnKVxuICAgIHByb3AuX2NhbGxlciA9IHRoaXNcbiAgICAvL2RlemUgYmluZCB6b3UgYWxsZWVuIG1vZXRlbiB3ZXJrZW4gdm9vciBhbHMgamUgaWV0cyBvcCBoZXQgZXhhY3QgZ29lZGUgbW9tbWVudCBjaGFuZ2VkIVxuXG4gICAgcHJvcC5fYmluZCA9IGZhbHNlXG4gICAgaWYgKHRoaXMgIT09IHByb3AuX2Jhc2UpIHtcbiAgICAgIHZhciBfbGlzdGVuZXJzID0gcHJvcC5fbGlzdGVuZXJzXG4gICAgICAgICwgX2IgPSBwcm9wLl9iYXNlXG4gICAgICAgICwgaVxuICAgICAgICAsIF90aGlzID0gdGhpc1xuXG4gICAgICB1dGlsLnNldHN0b3JlLmNhbGwodGhpcylcbiAgICAgIGV4cG9ydHMuY2xvbmVsaXN0WzBdWzFdID0gdGhpcyAvL2JlZXRqZSBkaXJ0eS4uLlxuXG4gICAgICAvL2Nsb25lIGlzIGFsd2F5cyB1c2VkIHRvIGdldCByaWQgb2YgZmxhZ3NcbiAgICAgIGlmICh2YWwgIT09IHZvaWQgMCAmJiAhdmFsLmNsZWFyKSB7XG4gICAgICAgIHZhbCA9IHByb3AuY2xvbmUodmFsLCBmYWxzZSwgZXhwb3J0cy5jbG9uZWxpc3QpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBpZihwcm9wLl9mbGFnKSB7XG4gICAgICAgIC8vICAgdmFsdWUuZmxhZ3NbcHJvcC5fZmxhZ1swXV0ucmVtb3ZlICYmIHZhbHVlLmZsYWdzW3Byb3AuX2ZsYWdbMF1dLnJlbW92ZS5jYWxsKHRoaXMscHJvcC5fZmxhZylcbiAgICAgICAgLy8gfVxuICAgICAgICAvL2xpc3RlbmVyIG9uIG5lc3RlZCBjaGlsZCBvbiBwYXJlbnRcblxuICAgICAgICAgLy8tLS0+ICBuZXcgd2lkdGggZm9yIHRoaXMgb25lXG4gICAgICAgICAvLyAtLS0+ICBoZXkgYSBsaXN0ZW5lciBvbiBtZSAvdyBhIGJpbmQgb24gbXkgaW5zdGFuY2UhXG4gICAgICAgICAvLyAgLS0tLT4gYWRkIGxpc3RlbmVyIHRvIG1lIChsaXN0ZW5lciBvbiBjbGFzcyBwcm9wKVxuICAgICAgICAgLy8gICAtLS0tLT4gaGV5IGxldHMgcmVzZXQgdGhpcyBsaXR0bGUgZ3V5cyB3aWR0aFxuICAgICAgICAgLy8gICAgLS0tLS0tPiAgbGV0cyBhZGQgTGlzdGVuZXJcbiAgICAgICAgIC8vICAgICAtLS0tLS0tLT4gIGRvdWJsZSBsaXN0ZW5lcnMgb24gdGhpcyBvbmVcbiAgICAgICAgdmFyIHYgPSBuZXcgdmFsdWUoKVxuICAgICAgICB2Ll9iYXNlID0gdGhpc1xuICAgICAgICB2Ll9wcm9wID0gc2V0dGluZ3NcbiAgICAgICAgdi5fY2FsbGVyID0gdGhpc1xuXG4gICAgICAgIC8vIGNsZWFuIEZMQUdTIGZyb20gbm9kZSFcbiAgICAgICAgaWYodmFsKSBkZWxldGUgdmFsLmNsZWFyXG4gICAgICAgIHYudmFsID0gdmFsXG4gICAgICAgIHZhbCA9IHZcbiAgICAgIH1cblxuICAgICAgdGhpcy5fX1tzZXR0aW5ncy5uYW1lXSA9IHZhbFxuXG4gICAgICBpZiggdGhpcy5fY2xhc3MgKSB0aGlzLl9jbGFzcy5wcm90b3R5cGUuX1tzZXR0aW5ncy5uYW1lXSA9IHZhbFxuXG4gICAgICAvLyBmb3IgZWFjaCBmaWVsZCAob25seSAxIGxldmVsIGRlZXAgZm9yIG5vdylcbiAgICAgIHByb3AuZWFjaFxuICAgICAgKCBcbiAgICAgICAgZnVuY3Rpb24oa2V5KSB7XG4gICAgICAgICAgLy8gY29uc29sZS5sb2coJ3Jlc29sdmUnLCBwcm9wLl9wcm9wLm5hbWUsIGtleSlcbiAgICAgICAgICAgaWYoIHRoaXMuX2xpc3RlbmVycyApIHtcbiAgICAgICAgICAgIGZvciAoaSA9ICB0aGlzLl9saXN0ZW5lcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICAgICAgcmVzb2x2ZUxpc3RlbmVyKCB0aGlzLl9saXN0ZW5lcnNbaV0sIHZhbFtrZXldLCBwcm9wLCBfdGhpcyApXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvL1RPRE86IGNoZWNrIGlmIHRoaXMgaXMgbmVzc2VjYXJ5XG4gICAgICAgICAgICBpZih2YWxba2V5XS52YWwgIT09IHRoaXMudmFsKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAvLyBjb25zb2xlLmxvZyh2YWxba2V5XSkgXG4gICAgICAgICAgICAgIC8vIHZhbFtrZXldLl91cGRhdGUoKVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgKVxuXG4gICAgICBpZiggX2xpc3RlbmVycyApIHtcblxuICAgICAgICBmb3IgKGkgPSBfbGlzdGVuZXJzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgcmVzb2x2ZUxpc3RlbmVyKCBfbGlzdGVuZXJzW2ldLCB2YWwsIHByb3AsIF90aGlzIClcbiAgICAgICAgfVxuXG4gICAgICB9XG5cbiAgICAgIHZhbCA9IG51bGxcbiAgICAgIC8vIGNvbnNvbGUubG9nKCdVUERBQ0UgLS0tLScueWVsbG93KVxuICAgICAgdGhpc1tzZXR0aW5ncy5uYW1lXS5fdXBkYXRlKHZhbClcbiAgICB9XG5cbiAgICByZXR1cm4gdmFsXG4gIH0sXG4gIC8qKlxuICAgRGVmaW5lcyB3aGF0IHRoaXMgdHlwZSB3aWxsIGRvIG9uIGdldC5cbiAgICogQG1ldGhvZCBnZXRcbiAgICogQHBhcmFtICB7T2JqZWN0fSBwcm9wICAgICBQcm9wZXJ0aWVzXG4gICAqIEBwYXJhbSAge09iamVjdH0gc2V0dGluZ3MgU2V0dGluZ29iamVjdFxuICAgKiBAcmV0dXJuIHtPYmplY3R9ICAgICAgICAgIFtkZXNjcmlwdGlvbl1cbiAgKi9cbiAgZ2V0OiBmdW5jdGlvbihwcm9wLCBzZXR0aW5ncykge1xuICAgIC8vIGNvbnNvbGUubG9nKCdHRVRUSU5HIScsIHByb3AsIHNldHRpbmdzLm5hbWUpXG4gICAgaWYgKHByb3ApIHByb3AuX2NhbGxlciA9IHRoaXNcbiAgICBpZiAoc2V0dGluZ3MuZ2V0KSByZXR1cm4gc2V0dGluZ3MuZ2V0LmNhbGwodGhpcywgcHJvcClcbiAgICByZXR1cm4gcHJvcFxuICB9XG59IiwiLyohXG4gKiBAbGljZW5zZSBDb3B5cmlnaHQgKGMpIDIwMTItMjAxNCwgVmlnb3VyLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogQGF1dGhvcjogSmltIGRlIEJlZXIsIGppbUB2aWdvdXIuaW9cbiAqL1xudmFyIGZsYWdzID0gbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuLycpLFxuICB1dGlsID0gcmVxdWlyZSgnLi4vLi4vdXRpbCcpLFxuICBvYmplY3QgPSByZXF1aXJlKCcuLi8uLi9vYmplY3QnKSxcbiAgb3duTW9kZWwgPSBmdW5jdGlvbihiYXNlKSB7XG4gICAgaWYgKCFiYXNlLl9fIHx8ICFiYXNlLl9fLm1vZGVsKSB7IC8vbWF5YmUgYSB1dGlsaXR5PyB1c2UgaXQgYXQgZGlmZmVyZW50IHNwb3RzIGxpa2Ugc2V0dGluZ3NcbiAgICAgIGJhc2UubW9kZWwgPSB7fTtcbiAgICAgIGlmICghYmFzZS5fLm1vZGVsKSB7XG4gICAgICAgIGJhc2UuX2RMaXN0ZW4oKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGJhc2UubW9kZWw7XG4gIH07XG4vKipcbiAqIGRhdGFcbiAqIGRhdGEgYWRkcyBhIHJlZmVyZW5jZSB0byB0aGUgZGF0YSBwcm9wZXJ0eSBvZiB0aGUgY3VycmVudCBiYXNlIGNsYXNzO1xuICogaWYgdGhlcmUgaXMgbm90IF9iYXNlLm1vZGVsIHVzZSBkYXRhLmJhc2UuZXh0ZW5kKGJhc2VDbGFzcyk7XG4gKiBAZmxhZ1xuICovXG5mbGFncy5kYXRhID0ge1xuICB1c2VWYWw6dHJ1ZSwgLy8ocmVzZXQ/Pz8pXG4gIHNldDogZnVuY3Rpb24odmFsLCBzdGFtcCwgcmVzZXQpIHtcblxuICAgIHZhciBjdXJyZW50ID0gdGhpcy5jaGVja1BhcmVudCgnX3Byb3AubmFtZScpLFxuICAgICAgbmFtZSA9IGN1cnJlbnQuX3Byb3AubmFtZSxcbiAgICAgIGJhc2UgPSBjdXJyZW50Ll9iYXNlLFxuICAgICAgbW9kZWwgPSBvd25Nb2RlbChiYXNlKTtcbiAgICBpZiAobW9kZWwuZmxhZ3MgJiYgbW9kZWwuZmxhZ3NbbmFtZV0pIHtcbiAgICAgIGlmICghKG1vZGVsLmZsYWdzW25hbWVdIGluc3RhbmNlb2YgQXJyYXkpKSB7XG4gICAgICAgIG1vZGVsLmZsYWdzW25hbWVdID0gW21vZGVsLmZsYWdzW25hbWVdXTtcbiAgICAgIH1cbiAgICAgIGlmICghdXRpbC5jaGVja0FycmF5KG1vZGVsLmZsYWdzW25hbWVdLCB0aGlzKSkge1xuICAgICAgICBtb2RlbC5mbGFnc1tuYW1lXS5wdXNoKHRoaXMpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoIWJhc2UubW9kZWwuZmxhZ3MpIHtcbiAgICAgICAgYmFzZS5tb2RlbC5mbGFncyA9IHt9O1xuICAgICAgfVxuICAgICAgYmFzZS5tb2RlbC5mbGFnc1tuYW1lXSA9IHRoaXM7XG4gICAgfVxuXG4gICAgLy8gY29uc29sZS5sb2coJ0xFWlogU0VUIElUIScsIHZhbCwgc3RhbXAsIHJlc2V0LCBjdXJyZW50KVxuXG4gICAgdmFyIGdldERhdGEgPSBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBkYXRhID0gdGhpcy5fZDtcbiAgICAgIGlmIChkYXRhID09PSB2b2lkIDApIHtcbiAgICAgICAgdmFyIHBhcmVudCA9IHRoaXM7XG4gICAgICAgIHdoaWxlIChkYXRhID09PSB2b2lkIDAgJiYgcGFyZW50KSB7XG5cbiAgICAgICAgICAvLyBpZihwYXJlbnQubW9kZWwgJiYgKCFwYXJlbnQubW9kZWwuaW5oZXJpdCB8fCBwYXJlbnQubW9kZWwuaW5oZXJpdC52YWwhPT1mYWxzZSkpIHtcbiAgICAgICAgICAvLyAgIHJldHVybiBkYXRhXG4gICAgICAgICAgLy8gfVxuXG4gICAgICAgICAgaWYgKHBhcmVudC5fZCkge1xuICAgICAgICAgICAgZGF0YSA9IHRoaXMuX2RTZXQocGFyZW50Ll9kLCB0cnVlKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcGFyZW50ID0gcGFyZW50Lm5vZGUucGFyZW50Tm9kZTtcbiAgICAgICAgICAgIGlmIChwYXJlbnQpIHtcbiAgICAgICAgICAgICAgcGFyZW50ID0gcGFyZW50LmJhc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gZGF0YTtcbiAgICB9O1xuICAgIGlmICh2YWwgaW5zdGFuY2VvZiBPYmplY3QpIHtcbiAgICAgIHZhciB2ID0gdmFsLnZhbCB8fCB2YWw7XG4gICAgICB0aGlzLl92YWwgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGRhdGEgPSBnZXREYXRhLmNhbGwodGhpcyk7XG4gICAgICAgIC8vIGNvbnNvbGUubG9nKCctLS0tPicsdixkYXRhKVxuICAgICAgICByZXR1cm4gZGF0YSAmJiB2LmNhbGwodGhpcywgZGF0YSk7XG4gICAgICB9O1xuICAgICAgdmFsID0gdmFsLmxpc3RlbiB8fCB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl92YWwgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGRhdGEgPSBnZXREYXRhLmNhbGwodGhpcyksXG4gICAgICAgICAgcmV0O1xuICAgICAgICBkYXRhID0gdmFsID09PSB0cnVlID8gZGF0YSA6IHV0aWwuZ2V0KGRhdGEsIHZhbCk7XG4gICAgICAgIGlmIChkYXRhICE9PSB2b2lkIDApIHtcbiAgICAgICAgICByZXQgPSBkYXRhLl9fdCAmJiAhZGF0YS5fZmlsdGVyICYmIGRhdGEudmFsO1xuICAgICAgICAgIGlmICghcmV0ICYmIHJldCAhPT0gMCAmJiByZXQgIT09ICcnKSB7IC8vd2VpcmRcbiAgICAgICAgICAgIHJldCA9IGRhdGE7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldCA9ICcnO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgICB9O1xuICAgIH1cbiAgICBpZighdGhpcy5fZmxhZykgdGhpcy5fZmxhZyA9IHt9XG5cbiAgICAvLyB0aGlzLl9fbHZhbCA9IGZhbHNlXG4gICAgLy8gY3VycmVudC5fY2FsbGVyLnNldFNldHRpbmcoe1xuICAgIC8vICAgbmFtZTogbmFtZSxcbiAgICAvLyAgIHBhcmVudDogZnVuY3Rpb24ocGFyZW50KSB7XG4gICAgLy8gICAgIGNvbnNvbGUubG9nKCchQCMhQCMhQCMnKVxuICAgIC8vICAgICB0aGlzLnVwZGF0ZURhdGEoKVxuICAgIC8vICAgfVxuICAgIC8vIH0pO1xuXG4gICAgdGhpcy5fZmxhZy5kYXRhID0gWydkYXRhJywgdGhpcy5fdmFsLCB2YWwsIG5hbWVdO1xuICB9LFxuICByZW1vdmU6IGZ1bmN0aW9uKCkge1xuICAgIHZhciBjdXJyZW50ID0gdGhpcy5jaGVja1BhcmVudCgnX3Byb3AubmFtZScpLFxuICAgICAgbW9kZWwgPSBvd25Nb2RlbChjdXJyZW50Ll9iYXNlKSxcbiAgICAgIHQgPSB0aGlzO1xuICAgIGlmIChtb2RlbCAmJiBtb2RlbC5mbGFncykge1xuICAgICAgZm9yICh2YXIgaSBpbiBtb2RlbC5mbGFncykge1xuICAgICAgICBpZiAoaSA9PT0gY3VycmVudC5fcHJvcC5uYW1lKSB7XG4gICAgICAgICAgdmFyIGl0ZW0gPSBtb2RlbC5mbGFnc1tpXTtcbiAgICAgICAgICBpZiAoaXRlbSBpbnN0YW5jZW9mIG9iamVjdCB8fCBpdGVtLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgbW9kZWwuZmxhZ3NbaV0gPSBudWxsO1xuICAgICAgICAgICAgZGVsZXRlIG1vZGVsLmZsYWdzW2ldO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBtb2RlbC5mbGFnc1tpXS5zcGxpY2UodXRpbC5jaGVja0FycmF5KGl0ZW0sIHQpLCAxKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5fdXBkYXRlKCkgLy9wYXMgaGllcm1lZSBvcCFcbiAgICAvLyB2YXIgdCA9IHRoaXNcbiAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgLy9kZXplIHBhcyB1aXR2b2VyZW4gbmFkYXQgYWxsZSBrbGFhciBpcyEgZGl0IGlzIGRpcnR5IVxuICAgICAgdC5fdXBkYXRlKClcbiAgICB9LDApXG4gIH1cbn07IiwiLyohXG4gKiBAbGljZW5zZSBDb3B5cmlnaHQgKGMpIDIwMTItMjAxNCwgVmlnb3VyLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogQGF1dGhvcjogSmltIGRlIEJlZXIsIGppbUB2aWdvdXIuaW9cbiAqL1xudmFyIHZhbHVlID0gcmVxdWlyZSgnLi4vJyksXG4gICAgYmFzZSA9IHJlcXVpcmUoJy4uL2Jhc2UnKSxcbiAgICBmbGFncyA9IHJlcXVpcmUoJy4uLy4uL29iamVjdC9mbGFncycpO1xuICAgIFxuICAgIGJhc2UuY2xvbmVsaXN0LnB1c2goWydfZmxhZycsIHRydWVdKTsgLy90cnVlIGNsb25lIVxuICAgIGZsYWdzLmV4dGVuZCh2YWx1ZSk7XG4gICAgbW9kdWxlLmV4cG9ydHMgPSB2YWx1ZS5mbGFnczsiLCIvKiFcbiAqIEBsaWNlbnNlIENvcHlyaWdodCAoYykgMjAxMi0yMDE0LCBWaWdvdXIuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBAYXV0aG9yOiBKaW0gZGUgQmVlciwgamltQHZpZ291ci5pb1xuICovXG52YXIgZmxhZ3MgPSBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vJylcbiAgLCB2YWx1ZSA9IHJlcXVpcmUoJy4uLycpXG4gICwgdXRpbCA9IHJlcXVpcmUoJy4uLy4uL3V0aWwnKVxuICAsIHZPYmplY3QgPSByZXF1aXJlKCcuLi8uLi9vYmplY3QnKVxuXG5cbi8vdG9kbyBhZGQgZWxlbWVudCBzaWduYXR1cmUgaW4gZnJvbSBzbyBpdCBjYW4gdHJhdmVsIHRyb3VnaCB1cGRhdGVzIC0tLSBpZiBwYXJlbnQgKG5lZWQgbGVzcyBmdW5reSB0aGluZ3MpXG5cbi8qKlxuICogcGFyZW50XG4gKiBwYXJlbnQgbWFrZXMgaXQgcG9zc2libGUgdG8gYWRkIGxpc3RlbmVycyB0byBwYXJlbnQgcHJvcGVydGllc1xuICogdXNpbmcgbXVsdGlwbGUgcGFyZW50IHByb3BlcnRpZXMgaW4gb25lIHByb3BlcnR5IGlzIHN0aWxsIHZlcnkgd3JvbmdcbiAqIEBmbGFnXG4gKi9cbnZhbHVlLnByb3RvdHlwZS5fYmxhY2tsaXN0LnB1c2goJ19wYXJlbnRTdG9yZScpXG5cbmZ1bmN0aW9uIGJhc2VSZXNldChiYXNlLG5hbWUpIHtcbiAgaWYoYmFzZSAmJiBiYXNlLm5vZGUpIHtcbiAgICBpZihuYW1lPT09J3gnIHx8IG5hbWUgPT09J3knKSBiYXNlLmNsZWFuQ29vcmRpbmF0ZXMobmFtZSlcbiAgICBpZihiYXNlW25hbWVdKSB7XG4gICAgICBiYXNlW25hbWVdLl9wcm9wLl92c2V0LmNhbGwoYmFzZVtuYW1lXSlcbiAgICB9XG4gIH1cbn1cblxuXG4vLyB3aW5kb3cucGNoZWNrID0gMFxuXG4vLyB3aW5kb3cucHByb3BzID0ge31cblxuLy9iYXNlLHZzZXQsdCx0eXBlLG1wYXJlbnQsZmJhc2UsIHYsIHZhbCwgc3RhbXAsIGZyb20sIHJlbW92ZSwgYWRkZWQsIG9sZHZhbCwgdHJ1ZSwgZmlyc3RTa2lwXG5mdW5jdGlvbiBjaGVja2VyKHZzZXQsIHQsIHR5cGUsIG1wYXJlbnQsIGZiYXNlLCB2LCB2YWwsIHN0YW1wLCBmcm9tLCByZW1vdmUsIGFkZGVkLCBvbGR2YWwsIGZpcnN0LCBmaXJzdFNraXAsIHApIHtcbiAgaWYocCYmKHRoaXMucGFyZW50IGluc3RhbmNlb2YgbXBhcmVudCkgfHwgICghcCAmJiB0aGlzLnBhcmVudD09PW1wYXJlbnQpIHx8IGZpcnN0U2tpcCApIHtcblxuICAgIC8vIHBjaGVjaysrXG5cbiAgICB2YXIgc1xuICAgICAgLCBiYXNlID0gdGhpcy5fZnJvbS5iYXNlLm5vZGUgJiYgdGhpcy5fZnJvbS5iYXNlXG4gICAgICAsIG5hbWUgPSB0Ll9wcm9wLm5hbWVcblxuICAgIC8vIGlmKCF3aW5kb3cucHByb3BzW25hbWVdKSB3aW5kb3cucHByb3BzW25hbWVdID0gMFxuXG4gICAgLy8gd2luZG93LnBwcm9wc1tuYW1lXSsrXG5cblxuICAgIHQuX2NhbGxlciA9IHRoaXNcblxuICAgIC8vZ2F1cmQgdm9vciBjaGFuZ2VzIC0tIGlmIG5vIGNoYW5nZSAtLSBkbyBub3RoaW5nXG4gICAgdnNldC5jYWxsKHQsIHN0YW1wLCBmcm9tLCByZW1vdmUsIHZhbClcblxuICAgIGlmKGJhc2UmJmJhc2VbbmFtZV0mJmJhc2VbbmFtZSsnX19wJ10hPT1zdGFtcCkge1xuICAgICAgdC5fY2FsbGVyID0gYmFzZVxuICAgICAgdC5fY2FsbGVyW25hbWUrJ19fcCddID0gc3RhbXBcbiAgICAgIHZzZXQuY2FsbCh0LCBzdGFtcCwgZnJvbSwgcmVtb3ZlLCB2YWwpXG4gICAgICB0Ll9jYWxsZXIgPSB0aGlzXG4gICAgICBzPXRydWVcbiAgICB9XG5cbiAgICAvLyBjb25zb2xlLmxvZyh0aGlzLm5vZGUpXG4gICAgZm9yKHZhciBpIGluIHQuX2xpc3RlbmVycykge1xuICAgICAgaWYodC5fbGlzdGVuZXJzW2ldLnBvcCAmJiB0Ll9saXN0ZW5lcnNbaV1bMl09PT0ncGFyZW50Jykge1xuICAgICAgICBpZih0Ll9saXN0ZW5lcnNbaV1bMV0uX2xzdGFtcD09PXN0YW1wKSB7XG4gICAgICAgICAgdC5fbGlzdGVuZXJzW2ldWzFdLl9sc3RhbXA9bnVsbFxuICAgICAgICB9XG4gICAgICAgIHQuX2xpc3RlbmVyc1tpXVswXS5jYWxsKHQuX2xpc3RlbmVyc1tpXVsxXSwgdHlwZSwgdGhpcywgYmFzZSwgdiwgdmFsLCBzdGFtcCwgZnJvbSwgcmVtb3ZlLCBhZGRlZCwgb2xkdmFsLCB0cnVlKVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vcmVzZXQgdGhpcy5fZnJvbS5iYXNlW3QuX3Byb3AubmFtZV09PT10XG4gICAgaWYocykgYmFzZVJlc2V0KGJhc2UsIG5hbWUpXG5cbiAgfVxufVxuXG5mdW5jdGlvbiB1cGRhdGVIYW5kbGVyKHR5cGUsbXBhcmVudCxmYmFzZSx2LCB2YWwsIHN0YW1wLCBmcm9tLCByZW1vdmUsIGFkZGVkLCBvbGR2YWwsZmlyc3RTa2lwLGluaGVyaXQpIHtcblxuICB2YXIgdCA9IHRoaXNcblxuICB0aGlzLl9wYXJlbnRTdG9yZVswXSA9IG1wYXJlbnRcblxuICB0aGlzLl91cGRhdGUodmFsLCBmcm9tID8gdGhpcy5zdGFtcCgpIDogc3RhbXAsIGZyb20sIHJlbW92ZSwgYWRkZWQsIG9sZHZhbCwgZmFsc2UsIGZhbHNlLCBmdW5jdGlvbigpIHtcbiAgICB2YXIgdnNldCA9ICB0aGlzLmNoZWNrUGFyZW50KCdfcHJvcC5fdnNldCcsIHRydWUpXG4gICAgICAsIGJhc2UgPSB0aGlzLmNoZWNrUGFyZW50KCdfYmFzZScsIHRydWUpXG4gICAgICAsIGNvbXBsZXhQYXJlbnQgPSB0cnVlXG4gICAgICAsIHBcblxuICAgIGlmKCAobXBhcmVudD09PWJhc2UucGFyZW50ICYmIGZyb20pICApIHtcbiAgICAgIHAgPSB0cnVlXG4gICAgfVxuXG4gICAgY2hlY2tlci5jYWxsKGJhc2UsdnNldCx0LHR5cGUsbXBhcmVudCxmYmFzZSwgdiwgdmFsLCBzdGFtcCwgZmFsc2UsIHJlbW92ZSwgYWRkZWQsIG9sZHZhbCwgdHJ1ZSwgZmlyc3RTa2lwKVxuXG4gICAgYmFzZS5lYWNoSW5zdGFuY2UoZnVuY3Rpb24oKSB7XG4gICAgIGNoZWNrZXIuY2FsbCh0aGlzLCB2c2V0LCB0LHR5cGUsIG1wYXJlbnQsZmJhc2UsIHYsIHZhbCwgc3RhbXAsIGZhbHNlLCByZW1vdmUsIGFkZGVkLCBvbGR2YWwsIGZhbHNlLCBwKVxuICAgIH0sIHQuX3Byb3AubmFtZSlcblxuICAgIHZPYmplY3QucHJvdG90eXBlLl91cGRhdGUuY2FsbCh0aGlzLCB2YWwsIHN0YW1wLCBmYWxzZSwgcmVtb3ZlLCBhZGRlZCwgb2xkdmFsLCBmdW5jdGlvbihsKSB7XG4gICAgICByZXR1cm4gbFsyXT09PSdwYXJlbnQnXG4gICAgfSlcblxuICAgIGlmKCFpbmhlcml0ICYmIHYuX2NhbGxlciAmJiBtcGFyZW50IT09di5fY2FsbGVyKSB7XG4gICAgICB1cGRhdGVIYW5kbGVyLmNhbGwodGhpcyx0eXBlLHYuX2NhbGxlcixmYmFzZSwgdiwgdmFsLCBzdGFtcCwgZmFsc2UsIHJlbW92ZSwgYWRkZWQsIG9sZHZhbCxmaXJzdFNraXAsdHJ1ZSlcbiAgICB9XG5cbiAgfSlcbn1cblxuZnVuY3Rpb24gX3BhcmVudChwYXJlbnQsIG5vdXBkYXRlLCBwcm9wLCBmbGFnLCByZXNldCkge1xuXG4gIC8vIGNvbnNvbGUubG9nKCdfcGFyZW50IGNhbGwnLmN5YW4uaW52ZXJzZSwgZmxhZylcblxuICB2YXIgX2xwYXJlbnQgPSBwcm9wLl9wYXJlbnRTdG9yZVswXVxuICAgICwgcG5hbWUgPSBmbGFnWzJdICAgLy9mbGFncy5wYXJlbnQudmFsXG4gICAgLCBwcHJvcCA9IHBhcmVudFtwbmFtZV1cbiAgICAsIGZiYXNlID0gdGhpcy5fZnJvbS5iYXNlXG4gICAgLCBuZXdQXG4gICAgLCBiYXNlU2V0XG5cbiAgaWYgKCFwcHJvcCkgcmV0dXJuXG5cbiAgLy8gY29uc29sZS5sb2coJ0FERCBMSVNURU5FUiBUTyBQQVJFTlQnKVxuXG4gIHBwcm9wLmFkZExpc3RlbmVyKFxuICAgIFsgdXBkYXRlSGFuZGxlclxuICAgICwgcHJvcFxuICAgICwgJ3BhcmVudCdcbiAgICAsIHBhcmVudFxuICAgICwgdGhpcyAvL2ZiYXNlXG4gIF0sIGZ1bmN0aW9uKGwsbGlzdGVuZXJzLGluZGV4KSB7XG5cbiAgICBpZihsWzNdIT09cGFyZW50ICYmICBfbHBhcmVudCE9PXBhcmVudCAmJiBsWzRdIT09ZmJhc2UpIHtcbiAgICAgIHByb3AuX3BhcmVudFN0b3JlWzBdID0gcGFyZW50XG4gICAgICBsWzRdID0gZmJhc2VcbiAgICAgIG5ld1AgPSB0cnVlIC8vaG9lIGRlemUgc21hcnQgYWZ2YW5nZW4/XG4gICAgfVxuICB9LCBmYWxzZSwgdHJ1ZSlcblxuICAvLyBpZihyZXNldCkge1xuICAvLyAgIGZvcih2YXIgaSBpbiBwcHJvcC5fbGlzdGVuZXJzKSB7XG4gIC8vICAgICBpZihwcHJvcC5fbGlzdGVuZXJzW2ldLnBvcCAmJiBwcHJvcC5fbGlzdGVuZXJzW2ldWzFdPT09ZmJhc2VbcHJvcC5fcHJvcC5uYW1lXSkge1xuICAvLyAgICAgICBpZihwcHJvcCE9PXBhcmVudC5fZnJvbS5iYXNlW3BuYW1lXSkge1xuICAvLyAgICAgICAgIHBwcm9wLl9saXN0ZW5lcnMuc3BsaWNlKGksMSlcbiAgLy8gICAgICAgICBicmVhaztcbiAgLy8gICAgICAgfVxuICAvLyAgICAgfVxuICAvLyAgIH1cbiAgLy8gfVxuXG4gIGlmIChuZXdQIHx8ICghX2xwYXJlbnQgfHwgKF9scGFyZW50ICE9PSBwYXJlbnQgJiYgX2xwYXJlbnRbcG5hbWVdICE9PSBwcHJvcCkgKSApIHtcbiAgICBwcm9wLl9wYXJlbnRTdG9yZVswXSA9IHBhcmVudFxuICAgIGlmICghbm91cGRhdGUpIHtcbiAgICAgIHByb3AuX2NhbGxlciA9IChiYXNlU2V0ID0gZmJhc2Uubm9kZSAmJiBmYmFzZSB8fCBwcm9wLl9iYXNlKVxuICAgICAgcHJvcC5fcHJvcC5fdnNldC5jYWxsKHByb3AsIHByb3ApXG4gICAgICBwcm9wLl9jYWxsZXIgPSB0aGlzXG4gICAgICB1cGRhdGVIYW5kbGVyLmNhbGwocHJvcCwncGFyZW50JyxwYXJlbnQsZmJhc2UscHByb3AsZmFsc2Usdk9iamVjdC5zdGFtcCgpLGZhbHNlLGZhbHNlLGZhbHNlLGZhbHNlLHRydWUsdHJ1ZSlcbiAgICAgIGJhc2VSZXNldChiYXNlU2V0LHByb3AuX3Byb3AubmFtZSlcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gX2luaXQodmFsLCBmbGFnLCByZXNldCkge1xuICB2YXIgcGFyZW50ID0gdGhpcy5wYXJlbnRcbiAgLy8gY29uc29sZS5sb2coJ3RyeSBwYXJlbnQnLCBmbGFnLCBwYXJlbnQpXG4gIGlmIChwYXJlbnQpIF9wYXJlbnQuY2FsbCh0aGlzLCBwYXJlbnQsIHRydWUsIHZhbCwgZmxhZywgcmVzZXQpXG59XG5cbmZ1bmN0aW9uIF92YWwodmFsKSB7XG4gIHZhciBwYXJlbnQgPSB0aGlzLnBhcmVudCB8fCB2YWwuY2hlY2tQYXJlbnQoJ19wYXJlbnRTdG9yZS4wJywgdHJ1ZSlcbiAgLy9mbGFncy5wYXJlbnQudmFsXG4gIGlmKHBhcmVudCAmJiAhdmFsLl9mbGFnLnBhcmVudCkge1xuICAgIGNvbnNvbGUuZXJyb3IoJ05PIFBBUkVOVCBGTEFHIScpXG4gICAgcmV0dXJuXG4gIH1cbiAgLy8gY29uc29sZS5sb2coJy0tLS0+Jyx2YWwuX2ZsYWcucGFyZW50WzJdKVxuICBpZiAocGFyZW50ICkgcmV0dXJuIHBhcmVudFt2YWwuX2ZsYWcucGFyZW50WzJdXS52YWxcbn1cblxuZmxhZ3MucGFyZW50ID1cbnsgcmVzZXQ6IHRydWVcbiwgdXNlVmFsOiB0cnVlXG4sIHNldDogZnVuY3Rpb24odmFsLCBzdGFtcCwgcmVzZXQpIHtcbiAgICB2YXIgY3VycmVudCA9IHRoaXMuY2hlY2tQYXJlbnQoJ19wcm9wLm5hbWUnKSxcbiAgICAgIG5hbWUgPSBjdXJyZW50Ll9wcm9wLm5hbWVcbiAgICAvL2ZsYWdzLnBhcmVudC52YWxcbiAgICBpZighdGhpcy5fZmxhZykgdGhpcy5fZmxhZyA9IHt9XG5cbiAgICAgIC8vb3ZlcndyaXRpbmcgcHJldmlvdXMgcGFyZW50XG4gICAgICAvL1xuICAgIC8vIGNvbnNvbGUubG9nKCdTRVQgUEFSRU5ULS0tLT4nKVxuICAgIHRoaXMuX2ZsYWcucGFyZW50ID0gWydwYXJlbnQnLCBfdmFsLCB2YWwsIHRoaXNdXG4gICAgaWYgKCFjdXJyZW50Ll9wYXJlbnRTdG9yZSkgY3VycmVudC5fcGFyZW50U3RvcmUgPSBbZmFsc2VdXG5cbiAgICAvLyBjb25zb2xlLmxvZygnR09UUyBQQVJFTlRTVE9SRSEnLCByZXNldCwgY3VycmVudC5fcGFyZW50U3RvcmUsIHRoaXMuX2ZsYWcucGFyZW50KVxuXG4gICAgY3VycmVudC5fcGFyZW50U3RvcmUucHVzaCh0aGlzKVxuICAgIC8vc2V0UGFyZW50IHNldHRpbmdzXG4gICAgLy8gY29uc29sZS5sb2coJy0tLT4gQ1JFQVRFIFNFVFRJTkcnLnllbGxvdy5pbnZlcnNlKVxuICAgIGN1cnJlbnQuX2NhbGxlci5zZXRTZXR0aW5nKHtcbiAgICAgIG5hbWU6IG5hbWUsXG4gICAgICBwYXJlbnQ6IGZ1bmN0aW9uKHBhcmVudCkge1xuXG4gICAgICAgIC8vIGNvbnNvbGUubG9nKCctLS0+IFNFVCBTRVRUSU5HJy55ZWxsb3cuaW52ZXJzZSlcblxuICAgICAgICBmb3IgKHZhciBzdG9yZSA9IHRoaXNbbmFtZV0uX3BhcmVudFN0b3JlLCBpID0gc3RvcmUgPyBzdG9yZS5sZW5ndGggLSAxIDogMDsgaSA+IDA7IGktLSkge1xuICAgICAgICAgIGlmKHN0b3JlW2ldLl9mbGFnLnBhcmVudCkge1xuICAgICAgICAgICAgX3BhcmVudC5jYWxsKHRoaXMsIHBhcmVudCwgZmFsc2UsIHRoaXNbbmFtZV0sIHN0b3JlW2ldLl9mbGFnLnBhcmVudClcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcignMiBOTyBQQVJFTlQgRkxBRyEnKVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICAgIC8vdHJ5IHRvIG1pbmltaXplIHZhbCBjYWx1bGF0aW9uc1xuICAgIHRoaXMuX3ZhbCA9IF92YWxcbiAgICB0aGlzLl9za2lwID0gdHJ1ZVxuICAgIC8vb25Jbml0IChpZiBpdCBhbHJlYWR5IGhhcyBzb21lIHBhcmVudHMpXG4gICAgX2luaXQuY2FsbChjdXJyZW50Ll9iYXNlLCBjdXJyZW50LCB0aGlzLl9mbGFnLnBhcmVudCwgcmVzZXQpXG4gICAgLy9yZUF0dGFjaCBsaXN0ZW5lcnMgZm9yIGluc3RhbmNlc1xuICAgIGN1cnJlbnQuX2Jhc2UuZWFjaEluc3RhbmNlKF9pbml0LCBuYW1lLCBjdXJyZW50LCB0aGlzLl9mbGFnLnBhcmVudClcbiAgfVxuLCByZW1vdmU6IGZ1bmN0aW9uKGZsYWcpIHtcblxuICAgIC8vIGNvbnNvbGUubG9nKCdSRU1PVkUgUEFSRU5UJy5jeWFuLmludmVyc2UpXG5cbiAgICB2YXIgY3VycmVudCA9IHRoaXMuY2hlY2tQYXJlbnQoJ19wcm9wLm5hbWUnKSxcbiAgICAgIGJhc2UgPSBjdXJyZW50Ll9iYXNlLFxuICAgICAgbGlzdGVucyA9IGN1cnJlbnQuX2xpc3RlbnMsXG4gICAgICBuYW1lID0gY3VycmVudC5fcHJvcC5uYW1lLFxuICAgICAgdmFsID0gZmxhZ1syXSwgIC8vZmxhZ3MucGFyZW50LnZhbFxuICAgICAgcGFyZW50U3RvcmUgPSBjdXJyZW50Ll9wYXJlbnRTdG9yZSxcbiAgICAgIHJlbW92ZWxpc3RlbmVyID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBwYXJlbnQgPSB0aGlzLnBhcmVudFxuICAgICAgICBpZiAocGFyZW50ICYmIHBhcmVudFt2YWxdKSB7XG4gICAgICAgICAgaWYgKGxpc3RlbnMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgaWYgKHV0aWwuY2hlY2tBcnJheShsaXN0ZW5zLCBwYXJlbnRbdmFsXSkpIHtcbiAgICAgICAgICAgICAgLy8gY29uc29sZS5sb2coJ1JFTU9WRSBMSVNURU5FUiEnLCBwYXJlbnRbdmFsXSwgbGlzdGVucy5sZW5ndGgsIHBhcmVudFt2YWxdLl9saXN0ZW5lcnMubGVuZ3RoLCBwYXJlbnRbdmFsXS5fbGlzdGVuZXJzICwgY3VycmVudClcblxuXG4gICAgICAgICAgICAgIC8vbW9yZSBzcGVjaWZpYyBvbmx5IHJlbW92ZSBpZiB2YWwgbWF0Y2hlcyAtLS0gc3RvcmUgZnVuY3Rpb25cbiAgICAgICAgICAgICAgcGFyZW50W3ZhbF0ucmVtb3ZlTGlzdGVuZXIoIGZhbHNlLCBjdXJyZW50IClcblxuICAgICAgICAgICAgICAvL21hcmsgPSBmYWxzZVxuXG5cbiAgICAgICAgICAgICAgLy8gY29uc29sZS5sb2coJ1JFTU9WRSBMSVNURU5FUiEgLS0gcmVzdWx0IC0tIG5vIHVwZGF0ZT8nLCBsaXN0ZW5zLmxlbmd0aClcblxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgdGhpcy5fdmFsID0gMFxuXG4gICAgaWYgKGxpc3RlbnMgJiYgIXJlbW92ZWxpc3RlbmVyLmNhbGwoYmFzZSkpIHtcbiAgICAgIGJhc2UuZWFjaEluc3RhbmNlKHJlbW92ZWxpc3RlbmVyLCBuYW1lKVxuICAgIH1cblxuICAgIC8vIGNvbnNvbGUubG9nKCdQQVJFTlRTVE9SRScsIHBhcmVudFN0b3JlLCBjdXJyZW50KVxuICAgIHBhcmVudFN0b3JlLnNwbGljZSh1dGlsLmNoZWNrQXJyYXkocGFyZW50U3RvcmUsIHRoaXMsIHRydWUpLCAxKVxuXG4gICAgaWYgKHBhcmVudFN0b3JlLmxlbmd0aCA9PT0gMSkge1xuICAgICAgLy8gY29uc29sZS5sb2coJy0tLT4gUkVNT1ZFIFNFVFRJTkcnLnllbGxvdy5pbnZlcnNlLCBwYXJlbnRTdG9yZSlcbiAgICAgIGJhc2UucmVtb3ZlU2V0dGluZyhuYW1lLCAncGFyZW50JykgLy9mZiBjb3JpZ2VyZW4gdm9vciBhbmRlcmUgcGFyZW50IHNldHRpbmdzISEhIG9wIGFuZGVyZSBmaWVsZHNcbiAgICAgIC8vZGl0IG1hYWt0IGhldCBoZWxlbWFhbCBrYXBvdCFcbiAgICAgIC8vIGNvbnNvbGUud2FybignUkVNT1ZFIFBBUkVOVFNUT1JFIScpXG4gICAgICBjdXJyZW50Ll9wYXJlbnRTdG9yZSA9IG51bGxcbiAgICB9XG4gIH1cbn0iLCIvKiFcbiAqIEBsaWNlbnNlIENvcHlyaWdodCAoYykgMjAxMi0yMDE0LCBWaWdvdXIuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBAYXV0aG9yOiBKaW0gZGUgQmVlciwgamltQHZpZ291ci5pb1xuICovXG5cbi8vVE9ETzogZmxhZ3Mgb24gdGhlIGJhc2lzIG9mIHBhdGggKCBzaW1pbGFpciB0byBjYXNlcyApXG5cbi8vVE9ETzogbWFrZSBWYWx1ZSBmbGFncyBtb3JlIGluamVjdGFibGVcbnZhciBmbGFncyA9IG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSggJy4vJyApXG4gICwgcHJvY2Vzc2VzID0gcmVxdWlyZSggJy4uLy4uL3V0aWwvcHJvY2VzcycgKVxuICAsIFZhbHVlID0gcmVxdWlyZSggJy4uLycgKVxuICAsIHV0aWwgPSByZXF1aXJlKCAnLi4vLi4vdXRpbCcgKVxuICAsIGFqYXggPSByZXF1aXJlKCcuLi8uLi9icm93c2VyL25ldHdvcmsvYWpheCcpXG4gICwgdk9iamVjdCA9IHJlcXVpcmUoJy4uLy4uL29iamVjdCcpXG5cbi8vVE9ETzogbWF5YmUgYWRkIHByb21pc2VcblxuZXhwb3J0cy5jcmVhdGUgPSBmdW5jdGlvbiggZmxhZywgc2V0dGluZ3MsIENvbnN0cnVjdG9yLCBleHRlbmRmbGFncyApIHtcblxuICBpZiggIWV4dGVuZGZsYWdzICkgZXh0ZW5kZmxhZ3MgPSBmbGFnc1xuICBpZiggIUNvbnN0cnVjdG9yICkgQ29uc3RydWN0b3IgPSBWYWx1ZVxuXG4gIHZhciB0ZW1wU3RvcmUgPSAnX190ZW1wJytmbGFnKydfXydcbiAgICAsIGluUHJvZ3Jlc3MgPSAgJ19faW5wcm9ncmVzcycrZmxhZysnX18nXG4gICAgLCBvcmlnVXBkYXRlID0gQ29uc3RydWN0b3IucHJvdG90eXBlLl91cGRhdGVcbiAgICAsIG9uY2UgPSBzZXR0aW5ncyAmJiBzZXR0aW5ncy5vbmNlXG4gICAgLCBkZWZlck1ldGhvZCA9IHNldHRpbmdzICYmIHNldHRpbmdzLmRlZmVyTWV0aG9kXG4gICAgLCBvcmlnU2V0XG4gICAgLCBvcmlnUmVtb3ZlXG4gICAgLCBkZWZlcmZsYWcgPSBcbiAgICAgIHsgcmVzZXQ6IHRydWVcbiAgICAgICwgc2V0OiBmdW5jdGlvbiggdmFsLCBzdGFtcCwgcmVzZXQgKSB7XG4gICAgICAgICAgaWYoICF0aGlzLl9mbGFnICkgdGhpcy5fZmxhZyA9IHt9XG4gICAgICAgICAgdGhpcy5fZmxhZ1tmbGFnXSA9IFsgZmxhZywgZmFsc2UsIHZhbCwgdGhpcyBdXG4gICAgICAgIH1cbiAgICAgICwgcmVtb3ZlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICB2YXIgZGVmZXIgPSB0aGlzLl9mbGFnICYmIHRoaXMuX2ZsYWdbZmxhZ11cbiAgICAgICAgICAgICwgdm9ialxuXG4gICAgICAgICAgaWYoIGRlZmVyICYmIGRlZmVyWzFdIClcbiAgICAgICAgICB7XG5cbiAgICAgICAgICAgIC8vIGlmKCBkZWZlck1ldGhvZCApIFxuICAgICAgICAgICAgLy8ge1xuICAgICAgICAgICAgICAvLyB2b2JqID0gZGVmZXJNZXRob2QuY2FsbCggX3RoaXMsIGFyciwgZGVmZXJbMl0sIF90aGlzW3RlbXBTdG9yZV0sIG9yaWdVcGRhdGUsIENvbnN0cnVjdG9yIClcbiAgICAgICAgICAgIC8vIH1cbiAgICAgICAgICAgIC8vIGlmKCkge1xuICAgICAgICAgICAgICB2b2JqID0gdHlwZW9mIGRlZmVyWzJdID09PSAnc3RyaW5nJ1xuICAgICAgICAgICAgICAgICAgID8gcHJvY2Vzc2VzW2RlZmVyWzJdXVxuICAgICAgICAgICAgICAgICAgIDogdHlwZW9mIGRlZmVyWzJdICE9PSAnZnVuY3Rpb24nICYmIGRlZmVyWzJdXG4gICAgICAgICAgICAvLyB9XG5cbiAgICAgICAgICAgIGlmKCB2b2JqLnJlbW92ZUxpc3RlbmVyIClcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgdm9iai5yZW1vdmVMaXN0ZW5lciggZGVmZXJbMV0gKVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiggdm9iaiAmJiB2b2JqICE9PSB0cnVlIClcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgZm9yKCB2YXIgdm9iaiQgaW4gdm9iaiApXG4gICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB2b2JqLnJlbW92ZUxpc3RlbmVyKCB2b2JqW3ZvYmokXSApXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuXG4gIENvbnN0cnVjdG9yLnByb3RvdHlwZS5fYmxhY2tsaXN0LnB1c2hcbiAgKCB0ZW1wU3RvcmVcbiAgLCBpblByb2dyZXNzXG4gICwgJ19oaXN0b3J5J1xuICAvLyAsICdfaW5pdGlhbGlzZWQnXG4gIClcblxuICBpZiggZGVmZXJNZXRob2QgKSB7XG4gICAgc2V0dGluZ3MuZGVmZXJNZXRob2QgPSBudWxsXG4gIH1cblxuICAgaWYoIG9uY2UgKSB7XG4gICAgc2V0dGluZ3Mub25jZSA9IG51bGxcbiAgICBDb25zdHJ1Y3Rvci5wcm90b3R5cGUuX2JsYWNrbGlzdC5wdXNoKCBvbmNlIClcbiAgfVxuXG4gIGlmKCBzZXR0aW5ncyApIHtcbiAgICBmb3IoIHZhciBrZXkgaW4gc2V0dGluZ3MgKVxuICAgIHtcbiAgICAgIGlmKCBrZXkgPT09ICdzZXQnIClcbiAgICAgIHtcbiAgICAgICAgb3JpZ1NldCA9IGRlZmVyZmxhZy5zZXRcbiAgICAgICAgZGVmZXJmbGFnLnNldCA9IGZ1bmN0aW9uKCB2YWwsIHN0YW1wLCByZXNldCApIHtcbiAgICAgICAgICBzZXR0aW5ncy5zZXQuY2FsbCggdGhpcywgb3JpZ1NldCwgYXJndW1lbnRzIClcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZWxzZSBpZigga2V5ID09PSAncmVtb3ZlJyApXG4gICAgICB7XG4gICAgICAgIG9yaWdSZW1vdmUgPSBkZWZlcmZsYWcucmVtb3ZlXG4gICAgICAgIGRlZmVyZmxhZy5yZW1vdmUgPSBmdW5jdGlvbiggdmFsLCBzdGFtcCwgcmVzZXQgKSB7XG4gICAgICAgICAgc2V0dGluZ3MucmVtb3ZlLmNhbGwoIHRoaXMsIG9yaWdSZW1vdmUsIGFyZ3VtZW50cyApXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGVsc2UgXG4gICAgICB7XG4gICAgICAgIGRlZmVyZmxhZ1trZXldID0gc2V0dGluZ3Nba2V5XVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGV4dGVuZGZsYWdzW2ZsYWddID0gZGVmZXJmbGFnXG5cbiAgLy9leHRlbmQgdXBkYXRlXG4gIHV0aWwuZGVmaW5lXG4gICggQ29uc3RydWN0b3JcbiAgLCAnX3VwZGF0ZSdcbiAgLCBmdW5jdGlvbiggdmFsLCBzdGFtcCApIHtcblxuICAgICAgaWYoIHRoaXMuX2ZsYWcgJiYgdGhpcy5fZmxhZ1tmbGFnXSAmJiAoICFvbmNlIHx8ICF0aGlzW29uY2VdICkgKSAvLyYmICF0aGlzLl9pbml0aWFsaXNlZCBcbiAgICAgIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpc1xuICAgICAgICAgICwgZGVmZXIgPSBfdGhpcy5fZmxhZyAmJiBfdGhpcy5fZmxhZ1tmbGFnXVxuICAgICAgICAgICwgdGVtcGRlZmVyID0gX3RoaXNbdGVtcFN0b3JlXVxuICAgICAgICAgICwgYWRkXG4gICAgICAgICAgLCBhcnJcbiAgICAgICAgICAsIHZvYmpcbiAgICAgICAgICAsIHJlY3VyXG4gICAgICAgICAgLCBmblxuXG5cbiAgICAgICAgaWYoICF0ZW1wZGVmZXIgKVxuICAgICAgICB7XG4gICAgICAgICAgX3RoaXNbdGVtcFN0b3JlXSA9IHRlbXBkZWZlciA9IFtdXG4gICAgICAgICAgYWRkID0gdHJ1ZVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vVE9ETzogZml4IGNhY2hpbmcgc3RhbXAsIG1vc3QgZWZmaWNpZW50IGJ1dCBtYXkgYnJlYWsgdGhpbmdzIC93IGluc3RhbmNlcyBldGNcblxuICAgICAgICAgIGlmKCBzdGFtcCAmJiB0ZW1wZGVmZXJbMF1bMV0gIT09IHN0YW1wIClcbiAgICAgICAgICB7XG4gICAgICAgICAgICB0ZW1wZGVmZXJbMF1bMV0gPSBzdGFtcFxuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm5cbiAgICAgICAgfVxuXG4gICAgICAgIGFyciA9IHV0aWwuYXJnKCBhcmd1bWVudHMgKVxuICAgICAgICB0ZW1wZGVmZXIucHVzaCggYXJyIClcblxuICAgICAgICBpZiggYWRkIClcbiAgICAgICAge1xuICAgICBcbiAgICAgICAgICBpZiggZGVmZXJNZXRob2QgKSBcbiAgICAgICAgICB7XG4gICAgICAgICAgICB2b2JqID0gZGVmZXJNZXRob2QuY2FsbCggX3RoaXMsIGFyciwgZGVmZXJbMl0sIHRlbXBTdG9yZSwgb3JpZ1VwZGF0ZSwgQ29uc3RydWN0b3IgKVxuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIHZvYmogPSB0eXBlb2YgZGVmZXJbMl0gPT09ICdzdHJpbmcnXG4gICAgICAgICAgICAgICA/IHByb2Nlc3Nlc1tkZWZlclsyXV1cbiAgICAgICAgICAgICAgIDogZGVmZXJbMl1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiggdm9iaiApXG4gICAgICAgICAge1xuICAgICAgICAgIFxuICAgICAgICAgICAgLy9UT0RPOiByZXBsYWNlIHdpdGggYSBzdGFuZGFyZCBmdW5jdGlvbiwgbG9zZSB0aGUgZXh0cmEgY2xvc3VyZSFcbiAgICAgICAgICAgIHJlY3VyID0gZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgICAgICAgaWYoIG9uY2UgKSBcbiAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIF90aGlzW29uY2VdID0gdHJ1ZVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIC8vZGl0IG9vayBrdW5uZW4gbWVlZ2V2ZW5cblxuICAgICAgICAgICAgICAvL1RPRE86IHVzaW5nIGEgY2xvc3VyZSBoZXJlIG1heSBub3QgYmUgbmVzc2VjYXJ5IGFueW1vcmUsIHVzZSBhbm90aGVyIGlkZW50aWZpZXJcbiAgICAgICAgICAgICAgZm9yKCB2YXIgaSA9IDAsIGxlbiA9IHRlbXBkZWZlci5sZW5ndGg7IGkgPCBsZW47IGkrKyApIHtcbiAgICAgICAgICAgICAgICAvLyBfdGhpcy5fY2FsbGVyID0gdGVtcGRlZmVyW2ldLnNwbGljZSggdGVtcGRlZmVyW2ldLmxlbmd0aC0xLCAxIClcbiAgICAgICAgICAgICAgICAvLyB0ZW1wZGVmZXJbaV1bMV0gPSB0aGlzLnN0YW1wKClcbiAgICAgICAgICAgICAgICBvcmlnVXBkYXRlLmFwcGx5KCBfdGhpcywgdGVtcGRlZmVyW2ldIClcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGlmKCB0aGlzLnJlbW92ZUxpc3RlbmVyICkgdGhpcy5yZW1vdmVMaXN0ZW5lciggcmVjdXIgKVxuICAgICAgICAgICAgICBfdGhpc1t0ZW1wU3RvcmVdID0gbnVsbFxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiggdHlwZW9mIHZvYmogPT09ICdmdW5jdGlvbicgKVxuICAgICAgICAgICAge1xuXG4gICAgICAgICAgICAgIGlmKCAhX3RoaXNbaW5Qcm9ncmVzc10gKVxuICAgICAgICAgICAgICB7XG5cbiAgICAgICAgICAgICAgICBmbiA9IGZ1bmN0aW9uKCB2YWwgKSB7XG4gICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgIGlmKCB2YWwhPT10cnVlICYmIF90aGlzW2luUHJvZ3Jlc3NdICkge1xuICAgICAgICAgICAgICAgICAgICBfdGhpc1tpblByb2dyZXNzXSgpXG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBfdGhpc1tpblByb2dyZXNzXSA9IG51bGxcbiAgICAgICAgICAgICAgICAgIF90aGlzW3RlbXBTdG9yZV0gPSBudWxsXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgX3RoaXNbaW5Qcm9ncmVzc10gPSByZWN1clxuXG4gICAgICAgICAgICAgICAgaWYoIHZvYmouY2FsbCggdGhpcywgZm4gLCBhcnIsIHRlbXBkZWZlciApID09PSB0cnVlIClcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICBfdGhpc1t0ZW1wU3RvcmVdID0gbnVsbFxuICAgICAgICAgICAgICAgICAgX3RoaXNbaW5Qcm9ncmVzc10gPSBudWxsXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIGVsc2VcbiAgICAgICAgICAgICAgICAvLyB7XG4gICAgICAgICAgICAgICAgLy8gICBjb25zb2xlLmxvZyggJz8nIClcbiAgICAgICAgICAgICAgICAvLyAgIC8vVE9ETzogY2hlY2sgaWYgdGhpcyBpcyB0aGUgYmVzdCB3YXksICh1cGRhdGluZyByZWN1ciwgb3IgbWF5ZWIganVzdCB1c2UgdGhlIHNhbWUgcmVjdXIpXG4gICAgICAgICAgICAgICAgLy8gICBfdGhpcy5fZGVmZXJpbnByb2dyZXNzID0gcmVjdXJcbiAgICAgICAgICAgICAgICAvLyB9XG5cbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmKCB2b2JqID09PSB0cnVlIClcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgaWYoIHRoaXMudmFsIHx8IHRoaXMudmFsID09PSAwIClcbiAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIG9yaWdVcGRhdGUuYXBwbHkoIF90aGlzLCBhcnIgKVxuICAgICAgICAgICAgICAgIF90aGlzW3RlbXBTdG9yZV0gPSBudWxsXG4gICAgICAgICAgICAgIH0gIFxuICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKCAnbm8gdmFsdWUhIGZyb20gZGVmZXIgdHlwZTonLCBmbGFnKVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmKCAhdm9iai5hZGRMaXN0ZW5lciApXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIGZvciggdmFyIHZvYmokIGluIHZvYmogKVxuICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdm9ialt2b2JqJF0uYWRkTGlzdGVuZXIoIHJlY3VyIClcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICB2b2JqLmFkZExpc3RlbmVyKCByZWN1ciApXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGRlZmVyWzFdID0gcmVjdXJcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgfVxuICAgICAgZWxzZVxuICAgICAge1xuICAgICAgICAvLyBjb25zb2xlLmxvZyggZmxhZywgb25jZSwgJ3Nob3VsZCBkbyBvcmlnIHVwZGF0ZSBiaXRjaGVzIScsIGFyZ3VtZW50cywgdGhpcyApXG4gICAgICAgIG9yaWdVcGRhdGUuYXBwbHkoIHRoaXMsIGFyZ3VtZW50cyApXG4gICAgICB9XG5cbiAgICB9XG4gIClcblxufSBcblxuLy9UT0RPOiBpbmplY3RhYmxlXG4vL1RPRE86X3RlbXBkZWZlciBob2VmdCBuaWV0IGFsdGlqZCBtYWFrIGNyZWF0ZSAtLSB1cGRhdGUgdHlwZSBmbGFnXG4vL2Fsd2F5cyB1cGRhdGUgbWV0aG9kXG5leHBvcnRzLmNyZWF0ZSggJ2ZvcmNlJywgXG57IGRlZmVyTWV0aG9kOiBmdW5jdGlvbiggYXJncywgdm9iaiwgdGVtcFN0b3JlLCB1cGRhdGUgKSB7XG4gICAgdmFyIF90aGlzID0gdGhpc1xuICAgIC8vZGl0IHppdCBuYXR1dXJsaWprIGRpZXBlciFcbiAgICBfdGhpcy5fc2tpcCA9IHRydWUgLy9tYXliZSBjaGVjayBpZiBpdCBybHkgZ2V0cyByZXNldD9cbiAgICBfdGhpcy5faWdub3JlVmFsdWUgPSB0cnVlXG4gICAgX3RoaXMuY2xlYXJDYWNoZSgpXG4gICAgX3RoaXNbIHRlbXBTdG9yZSBdID0gbnVsbFxuICAgIHVwZGF0ZS5hcHBseSggX3RoaXMsIGFyZ3MgKVxuICB9ICBcbn0pXG4vL2RlemUgbW9ldCBub2cgd2F0IGRpZXBlclxuXG5leHBvcnRzLmNyZWF0ZSggJ2hpc3RvcnknLCBcbnsgZGVmZXJNZXRob2Q6IGZ1bmN0aW9uKCBhcmdzLCB2b2JqLCB0ZW1wU3RvcmUsIHVwZGF0ZSwgQ29uc3RydWN0b3IgKSB7XG4gICAgLy92b2JqIG9wdGlvbiB2b29yIGZsYWdcbiAgICBpZighdGhpcy5faGlzdG9yeSkgdGhpcy5faGlzdG9yeSA9IFtdXG5cbiAgICB0aGlzLl9oaXN0b3J5LnVuc2hpZnQoIGFyZ3MgKVxuICAgIHRoaXNbdGVtcFN0b3JlXSA9IG51bGwgLy90b3RhbCBjb250cm9sISAob2xkIGluY2x1ZGluZyBhcmd1bWVudHMpXG5cbiAgICAvL2FsbHJpZ2h0IHRoYXQgd29ya3MgdGhpcy5jbGVhckNhY2hlKCkgLy9jYWNoZSBkaW5nZW4gYWRkZW5cbiAgICB1cGRhdGUuYXBwbHkoIHRoaXMsIGFyZ3MgKVxuICB9XG59KVxuXG5leHBvcnRzLmNyZWF0ZSggJyR0eXBlJywgXG57IGRlZmVyTWV0aG9kOiBmdW5jdGlvbiggYXJncywgdm9iaiwgdGVtcFN0b3JlLCB1cGRhdGUgKSB7XG4gICAgdmFyIF90aGlzID0gdGhpc1xuICAgICAgLCBoYXZlVG9VcGRhdGVcblxuICAgIC8vYXJyYXlzIGV0Y1xuICAgIF90aGlzLmNsZWFyQ2FjaGUoKVxuXG4gICAgaWYoIHZvYmogPT09IHRydWUgKVxuICAgIHtcbiAgICAgIGlmKCBfdGhpcy52YWwgKSBoYXZlVG9VcGRhdGUgPSB0cnVlXG4gICAgfVxuICAgIGVsc2UgaWYoIHZvYmogPT09ICdzdHJpbmcnIClcbiAgICB7XG4gICAgICBpZiggdHlwZW9mIF90aGlzLnZhbCA9PT0gJ3N0cmluZycgKSBoYXZlVG9VcGRhdGUgPSB0cnVlXG4gICAgfVxuICAgIGVsc2UgaWYoIHZvYmogPT09ICdudW1iZXInIClcbiAgICB7XG4gICAgICBpZiggdHlwZW9mIF90aGlzLnZhbCA9PT0gJ251bWJlcicgKSBoYXZlVG9VcGRhdGUgPSB0cnVlXG4gICAgfVxuICAgIGVsc2UgaWYoIHR5cGVvZiB2b2JqID09PSAnZnVuY3Rpb24nIClcbiAgICB7XG4gICAgICBpZiggdm9iai5hcHBseSggX3RoaXMsIGFyZ3MgKSApIGhhdmVUb1VwZGF0ZSA9IHRydWVcbiAgICB9XG5cbiAgICBpZiggaGF2ZVRvVXBkYXRlICkge1xuICAgICAgX3RoaXNbdGVtcFN0b3JlXSA9IG51bGxcbiAgICAgIHVwZGF0ZS5hcHBseSggX3RoaXMsIGFyZ3MgKVxuICAgIH1cbiAgfSAgXG59KVxuXG5leHBvcnRzLmNyZWF0ZSggJ2RlZmVyJyApXG5cbi8vVE9ETzogdk9iaiBmbGFnICggYWNjZXNzYWJsZSB0cm91Z2ggb2JqZWN0W2ZsYWddIClcblxuVmFsdWUub3BlcmF0b3JzLnJlc3BvbnNlRGF0YSA9IGZ1bmN0aW9uKCB2YWwsIG9wZXJhdG9yICkge1xuICByZXR1cm4gb3BlcmF0b3I9PT1mYWxzZSA/IHZhbCA6IG9wZXJhdG9yXG59XG5cbi8vdm9iaiBwYXJzZXIhXG5cbmV4cG9ydHMuY3JlYXRlKCAnYWpheCcsIFxueyByZW1vdmU6IGZ1bmN0aW9uKCByZW1vdmUsIGFyZ3MgKSB7XG4gICAgLy9UT0RPOiBhamF4IGNhbGwgc3RvcFxuICAgIHJlbW92ZS5hcHBseSggdGhpcywgYXJncyApXG4gIH1cbiwgc2V0OmZ1bmN0aW9uKCBzZXQsIGFyZ3MpIHtcbi8vICAgICBjb25zb2xlLmxvZygnc2V0IGFqYXggZGVmZXInKVxuICAgIGlmKCAhIHRoaXMubG9hZGluZyApIHtcbiAgICAgIC8vbmFtZSwgdmFsLCB2b2JqLCBzdGFtcCwgbm91cGRhdGUsIGZyb21cbiAgICAgIHRoaXMuc2V0KCAnbG9hZGluZycsIGZhbHNlLCBmYWxzZSwgZmFsc2UsIHRydWUgKVxuICAgIH1cbiAgICBzZXQuYXBwbHkoIHRoaXMsIGFyZ3MgKVxuICB9XG4sIGRlZmVyTWV0aG9kOiBmdW5jdGlvbiggYXJncywgdm9iaiwgdGVtcFN0b3JlLCB1cGRhdGUsIENvbnN0cnVjdG9yICkge1xuICAgIHZhciBfdGhpcyA9IHRoaXMgIFxuXG4gICAgcmV0dXJuIHZvYmogJiYgZnVuY3Rpb24oIHVwZGF0ZSwgYXJncyApIHtcblxuICAgICAgdmFyIG9yaWd1ID0gdXBkYXRlXG5cbiAgICAgIHVwZGF0ZSA9IGZ1bmN0aW9uKCB0eXBlLCBraWxsICkge1xuICAgICAgICBfdGhpcy5jbGVhckNhY2hlKClcbiAgICAgICAgX3RoaXMuX3NraXAgPSB0cnVlXG4gICAgICAgIF90aGlzLl9pZ25vcmVWYWx1ZSA9IHRydWVcbiAgICAgICAgaWYoIHR5cGUgKSB7XG4gICAgICAgICAgYXJnc1swXSA9IHR5cGVcbiAgICAgICAgICBpZighICggX3RoaXMuX3ZhbCBpbnN0YW5jZW9mIHZPYmplY3QgKSApIHtcbiAgICAgICAgICAgIF90aGlzLnZhbCA9IHR5cGVcbiAgICAgICAgICB9IFxuICAgICAgICB9XG4gICAgICAgIGlmKCBfdGhpcy5sb2FkaW5nICkgX3RoaXMubG9hZGluZy52YWwgPSBmYWxzZVxuICAgICAgICBvcmlndSgga2lsbCApXG4gICAgICAgIF90aGlzLl9pZ25vcmVWYWx1ZSA9IG51bGxcbiAgICAgIH1cblxuICAgICAgaWYoIHR5cGVvZiB2b2JqID09PSAnb2JqZWN0JyApXG4gICAgICB7XG4gICAgICAgIHZhciBwYXJhbXMgPSB2b2JqXG4gICAgICAgIHZvYmogPSB7fVxuICAgICAgICBmb3IoIHZhciBrZXkgaW4gcGFyYW1zICkge1xuICAgICAgICAgIGlmKCBrZXkgPT09ICdkZWZlcicgKSB7XG4gICAgICAgICAgICB2b2JqW2tleV0gPSBwYXJhbXNba2V5XVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZighdm9ialtrZXldKSB7XG4gICAgICAgICAgICAgIGlmKCBrZXkgIT09ICdjb21wbGV0ZScgJiYga2V5ICE9PSAnZXJyb3InICYmIHR5cGVvZiBwYXJhbXNba2V5XSA9PT0gJ2Z1bmN0aW9uJyApIHtcbiAgICAgICAgICAgICAgICB2b2JqWyBrZXkgXSA9IHBhcmFtc1sga2V5IF0uY2FsbCggX3RoaXMsIHZvYmosIGFyZ3NbMF0sIGFyZ3MgKVxuICAgICAgICAgICAgICAgIGlmKCAhdm9ialtrZXldICkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdm9ialtrZXldID0gcGFyYW1zW2tleV1cbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGlmKCB2b2JqW2tleV0gaW5zdGFuY2VvZiB2T2JqZWN0ICkge1xuICAgICAgICAgICAgICAgIHZvYmpba2V5XSA9IHZvYmpba2V5XS52YWwgLy9jdXN0b20gZ2V0IG9yIHJhd1xuICAgICAgICAgICAgICB9IFxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiggdHlwZW9mIHZvYmogPT09ICdmdW5jdGlvbicgKSBcbiAgICAgIHtcbiAgICAgICAgdm9iaiA9IHZvYmouY2FsbCggX3RoaXMsIHZvYmosIGFyZ3NbMF0sIGFyZ3MgKVxuICAgICAgICBpZighdm9iaikgcmV0dXJuIHRydWVcbiAgICAgIH1cblxuICAgICAgaWYoIHR5cGVvZiB2b2JqID09PSAnc3RyaW5nJyApIFxuICAgICAge1xuICAgICAgICB2b2JqID0geyB1cmw6IHZvYmogfVxuICAgICAgfVxuXG4gICAgICBpZiggdm9iai51cmwgaW5zdGFuY2VvZiB2T2JqZWN0ICkge1xuICAgICAgICB2b2JqLnVybCA9IHZvYmoudXJsLnZhbFxuICAgICAgfVxuXG4gICAgICBpZiggIXZvYmogfHwgISggdm9iai51cmwgfHwgdm9iai5hcGkgKSApIFxuICAgICAge1xuICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgfVxuXG4gICAgICB2YXIgY29tcGxldGUgPSB2b2JqLmNvbXBsZXRlXG4gICAgICAgICwgZXJyb3IgPSB2b2JqLmVycm9yXG5cbiAgICAgIHZvYmouY29tcGxldGUgPSBmdW5jdGlvbiggZGF0YSApIHtcbiAgICAgICAgaWYoIHZvYmouZGVmZXIgKSBcbiAgICAgICAge1xuICAgICAgICAgIHZvYmouZGVmZXIuY2FsbCggX3RoaXMsIHVwZGF0ZSwgYXJncywgbnVsbCwgZGF0YSwgdm9iaiApXG4gICAgICAgIH1cbiAgICAgICAgZWxzZVxuICAgICAgICB7XG4gICAgICAgICAgaWYoIV90aGlzLnJlc3BvbnNlRGF0YSkge1xuICAgICAgICAgICAgX3RoaXMuc2V0KCAncmVzcG9uc2VEYXRhJywgZGF0YSApXG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgX3RoaXMucmVzcG9uc2VEYXRhLm1lcmdlKCBkYXRhIClcbiAgICAgICAgICB9XG4gICAgICAgICAgO2NvbXBsZXRlICYmIGNvbXBsZXRlKCBkYXRhIClcbiAgICAgICAgICB1cGRhdGUoICdzdWNjZXNzJyApXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdm9iai5lcnJvciA9IGZ1bmN0aW9uKCBlcnIgKSB7XG4gICAgICAgIGlmKCB2b2JqLmRlZmVyICkgXG4gICAgICAgIHtcbiAgICAgICAgICB2b2JqLmRlZmVyLmNhbGwoIF90aGlzLCB1cGRhdGUsIGFyZ3MsIGVyciwgdm9iaiApXG4gICAgICAgIH1cbiAgICAgICAgZWxzZVxuICAgICAgICB7XG4gICAgICAgICAgaWYoIF90aGlzLnJlc3BvbnNlRGF0YSApXG4gICAgICAgICAgeyBcbiAgICAgICAgICAgIF90aGlzLnJlc3BvbnNlRGF0YS5lYWNoKCBmdW5jdGlvbigga2V5ICkge1xuICAgICAgICAgICAgICBpZiggIUNvbnN0cnVjdG9yLm9wZXJhdG9yc1trZXldICYmICFDb25zdHJ1Y3Rvci5mbGFnc1trZXldIClcbiAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHRoaXMucmVtb3ZlKClcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSlcbiAgICAgICAgICB9XG4gICAgICAgICAgX3RoaXMuc2V0KCAncmVzcG9uc2VEYXRhJyAsIHZvaWQgMCApXG4gICAgICAgICAgaWYoIGVycm9yICkgZXJyb3IoIGRhdGEgKVxuICAgICAgICAgIHVwZGF0ZSggJ2Vycm9yJyApXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYoIF90aGlzLmxvYWRpbmcgKSB7XG4gICAgICAgIC8vVE9ETzpjb3JyZWN0IHJlc3BvbnNlcyBtYW5hZ2VtZXQgLS0gcHJldHR5IGVhc3kgdG9kb1xuICAgICAgICBfdGhpcy5sb2FkaW5nLnZhbCA9IHRydWVcbiAgICAgIH1cblxuICAgICAgYWpheCggdm9iaiApIC8vVE9ETzogbGV0IGl0IHJldHVybiBhIHByb21pc2VcbiAgICB9ICBcbiAgfVxufSlcblxuLy90ZW1wIGFyZ3MgXG5cbi8vVE9ETzogZGl0IGxhdGVyIHZlcnZhbmdlbiBtZXQgbG9jYWwgZmxhZ3MgKGFwaSlcbi8vVE9ETzogdW5pZnkgYWpheCBoaWVybWVlIHZvb3Igb25jc2l0ZW50IGVycm9yIGhhbmRlbGluZyAtLSBvZiBleHRlbnNpb24gb3AgYWpheFxuZXhwb3J0cy5jcmVhdGUoICdhcGlEZWZlcicsIFxueyByZW1vdmU6IGZ1bmN0aW9uKCByZW1vdmUsIGFyZ3MgKSB7XG4gICAgLy9UT0RPOiBhamF4IGNhbGwgc3RvcFxuICAgIHJlbW92ZS5hcHBseSggdGhpcywgYXJncyApXG4gIH1cbiwgc2V0OmZ1bmN0aW9uKCBzZXQsIGFyZ3MpIHtcbiAgICBpZighIHRoaXMubG9hZGluZyApIHtcbiAgICAgIHRoaXMuc2V0KCAnbG9hZGluZycsIGZhbHNlLCBmYWxzZSwgZmFsc2UsIHRydWUgKVxuICAgIH1cbiAgICBzZXQuYXBwbHkoIHRoaXMsIGFyZ3MgKVxuICB9XG4sIGRlZmVyTWV0aG9kOiBmdW5jdGlvbiggYXJncywgdm9iaiwgdGVtcFN0b3JlLCB1cGRhdGUsIENvbnN0cnVjdG9yICkge1xuICAgIHZhciBfdGhpcyA9IHRoaXMgIFxuICAgXG4gICAgcmV0dXJuIHZvYmogJiYgZnVuY3Rpb24oIHVwZGF0ZSwgYXJncyApIHtcblxuICAgICAgaWYoICFhcmdzWzBdIHx8IGFyZ3NbMF0uYXBpRGVmZXIgKSByZXR1cm4gdHJ1ZVxuXG4gICAgICB2YXIgd3JhcHBlZFVwZGF0ZSA9IGZ1bmN0aW9uKCB2YWwsIGtpbGwgKSB7XG5cbiAgICAgICAgX3RoaXMubG9hZGluZy52YWwgPSBmYWxzZVxuICAgICAgICBpZiggdmFsICYmIHZhbCE9PXRydWUgKSBcbiAgICAgICAge1xuICAgICAgICAgIF90aGlzLnZhbCA9IGFyZ3NbMF0gPSB2YWxcbiAgICAgICAgICBcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgdXBkYXRlKCB2YWwgKSAvL3ZhbCAtLSB2YWxcbiAgICAgICAgICB9IGNhdGNoKCBlcnIgKSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKCAnREVFUEVSIEVSUk9SIElOIEFQSSBERUZFUiAsIFNPTUVUSElORyBUT1VSR0hMWSBXUk9ORyAvdyB0aGlzIEFQSScsIHZhbCApXG4gICAgICAgICAgICAvL2Jlc3QgZXhhbXBsZSBpcyBmYWNlYm9vayBsb2dpbiB0cnVlIGFuZCBnb25lIGJ1dCBvbmx5IHdlaCB0aGUgLmxvYWRpbmcgaXMgdGhlcmVcbiAgICAgICAgICAgIC8vbW9zdCBiZSBhIHZlcnkgZGVlcCBpc3N1ZXMgaSBnZXVzcy4uLiBoYXJkIHRvIHJlY3JlYXRlIFxuICAgICAgICAgICAgX3RoaXMudHlwZSA9IGVyclxuICAgICAgICAgICAgdXBkYXRlKCAnZXJyb3InIClcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBfdGhpcy5jbGVhckNhY2hlKClcbiAgICAgICAgICBfdGhpcy5fdmFsID0gZmFsc2VcbiAgICAgICAgfVxuICAgICAgICBlbHNlIFxuICAgICAgICB7XG4gICAgICAgICAgdXBkYXRlKCB2YWwgKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBcbiAgICAgIF90aGlzLmxvYWRpbmcudmFsID0gdHJ1ZVxuICAgICAgdmFyIGFwaSA9IF90aGlzLmNoZWNrUGFyZW50KCAnYXBpJywgdHJ1ZSApXG5cbiAgICAgIGlmKCBhcGkgJiYgYXBpLnZhbCAhPT0gdHJ1ZSApIFxuICAgICAge1xuXG4gICAgICAgIGFwaS5vbmNlKGZ1bmN0aW9uKCB2YWwgKSB7XG4gICAgICAgICAgaWYoIHZhbCA9PT0gJ2Vycm9yJyApIFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIF90aGlzLmNsZWFyQ2FjaGUoKSAvL2hpZXIgZmYgZWVuIGZ1bmN0aWUgdm9vciBtYWtlbiFcbiAgICAgICAgICAgIF90aGlzLnZhbCA9IGFyZ3NbMF0gPSAnZXJyb3InXG4gICAgICAgICAgICBfdGhpcy50eXBlID0gdGhpcy50eXBlIHx8ICdhcGknXG4gICAgICAgICAgICBfdGhpcy5sb2FkaW5nLnZhbCA9IGZhbHNlXG4gICAgICAgICAgICB3cmFwcGVkVXBkYXRlKClcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSBpZiggdmFsID09PSB0cnVlIClcbiAgICAgICAgICB7XG4gICAgICAgICAgICB2b2JqLmNhbGwoIF90aGlzLCB3cmFwcGVkVXBkYXRlLCBhcmdzIClcbiAgICAgICAgICB9XG4gICAgICAgIH0pXG4gICAgICAgIGFwaS52YWwgPSB0cnVlXG4gICAgICB9IFxuICAgICAgZWxzZVxuICAgICAge1xuICAgICAgICB2b2JqLmNhbGwoIF90aGlzLCB3cmFwcGVkVXBkYXRlLCBhcmdzIClcbiAgICAgIH1cbiAgICB9XG4gIH1cbn0pXG5cbmV4cG9ydHMuY3JlYXRlKCAnaW5pdCcsIFxueyBzZXQ6IGZ1bmN0aW9uKCBzZXQsIGFyZ3MgKSB7XG4gICAgaWYoICF0aGlzLmluaXRpYWxpc2VkIClcbiAgICB7XG4gICAgICBzZXQuYXBwbHkoIHRoaXMsIGFyZ3MgKSAvL25pZXQgbm9kaWchXG4gICAgfVxuICB9XG4sIHJlbW92ZTogZnVuY3Rpb24oIHJlbW92ZSwgYXJncyApIHtcbiAgICByZW1vdmUuYXBwbHkoIHRoaXMsIGFyZ3MgKVxuICAgIHRoaXMuaW5pdGlhbGlzZWQgPSBudWxsXG4gIH1cbiwgb25jZTogJ2luaXRpYWxpc2VkJ1xufSlcblxuIiwiLyohXG4gKiBAbGljZW5zZSBDb3B5cmlnaHQgKGMpIDIwMTItMjAxNCwgVmlnb3VyLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogQGF1dGhvcjogSmltIGRlIEJlZXIsIGppbUB2aWdvdXIuaW9cbiAqL1xudmFyIGZsYWdzID0gbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuLycpO1xuXG4vKipcbiAqIHNlbGZcbiAqIEBmbGFnXG4gKi9cbmZsYWdzLnNlbGYgPSB7XG4gIHJlc2V0OiB0cnVlLFxuICB1c2VWYWw6dHJ1ZSxcbiAgc2V0OiBmdW5jdGlvbih2YWwsIHN0YW1wLCByZXNldCkge1xuICAgIHZhciBjdXJyZW50ID0gdGhpcy5jaGVja1BhcmVudCgnX3Byb3AubmFtZScpXG4gICAgaWYgKGN1cnJlbnQuX2Jhc2UgJiYgY3VycmVudC5fYmFzZVt2YWxdKSB7XG4gICAgICBjdXJyZW50Ll9iYXNlW3ZhbF0uYWRkTGlzdGVuZXIodGhpcylcbiAgICAgIHRoaXMuX3ZhbCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpc1t2YWxdICYmIHRoaXNbdmFsXS52YWxcbiAgICAgIH1cbiAgICAgIGlmKCF0aGlzLl9mbGFnKSAgdGhpcy5fZmxhZyA9IHt9XG4gICAgICB0aGlzLl9mbGFnLnNlbGYgPSBbJ3NlbGYnLCB0aGlzLl92YWwsIHZhbCwgdGhpc11cbiAgICB9XG4gIH1cbn07XG4iLCIvKiFcbiAqIEBsaWNlbnNlIENvcHlyaWdodCAoYykgMjAxMi0yMDE0LCBWaWdvdXIuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBAYXV0aG9yOiBKaW0gZGUgQmVlciwgamltQHZpZ291ci5pb1xuICovXG5cbnZhciBmbGFncyA9IG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi8nKVxuLyoqXG4gKiBsaXN0ZW5cbiAqIGFkZHMgbGlzdGVuZXJzIHRvIGEgVi5WYWx1ZVxuICogQHByb3BlcnR5XG4gKiovXG5mbGFncy5saXN0ZW4gPSB7XG4gIHJlc2V0OnRydWUsXG4gIHNldDogZnVuY3Rpb24odmFsLCBzdGFtcCwgcmVzZXQpIHtcbiAgICBpZighdmFsKVxuICAgIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ25vIHZhbCBpbiBmbGFncyBsaXN0ZW4hJylcbi8vICAgICAgIGRlYnVnZ2VyXG4gICAgICByZXR1cm5cbiAgICB9XG4gICAgaWYoIXRoaXMuX2ZsYWcpIHRoaXMuX2ZsYWcgPSB7fVxuICAgIC8vZXZlbnR1ZWVsIG1lcmdlbiFcbiAgICAgIFxuICAgIC8vIGNvbnNvbGUubG9nKCdsaXN0ZW4nLmN5YW4uaW52ZXJzZSwgcmVzZXQsIHZhbClcbiAgICAvL2lmIHJlc2V0IG1ha2Ugc3VyZSBpdHMgcmVzZXR0ZWQgY29ycmVjdGx5IVxuICAgIHRoaXMuX2ZsYWcubGlzdGVuID0gWydsaXN0ZW4nLCBmYWxzZSwgdmFsLCB0aGlzIF0gXG4gICAgaWYgKHZhbCBpbnN0YW5jZW9mIEFycmF5KSB7XG4gICAgICBmb3IgKHZhciBpID0gdmFsLmxlbmd0aCAtIDE7IGkgPj0gMDsgdmFsW2ktLV0uYWRkTGlzdGVuZXIodGhpcykpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvL29rXG4gICAgICB2YXIgX3RoaXMgPSB0aGlzXG4gICAgICAvLyB2YWwuYWRkTGlzdGVuZXIoZnVuY3Rpb24oKSB7XG4gICAgICAvLyAgIGNvbnNvbGUubG9nKCdUUk9VR0ggTElTVEVOISEhIScubWFnZW50YS5pbnZlcnNlLCB2YWwuX3BhdGgpXG4gICAgICAvLyAgIC8vIF90aGlzLl91cGRhdGUuYXBwbHkoX3RoaXMsIGFyZ3VtZW50cylcbiAgICAgIC8vIH0pIFxuICAgICAgdmFsLmFkZExpc3RlbmVyKHRoaXMpIC8vZGl0IG1vZXQgYmV0ZXIgKHJlbW92ZSBsaXN0ZW5lciBpZiBwb3NzaWJsZSlcbiAgICB9XG4gIH0sXG4gIHJlbW92ZTpmdW5jdGlvbigpIHtcbiAgICBpZih0aGlzLl9mbGFnJiZ0aGlzLl9mbGFnLmxpc3Rlbikge1xuICAgICAgdmFyIHZhbCA9IHRoaXMuX2ZsYWcubGlzdGVuWzJdXG4gICAgICBpZiAodmFsIGluc3RhbmNlb2YgQXJyYXkpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IHZhbC5sZW5ndGggLSAxOyBpID49IDA7IHZhbFtpLS1dLnJlbW92ZUxpc3RlbmVyKHRoaXMpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhbC5yZW1vdmVMaXN0ZW5lcih0aGlzKSAvL2RpdCBtb2V0IGJldGVyIChyZW1vdmUgbGlzdGVuZXIgaWYgcG9zc2libGUpXG4gICAgICB9XG4gICAgfVxuICB9XG59XG4iLCIvKiFcbiAqIEBsaWNlbnNlIENvcHlyaWdodCAoYykgMjAxMi0yMDE0LCBWaWdvdXIuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBAYXV0aG9yOiBKaW0gZGUgQmVlciwgamltQHZpZ291ci5pb1xuICovXG52YXIgb2JqZWN0ID0gcmVxdWlyZSggJy4uL29iamVjdCcgKVxuICAsIHV0aWwgPSByZXF1aXJlKCAnLi4vdXRpbCcgKVxuICAsIHZpZ291ciA9IHJlcXVpcmUoICcuLi8nIClcblxuLyoqXG4gKiB2aWdvdXIuVmFsdWVcbiAqIHYgdmFsdWVzIGFyZSBvcHRpbWl6ZWQgZm9yIHVzZSBpbiBjb21iaW5hdGlvbiAvdyBpbnN0YW5jZXMgb2Ygdmlnb3VyQmFzZSwgaGF2ZSBvcGVyYXRvcnMgYW5kIHN1cHBvcnQgbWV0aG9kIHZhbHVlc1xuICogQENsYXNzXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0cyA9IHZpZ291ci5WYWx1ZSA9IG9iamVjdC5uZXcoXG57IG1peGVkOiB0cnVlXG4sIG1lcmdlOiB0cnVlXG59KVxuXG4vL3BhcmVudCBwcm9ibGVtc1xuXG52YXIgX2dldE9wZXJhdG9yID0gZnVuY3Rpb24oIHZhbCwgZm9yY2UsIGksIHQsIGJpbmQsIG9wZXJhdG9ycyApIHtcbiAgdmFyIGYgPSB0W2ldLl9nZXQoYmluZCwgZm9yY2UsIHZhbCk7XG4gIGlmIChmICE9PSB2b2lkIDAgJiYgZiAhPT0gbnVsbCkge1xuICAgIHZhbCA9IG9wZXJhdG9yc1tpXSh2YWwgfHwgKCh0eXBlb2YgZiA9PT0gJ3N0cmluZycpID8gJycgOiAwKSwgZik7XG4gIH1cbiAgcmV0dXJuIHZhbDtcbn07XG5cbmV4cG9ydHMucHJvdG90eXBlLl9ibGFja2xpc3QucHVzaCgnX2xzdGFtcCcsICdfY2xlYXJDYWNoZScsICdfbHZhbCcsICdfX2x2YWwnLCdfX19sdmFsJywgJ19iYXNlJywgJ19jYWxsZXInLCAnX2JpbmQnLCAnX3Byb3AnLCAnX2luc3RhbmNlcycsICdfc2tpcCcsICdfb3ZlcndyaXRlJylcbi8vX2NhbGxlciBzdGFtcCBmb3IgZ2V0IGZvciBsdmFscyAobGFzdCB2YWx1ZXMpXG51dGlsLmRlZmluZShleHBvcnRzLFxuICAnY2xlYXJDYWNoZScsIGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuX19fbHZhbCA9IG51bGxcbiAgICB0aGlzLl9fbHZhbCA9IG51bGxcbiAgICB0aGlzLl9sdmFsID0gbnVsbCBcbiAgfSxcbiAgLyoqXG4gICAqIFVzZWQgdG8gZ2V0IC52YWwgd2hpY2ggY2FsY3VsYXRlcyBhIGNvbnN0cnVjdGVkIHZhbHVlXG4gICAqIF9iaW5kIGlzIHZlcnkgaW1wb3J0YW50IGJpbmRzIGxpc3RlbmVycyB0byBzcGVjaWZpYyBpbnN0YW5jZXNcbiAgICogQG1ldGhvZCBfZ2V0XG4gICAqIEBwYXJhbSAge1t0eXBlXX0gYmluZCAgW2Rlc2NyaXB0aW9uXVxuICAgKiBAcGFyYW0gIHtbdHlwZV19IGZvcmNlIFtkZXNjcmlwdGlvbl1cbiAgICogQHJldHVybiB7W3R5cGVdfSAgICAgICBbZGVzY3JpcHRpb25dXG4gICAqL1xuICAnX2dldCcsIGZ1bmN0aW9uKGJpbmQsIGZvcmNlLCBjdXJyZW50VmFsKSB7XG5cbiAgICBpZih0aGlzLl9jbGVhckNhY2hlKSB7XG4gICAgICB0aGlzLmNsZWFyQ2FjaGUoKVxuICAgIH1cblxuICAgIC8vIGNvbnNvbGUubG9nKCdfZ2V0Jyx0aGlzLl9uYW1lLCB0aGlzLl92YWwsdGhpcyk7XG4gICAgaWYgKHRoaXMuX292ZXJ3cml0ZSkge1xuICAgICAgcmV0dXJuIHRoaXMuX292ZXJ3cml0ZTtcbiAgICB9XG4gICAgaWYgKCF0aGlzLl9sdmFsICYmIHRoaXMuX2x2YWwgIT09IDAgfHwgZm9yY2UpIHtcbiAgICAgIHZhciB2YWwgPSB0aGlzLl92YWwsXG4gICAgICAgIG5vbHZhbCxcbiAgICAgICAgb3BlcmF0b3JzID0gdGhpcy5vcGVyYXRvcnM7XG5cbiAgICAgIGlmICh2YWwgaW5zdGFuY2VvZiBvYmplY3QpIHtcbiAgICAgICAgdmFsID0gdmFsLl9nZXQodGhpcy5fYmluZCB8fCBiaW5kLCBmb3JjZSwgY3VycmVudFZhbCk7XG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiB2YWwgPT09ICdmdW5jdGlvbicpIHtcblxuICAgICAgICAvLyBjb25zb2xlLmxvZygnUklHSFQgSEVSRScsIGN1cnJlbnRWYWwpXG4gICAgICAgIHZhciBhID0gdGhpcztcbiAgICAgICAgaWYgKCFiaW5kKSB7XG4gICAgICAgICAgd2hpbGUgKGEuX3BhcmVudCAmJiAhYS5fY2FsbGVyKSB7XG4gICAgICAgICAgICBhID0gYS5fcGFyZW50O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB2YWwgPSB2YWwuY2FsbChiaW5kIHx8IGEuX2NhbGxlciB8fCBhLl9iYXNlIHx8IHRoaXMsIHRoaXMsIGN1cnJlbnRWYWwpOyAvL2lmIGN1cnJlbnR2YWwgZWxzZSBzb21ldGhpbmcgZWxzZTtcbiAgICAgICAgbm9sdmFsID0gdHJ1ZTtcbiAgICAgICAgLy9mb3IgZnVuY3Rpb25zIHlvdSBuZWVkIHRvIGNsZWFyIF9sdmFsIHNpbmNlIHlvdSBuZXZlciBrbm93IGlmIHRoZXJlIGlzIHNvbWV0aGluZyBpbiB0aGUgZnVuY3Rpb24gdXBkYXRlZFxuICAgICAgfVxuICAgICAgaWYgKG9wZXJhdG9ycykge1xuICAgICAgICBpZiAodGhpcy5fX3QgPT09IDEgJiYgb3BlcmF0b3JzW3RoaXMuX25hbWVdKSB7IFxuICAgICAgICAgIC8vb3BlcmF0b3IgaXMgYW4gYXJyYXlcbiAgICAgICAgICB2YWwgPSAwOyAvL3N0cmluZ1xuICAgICAgICAgIGZvciAodmFyIGogPSAwLCBsID0gdGhpcy5sZW5ndGg7IGogPCBsOyBqKyspIHtcbiAgICAgICAgICAgIGlmICh0aGlzW2pdKSB7XG4gICAgICAgICAgICAgIHZqID0gdGhpc1tqXS5fZ2V0KGJpbmQsIGZhbHNlLCAoY3VycmVudFZhbCB8fCAwKSArIHZhbCk7XG4gICAgICAgICAgICAgIGlmICghdmopIHtcbiAgICAgICAgICAgICAgICB2aiA9IDA7IC8vc3RyaW5nXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKHR5cGVvZiB2aiA9PT0gJ3N0cmluZycgJiYgdmFsID09PSAwKSB7XG4gICAgICAgICAgICAgICAgdmFsID0gJyc7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgdmFsICs9IHZqOyAvL29ubHkgYWRkIG5vIG9wZXJhdG9yIHN0dWZmXG4gICAgICAgICAgICAgIGlmICghdGhpc1tqXS5fbHZhbCkge1xuICAgICAgICAgICAgICAgIG5vbHZhbCA9IHRydWU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy9hbHNvIGFkZCBiZWZvcmVcbiAgICAgICAgICB2YXIgb3JkZXJlZDtcbiAgICAgICAgICBmb3IgKHZhciBpIGluIHRoaXMpIHtcbiAgICAgICAgICAgIGlmIChvcGVyYXRvcnNbaV0pIHtcbiAgICAgICAgICAgICAgaWYgKCFvcGVyYXRvcnNbaV0ub3JkZXIpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWZvcmNlICYmIHRoaXNbaV0uX2xzdGFtcCAhPT0gdGhpcy5fbHN0YW1wICYmIHRoaXNbaV0uX190ID09PSAxKSB7XG4gICAgICAgICAgICAgICAgICBmb3JjZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhbCA9IF9nZXRPcGVyYXRvcih2YWwsIGZvcmNlLCBpLCB0aGlzLCBiaW5kLCBvcGVyYXRvcnMpO1xuICAgICAgICAgICAgICAgIGlmICghbm9sdmFsICYmICF0aGlzW2ldLl9sdmFsKSB7XG4gICAgICAgICAgICAgICAgICBub2x2YWwgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAob3JkZXJlZCkge1xuICAgICAgICAgICAgICAgICAgaWYgKCFvcmRlcmVkLnBvcCkge1xuICAgICAgICAgICAgICAgICAgICBvcmRlcmVkID0gW29yZGVyZWRdO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgdmFyIG8gPSBvcGVyYXRvcnNbaV0ub3JkZXIsXG4gICAgICAgICAgICAgICAgICAgIG9sID0gb3JkZXJlZC5sZW5ndGggLSAxO1xuICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaCA9IDA7IGggIT09IHRydWUgJiYgaCA8PSBvbDsgaCsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChoID09PSBvbCkge1xuICAgICAgICAgICAgICAgICAgICAgIGlmIChvIDwgb3BlcmF0b3JzW29yZGVyZWRbaF1dLm9yZGVyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgYSA9IG9yZGVyZWRbaF07XG4gICAgICAgICAgICAgICAgICAgICAgICBvcmRlcmVkW29sXSA9IGk7XG4gICAgICAgICAgICAgICAgICAgICAgICBvcmRlcmVkLnB1c2goYSk7XG4gICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9yZGVyZWQucHVzaChpKTtcbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgaCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoaCA9PT0gb2wgJiYgbyA+IG9wZXJhdG9yc1tvcmRlcmVkW2hdXS5vcmRlcikge1xuICAgICAgICAgICAgICAgICAgICAgIG9yZGVyZWQucHVzaChpKTtcbiAgICAgICAgICAgICAgICAgICAgICBoID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICBvcmRlcmVkID0gaTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgLy9zaG9ydGVyXG4gICAgICAgICAgaWYgKG9yZGVyZWQpIHtcbiAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKG9yZGVyZWQpO1xuICAgICAgICAgICAgdmFyIHg7XG4gICAgICAgICAgICBpID0gb3JkZXJlZC5wb3AgPyAoeCA9IDEpICYmIG9yZGVyZWRbMF0gOiBvcmRlcmVkO1xuICAgICAgICAgICAgd2hpbGUgKGkgJiYgdGhpc1tpXSkge1xuICAgICAgICAgICAgICBpZiAoIWZvcmNlICYmIHRoaXNbaV0uX2xzdGFtcCAhPT0gdGhpcy5fbHN0YW1wICYmIHRoaXNbaV0uX190ID09PSAxKSBmb3JjZSA9IHRydWVcbiAgICAgICAgICAgICAgdmFsID0gX2dldE9wZXJhdG9yKHZhbCwgZm9yY2UsIGksIHRoaXMsIGJpbmQsIG9wZXJhdG9ycyk7XG4gICAgICAgICAgICAgIGlmICghbm9sdmFsICYmICF0aGlzW2ldLl9sdmFsKSBub2x2YWwgPSB0cnVlXG4gICAgICAgICAgICAgIGkgPSBvcmRlcmVkW3grK107XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoIW5vbHZhbCAmJiAhZm9yY2UpIHtcbiAgICAgICAgdGhpcy5fbHZhbCA9IHZhbDtcbiAgICAgICAgdGhpcy5fX2x2YWwgPSB2YWw7XG4gICAgICB9IGVsc2UgaWYgKCEodGhpcy5fYmFzZSAmJiB0aGlzLl9iYXNlLmluc3RhbmNlcykpIHtcbiAgICAgICAgdGhpcy5fX2x2YWwgPSB2YWw7XG4gICAgICB9XG4gICAgICByZXR1cm4gdmFsO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdGhpcy5fX2x2YWw7XG4gICAgfVxuICB9LFxuICAvKipcbiAgICogRmlyZXMgYWxsIGxpc3RlbmVyc1xuICAgKiBAbWV0aG9kIHVwZGF0ZVxuICAgKiBAcGFyYW0gIHtbdHlwZV19IGluc3RhbmNlICAgIFtkZXNjcmlwdGlvbl1cbiAgICogQHBhcmFtICB7W3R5cGVdfSBub2luc3RhbmNlcyBbZGVzY3JpcHRpb25dXG4gICAqIEBwYXJhbSAge1t0eXBlXX0gc3RhbXAgICAgICAgW2Rlc2NyaXB0aW9uXVxuICAgKiBAcGFyYW0gIHtbdHlwZV19IGZyb20gICAgICAgIFtkZXNjcmlwdGlvbl1cbiAgICogQHBhcmFtICB7W3R5cGVdfSByZW1vdmUgICAgICBbZGVzY3JpcHRpb25dXG4gICAqIEBwYXJhbSAge1t0eXBlXX0gYWRkZWQgICAgICAgW2Rlc2NyaXB0aW9uXVxuICAgKiBAcmV0dXJuIHtbdHlwZV19ICAgICAgICAgICAgIFtkZXNjcmlwdGlvbl1cbiAgICovXG4gICd1cGRhdGUnLFxuICBmdW5jdGlvbihpbnN0YW5jZSwgbm9pbnN0YW5jZXMsIGluc3RhbmNlc1VwZGF0ZXMsIHN0YW1wLCBmcm9tLCByZW1vdmUsIGFkZGVkKSB7XG4gICAgLy9pcyB0aGlzIHJlYWxseSBuZXNzZWNhcnk/XG4gICAgdGhpcy5fdXBkYXRlLmNhbGwoIHRoaXMsIHZvaWQgMCwgc3RhbXAgfHwgdGhpcy5zdGFtcCgpLCBmcm9tLCByZW1vdmUsIGZhbHNlLCBmYWxzZSwgbm9pbnN0YW5jZXMsIGluc3RhbmNlLCBpbnN0YW5jZXNVcGRhdGVzICApOyAvL3RoaXMudmFsXG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG4gIC8qKlxuICAgKiBFeHRlbmRzIHZpZ291ck9iamVjdC5fdXBkYXRlXG4gICAqIEFkZHMgbG9hZHMgb2Ygc3R1ZmYgdG8gb3B0aW1pemUgdXBkYXRlcyBmb3IgY2FsY3VsYXRpb25zXG4gICAqIEBtZXRob2QgX3VwZGF0ZVxuICAgKiBAcGFyYW0gIHtbdHlwZV19IHZhbCAgICAgICAgIFtkZXNjcmlwdGlvbl1cbiAgICogQHBhcmFtICB7W3R5cGVdfSBzdGFtcCAgICAgICBbZGVzY3JpcHRpb25dXG4gICAqIEBwYXJhbSAge1t0eXBlXX0gZnJvbSAgICAgICAgW2Rlc2NyaXB0aW9uXVxuICAgKiBAcGFyYW0gIHtbdHlwZV19IHJlbW92ZSAgICAgIFtkZXNjcmlwdGlvbl1cbiAgICogQHBhcmFtICB7W3R5cGVdfSBhZGRlZCAgICAgICBbZGVzY3JpcHRpb25dXG4gICAqIEBwYXJhbSAge1t0eXBlXX0gbm9pbnN0YW5jZXMgW2Rlc2NyaXB0aW9uXVxuICAgKiBAcGFyYW0gIHtbdHlwZV19IGluc3RhbmNlICAgIFtkZXNjcmlwdGlvbl1cbiAgICogQHJldHVybiB7W3R5cGVdfSAgICAgICAgICAgICBbZGVzY3JpcHRpb25dXG4gICAqL1xuICAnX3VwZGF0ZScsXG4gIGZ1bmN0aW9uKCB2YWwsIHN0YW1wLCBmcm9tLCByZW1vdmUsIGFkZGVkLCBvbGR2YWwsIG5vaW5zdGFuY2VzLCBpbnN0YW5jZSwgaW5zdGFuY2VzVXBkYXRlcyApIHtcblxuICAgIHZhciB0ID0gdGhpcyxcbiAgICAgIGJhc2UgPSB0Ll9iYXNlO1xuXG4gICAgaWYgKHZhbCBpbnN0YW5jZW9mIGV4cG9ydHMgJiYgIXQuX2JpbmQpIFxuICAgIHtcbiAgICAgIC8vIGNvbnNvbGUubG9nKCdsZXRzIGJpbmQnLmJvbGQuaW52ZXJzZSwgdmFsLl9uYW1lKVxuICAgICAgaWYgKHZhbC5fY2FsbGVyKSB7XG4gICAgICAgIHQuX2JpbmQgPSB2YWwuX2NhbGxlcjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZih0Ll9jbGVhckNhY2hlKSB7XG4gICAgICB0LmNsZWFyQ2FjaGUoKVxuICAgIH1cblxuICAgIGlmICggKCF0Ll9sc3RhbXApIHx8IHQuX2xzdGFtcCAhPT0gc3RhbXAgICkgXG4gICAge1xuXG4gICAgICB0Ll9sdmFsID0gZmFsc2VcblxuICAgICAgLy9fc2tpcCBwcm9wZXJ0eSBtYWtlcyBzdXJlIHRoYXQgdGhlIC52YWwgaXMgbmV2ZXIgY2FjaGVkIGluIGx2YWxcbiAgICAgIGlmIChiYXNlICYmIGJhc2UuaW5zdGFuY2VzIHx8IHQuX3NraXAgfHwgdC5fX2x2YWwgPT09IHZvaWQgMCB8fCB0Ll9fX2x2YWwgIT09IHQudmFsKSB7IC8vcGFzcyB0aGlzIGNhbGN1bGF0aW9uIHRvIHZzZXQgZWxzZSBpdHMgdG9vIGhlYXZ5O1xuXG4gICAgICAgIHZhciBvcGVyYXRvcnMgPSB0Lm9wZXJhdG9ycyxcbiAgICAgICAgICBwcm9wID0gdC5fcHJvcCxcbiAgICAgICAgICBwYXJlbnQgPSB0Ll9wYXJlbnQsXG4gICAgICAgICAgdnNldCA9IHByb3AgJiYgcHJvcC5fdnNldDtcblxuICAgICAgICBpZiAoIShmcm9tICYmIHJlbW92ZSkgJiYgb3BlcmF0b3JzICYmIChvcGVyYXRvcnNbdC5fbmFtZV0gfHwgKHBhcmVudCAmJiBwYXJlbnQuX190ID09PSAxICYmIG9wZXJhdG9yc1twYXJlbnQuX25hbWVdICYmICghZnJvbSB8fCB0Ll9uYW1lID09IHBhcmVudC5sZW5ndGggLSAxKSkpKSB7XG4gICAgICAgICAgLy93b3JrcyBmb3IgYXJyYXlzIHNpbmNlIGFycmF5cyBhcmUgYWx3YXlzIHJlcGxhY2VkIG9uIHVwZGF0ZSAsIHVwZGF0aW5nIGFuIGluZGl2aWR1YWwgaXRlbSB1c2luZyAuc2V0IHdpbGwgbm90IHJlc3VsdCBpbiBhbiB1cGRhdGUgYXQgdGhpcyBwb250IHdoaWNoIGhhcyB0byBiZSByZXNvbHZlZFxuICAgICAgICAgIF9vcCA9IHRoaXMuX3BhcmVudDtcbiAgICAgICAgICBcbiAgICAgICAgICB3aGlsZSAob3BlcmF0b3JzW19vcC5fbmFtZV0pIHtcbiAgICAgICAgICAgIF9vcC5fbHZhbCA9IGZhbHNlOyAvL2lmIG5vIGNoYW5nZSB0byBsdmFsIGNhbiBnbyB3cm9uZy4uLlxuICAgICAgICAgICAgX29wID0gX29wLl9wYXJlbnQ7XG4gICAgICAgICAgfVxuICAgICAgICAgIFxuICAgICAgICAgIGlmIChfb3ApIHtcbiAgICAgICAgICAgIF9vcC5fdXBkYXRlKHZhbCwgc3RhbXAsIHRoaXMsIHJlbW92ZSwgYWRkZWQsIG9sZHZhbCwgbm9pbnN0YW5jZXMsIGluc3RhbmNlLCBpbnN0YW5jZXNVcGRhdGVzKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpbnN0YW5jZXNVcGRhdGVzKSB7XG4gICAgICAgICAgaW5zdGFuY2VzVXBkYXRlcy5jYWxsKHQsIHZhbCwgc3RhbXAsIGZyb20sIHJlbW92ZSwgYWRkZWQsIG9sZHZhbCwgbm9pbnN0YW5jZXMsIGluc3RhbmNlLCBpbnN0YW5jZXNVcGRhdGVzKTtcbiAgICAgICAgfSBlbHNlIHtcblxuICAgICAgICAgIGlmIChpbnN0YW5jZSkge1xuICAgICAgICAgICAgYmFzZSA9IGluc3RhbmNlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmICh2c2V0KSB7XG4gICAgICAgICAgICB0Ll9jYWxsZXIgPSBiYXNlO1xuICAgICAgICAgICAgdnNldC5jYWxsKHQsIHN0YW1wLCBmcm9tLCByZW1vdmUsIHZhbCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChiYXNlICYmIHZzZXQgJiYgYmFzZS5pbnN0YW5jZXMgJiYgIW5vaW5zdGFuY2VzICYmIHByb3AudXBkYXRlaW5zdGFuY2VzICE9PSBmYWxzZSkge1xuICAgICAgICAgICAgYmFzZS5lYWNoSW5zdGFuY2UoZnVuY3Rpb24oKSB7IC8vbG9vayBmb3IgY3VycmVudCBjYWxsZXIgaW5zdGFuY2UgcGVyaGFwcz9cbiAgICAgICAgICAgICAgdC5fY2FsbGVyID0gdGhpcztcbiAgICAgICAgICAgICAgdnNldC5jYWxsKHQsIHN0YW1wLCBmcm9tLCByZW1vdmUsIHZhbCk7XG4gICAgICAgICAgICB9LCBwcm9wLm5hbWUsIHQpO1xuICAgICAgICAgICAgdC5fY2FsbGVyID0gYmFzZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvL2Zvcm0gZ29uZSBsZXRzIHNlZSFcbiAgICAgICAgICAvL2Zyb20gc2VsZiBkb29yZ2V2ZW4gaW4gY2hhaW4gPT0tLSBpZiAhIG5vdCBmcm9tIGZyb20gLS0tPiAsIGV4dHJhIGFyZ1xuXG4gICAgICAgICAgb2JqZWN0LnByb3RvdHlwZS5fdXBkYXRlLmNhbGwodCwgdmFsLCBzdGFtcCwgZnJvbSB8fCB0LCByZW1vdmUsIGFkZGVkLCBvbGR2YWwpXG5cbiAgICAgICAgfVxuXG4gICAgICAgIC8vcGFzIG9wIG1ldCBkZXplIVxuICAgICAgICB0Ll9fX2x2YWwgPSB0Ll9fbHZhbFxuICAgICAgICB0Ll9sc3RhbXAgPSBzdGFtcDtcblxuICAgICAgfVxuXG4gICAgfVxuICB9KVxuXG4vL3JlcXVpcmluZyBvcGVyYXRvcnMgZG9lcyBub3QgYXV0b21hdGljbHkgcmVxdWlyZSB2aWdvdXJWYWx1ZSwgbWF5IGJlIGhhbmR5P1xudXRpbC5kZWZpbmUoZXhwb3J0cywgJ29wZXJhdG9ycycsIHtcbiAgdmFsdWU6IGV4cG9ydHMub3BlcmF0b3JzID0gcmVxdWlyZSgnLi9vcGVyYXRvcnMnKVxufSlcblxuXG5cblxuIiwiLyohXG4gKiBAbGljZW5zZSBDb3B5cmlnaHQgKGMpIDIwMTItMjAxNCwgVmlnb3VyLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogQGF1dGhvcjogSmltIGRlIEJlZXIsIGppbUB2aWdvdXIuaW9cbiAqL1xuXG4gIC8qXG4gICAgRXh0ZW5zaW9uIGZvciBCYXNlIGNsYXNzZXMgdG8gY3JlYXRlIGFuIGluaGVyaXRhYmxlIG9uIC0gdmFsdWVcbiAgKi9cblxudmFyIFZhbHVlID0gcmVxdWlyZSgnLi8nKVxuICAsIHV0aWwgPSByZXF1aXJlKCcuLi91dGlsJylcbiAgLCBCYXNlID0gcmVxdWlyZSgnLi4vYmFzZScpXG5cbmV4cG9ydHMuZXh0ZW5kID0gdXRpbC5leHRlbmRcbiggZnVuY3Rpb24oYmFzZSlcbiAge1xuICAgIGlmKCBiYXNlIGluc3RhbmNlb2YgQmFzZSApXG4gICAge1xuXG4gICAgICBiYXNlLmV4dGVuZFxuICAgICAgKFxuICAgICAgICB7XG4gICAgICAgICAgbmFtZTonb24nLFxuICAgICAgICAgIHNldDpmdW5jdGlvbih2YWwpIHtcbiAgICAgICAgICAgIFxuICAgICAgICAgIH0sXG4gICAgICAgICAgcmVtb3ZlOmZ1bmN0aW9uKHZhbCkge1xuICAgICAgICAgICAgLy9yZW1vdmVcbiAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKCdpbSBiZWluZyByZW1vdmVkIScpXG4gICAgICAgICAgICAgaWYodGhpcy5vbi4kcmVtb3ZlKSB7XG4gICAgICAgICAgICAgIHRoaXMub24uJHJlbW92ZS51cGRhdGUoKVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sXG4gICAgICAgICAgbmV3OmZ1bmN0aW9uKHZhbCkge1xuICAgICAgICAgICAgLy9pbml0XG4gICAgICAgICAgICAvLyBjb25zb2xlLmxvZygnSU5JVCEtLS0tJywgdGhpcywgdmFsLCBhcmd1bWVudHMpXG4gICAgICAgICAgICBpZih0aGlzLm9uLiRuZXcpIHtcbiAgICAgICAgICAgICAgdGhpcy5vbi4kbmV3LnVwZGF0ZSgpXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSxcbiAgICAgICAgICBwYXJlbnQ6ZnVuY3Rpb24odmFsKSB7XG4gICAgICAgICAgICAvL2luaXRcbiAgICAgICAgICAgIGlmKHRoaXMub24uJHBhcmVudCkge1xuICAgICAgICAgICAgICB0aGlzLm9uLiRwYXJlbnQudXBkYXRlKClcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LFxuICAgICAgICAgIHJlbmRlcjpmdW5jdGlvbih2YWwpIHtcbiAgICAgICAgICAgIC8vaW5pdFxuICAgICAgICAgICAgLy8gY29uc29sZS5sb2coJ1JFTkRFUiEtLS0tJywgdGhpcywgdmFsLCBhcmd1bWVudHMpXG4gICAgICAgICAgICBpZih0aGlzLm9uLiRyZW5kZXIpIHtcbiAgICAgICAgICAgICAgdGhpcy5vbi4kcmVuZGVyLnVwZGF0ZSgpXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICApXG5cbiAgICB9XG4gICAgZWxzZVxuICAgIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoICdleHRlbmQgb24gYmFzZScgKVxuICAgIH1cbiAgfVxuKVxuIiwiLyoqXG4gKiBvcGVyYXRvcnNcbiAqIG9wZXJhdG9ycyBjYW4gYmUgc2V0IG9uIFYuVmFsdWUub3BlcmF0b3JzXG4gKiBkZWZpbmUgb3BlcmF0b3JzIG9uIHRoaXMgbW9kdWxlXG4gKiBAcHJvcGVydHlcbiAqL1xudmFyIHV0aWwgPSByZXF1aXJlKCcuLi91dGlsJylcbiAgLCBWID0gcmVxdWlyZSgnLi4vJylcblxuZXhwb3J0cy5hZGQgPSBmdW5jdGlvbiggdmFsLCBvcGVyYXRvciApIHtcbiAgcmV0dXJuIHZhbCArIG9wZXJhdG9yXG59XG5leHBvcnRzLnN1YiA9IGZ1bmN0aW9uKCB2YWwsIG9wZXJhdG9yICkge1xuICByZXR1cm4gdmFsIC0gb3BlcmF0b3Jcbn1cbmV4cG9ydHMubXVsdGlwbHkgPSBmdW5jdGlvbiggdmFsLCBvcGVyYXRvciApIHtcbiAgcmV0dXJuIHZhbCAqIG9wZXJhdG9yXG59XG5leHBvcnRzLmRpdmlkZSA9IGZ1bmN0aW9uKCB2YWwsIG9wZXJhdG9yICkge1xuICByZXR1cm4gdmFsIC8gb3BlcmF0b3Jcbn1cbmV4cG9ydHMubWF4ID0gZnVuY3Rpb24oIHZhbCwgb3BlcmF0b3IgKSB7XG4gIHJldHVybiB2YWwgPiBvcGVyYXRvciA/IG9wZXJhdG9yIDogdmFsXG59XG5leHBvcnRzLm1pbiA9IGZ1bmN0aW9uKCB2YWwsIG9wZXJhdG9yICkge1xuICByZXR1cm4gdmFsIDwgb3BlcmF0b3IgPyBvcGVyYXRvciA6IHZhbFxufVxuZXhwb3J0cy50cmFuc2Zvcm0gPSBmdW5jdGlvbiggdmFsLCBvcGVyYXRvciApIHtcbiAgcmV0dXJuIG9wZXJhdG9yPT09ZmFsc2UgPyB2YWwgOiBvcGVyYXRvclxufVxuZXhwb3J0cy5hYnMgPSBmdW5jdGlvbiggdmFsLCBvcGVyYXRvciApIHtcbiAgcmV0dXJuIG9wZXJhdG9yID8gTWF0aC5hYnModmFsKSA6IHZhbFxufVxuZXhwb3J0cy5mbG9vciA9IGZ1bmN0aW9uKCB2YWwsIG9wZXJhdG9yICkge1xuICByZXR1cm4gdmFsIHwgMFxufVxuZXhwb3J0cy5jZWlsID0gZnVuY3Rpb24gKCB2YWwsIG9wZXJhdG9yICkge1xuICByZXR1cm4gTWF0aC5jZWlsKCB2YWwgKVxufVxuZXhwb3J0cy4kY29udmVydFR5cGUgPSBmdW5jdGlvbiAoIHZhbCwgb3BlcmF0b3IgKSB7XG4gIC8vY29udmVydFR5cGVcbiAgaWYoIG9wZXJhdG9yID09PSAnYm9vbGVhbicgKVxuICB7IFxuICAgIHJldHVybiB2YWwgPyB0cnVlIDogZmFsc2VcbiAgfSBcbiAgZWxzZSBpZiggb3BlcmF0b3IgPT09ICdudW1iZXInIClcbiAge1xuICAgIC8vZG8gaXNOYW4gc3RhcnQgdXNpbmcgbG9EYXNoIGZvciB0aGlzIGtpbmQgb2Ygc3R1ZmYgKCBhbG1vc3Qgbm90aGluZyApXG4gICAgLy9jb252ZXJ0IGZhbHN5IG9yIE5hTiB2YWx1ZXMgdG8gMFxuICAgIHJldHVybiBOdW1iZXIoIHZhbCApXG4gIH1cbn1cblxuZXhwb3J0cy5kZWZhdWx0ID0gZnVuY3Rpb24oIHZhbCwgb3BlcmF0b3IgKSB7XG5cbi8vIGNvbnNvbGUubG9nKCAnPz8/PycsIHZhbCApXG4gIFxuICAvL3BhcyBvcCBtZXQgZGllIDBcbiAgaWYoICghdmFsICYmIHZhbCAhPT0gMCkgfHwgdmFsLl92YWwgPT09IGZhbHNlIHx8IHZhbCA9PT0gJ2Vycm9yJyB8fCB2YWwgPT09ICdzdWNjZXNzJyApXG4gIHtcbiAgICAvL1RPRE86IEFycmF5cyBmb3IgZGVmYXVsdCBvcGVyYXRvclxuICAgIHJldHVybiBvcGVyYXRvclxuICB9XG4gIHJldHVybiB2YWxcbn1cbmV4cG9ydHMuZGVmYXVsdC5vcmRlciA9IDEwMDAiLCIvLyBzaGltIGZvciB1c2luZyBwcm9jZXNzIGluIGJyb3dzZXJcblxudmFyIHByb2Nlc3MgPSBtb2R1bGUuZXhwb3J0cyA9IHt9O1xuXG5wcm9jZXNzLm5leHRUaWNrID0gKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgY2FuU2V0SW1tZWRpYXRlID0gdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCdcbiAgICAmJiB3aW5kb3cuc2V0SW1tZWRpYXRlO1xuICAgIHZhciBjYW5Qb3N0ID0gdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCdcbiAgICAmJiB3aW5kb3cucG9zdE1lc3NhZ2UgJiYgd2luZG93LmFkZEV2ZW50TGlzdGVuZXJcbiAgICA7XG5cbiAgICBpZiAoY2FuU2V0SW1tZWRpYXRlKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoZikgeyByZXR1cm4gd2luZG93LnNldEltbWVkaWF0ZShmKSB9O1xuICAgIH1cblxuICAgIGlmIChjYW5Qb3N0KSB7XG4gICAgICAgIHZhciBxdWV1ZSA9IFtdO1xuICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignbWVzc2FnZScsIGZ1bmN0aW9uIChldikge1xuICAgICAgICAgICAgdmFyIHNvdXJjZSA9IGV2LnNvdXJjZTtcbiAgICAgICAgICAgIGlmICgoc291cmNlID09PSB3aW5kb3cgfHwgc291cmNlID09PSBudWxsKSAmJiBldi5kYXRhID09PSAncHJvY2Vzcy10aWNrJykge1xuICAgICAgICAgICAgICAgIGV2LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgICAgICAgIGlmIChxdWV1ZS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBmbiA9IHF1ZXVlLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgICAgIGZuKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9LCB0cnVlKTtcblxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gbmV4dFRpY2soZm4pIHtcbiAgICAgICAgICAgIHF1ZXVlLnB1c2goZm4pO1xuICAgICAgICAgICAgd2luZG93LnBvc3RNZXNzYWdlKCdwcm9jZXNzLXRpY2snLCAnKicpO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIHJldHVybiBmdW5jdGlvbiBuZXh0VGljayhmbikge1xuICAgICAgICBzZXRUaW1lb3V0KGZuLCAwKTtcbiAgICB9O1xufSkoKTtcblxucHJvY2Vzcy50aXRsZSA9ICdicm93c2VyJztcbnByb2Nlc3MuYnJvd3NlciA9IHRydWU7XG5wcm9jZXNzLmVudiA9IHt9O1xucHJvY2Vzcy5hcmd2ID0gW107XG5cbmZ1bmN0aW9uIG5vb3AoKSB7fVxuXG5wcm9jZXNzLm9uID0gbm9vcDtcbnByb2Nlc3MuYWRkTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5vbmNlID0gbm9vcDtcbnByb2Nlc3Mub2ZmID0gbm9vcDtcbnByb2Nlc3MucmVtb3ZlTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5yZW1vdmVBbGxMaXN0ZW5lcnMgPSBub29wO1xucHJvY2Vzcy5lbWl0ID0gbm9vcDtcblxucHJvY2Vzcy5iaW5kaW5nID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuYmluZGluZyBpcyBub3Qgc3VwcG9ydGVkJyk7XG59XG5cbi8vIFRPRE8oc2h0eWxtYW4pXG5wcm9jZXNzLmN3ZCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuICcvJyB9O1xucHJvY2Vzcy5jaGRpciA9IGZ1bmN0aW9uIChkaXIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuY2hkaXIgaXMgbm90IHN1cHBvcnRlZCcpO1xufTtcbiJdfQ==
